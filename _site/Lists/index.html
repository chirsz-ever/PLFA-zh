<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Lists: 列表与高阶函数 | 编程语言基础：Agda 描述
</title><!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Lists: 列表与高阶函数" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="编程语言基础：Agda 描述" />
<meta property="og:description" content="编程语言基础：Agda 描述" />
<link rel="canonical" href="https://agda-zh.github.io/PLFA-zh/Lists/" />
<meta property="og:url" content="https://agda-zh.github.io/PLFA-zh/Lists/" />
<meta property="og:site_name" content="编程语言基础：Agda 描述" />
<script type="application/ld+json">
{"description":"编程语言基础：Agda 描述","@type":"WebPage","url":"https://agda-zh.github.io/PLFA-zh/Lists/","headline":"Lists: 列表与高阶函数","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/PLFA-zh/assets/main.css"></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/PLFA-zh/">编程语言基础：Agda 描述
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/PLFA-zh/">本书</a>
                <!--!>
                <a class="page-link" href="/PLFA-zh/Announcements/">公告</a>
                <---->
                <a class="page-link" href="/PLFA-zh/GettingStarted/">使用说明</a>
                <a class="page-link" href="/PLFA-zh/Citing/">引用</a>
                <a class="page-link" href="https://plfa.github.io/">English</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
      <h1 class="post-title">Lists: 列表与高阶函数</h1>
  </header>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Decidable/">前一章</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/Lists.lagda">源代码</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/PLFA-zh/Lambda/">后一章</a>
    
</p>


  <div class="post-content">
    <pre class="Agda"><a id="179" class="Keyword">module</a> <a id="186" href="/PLFA-zh/Lists/" class="Module">plfa.Lists</a> <a id="197" class="Keyword">where</a></pre>

<!-- This chapter discusses the list data type.  It gives further examples
of many of the techniques we have developed so far, and provides
examples of polymorphic types and higher-order functions. -->

<p>本章节讨论列表（List）数据类型。我们用列表作为例子，来使用我们之前学习的技巧。同时，列表也给我们带来多态类型（Polymorphic Types）和高阶函数（Higher-order Functions）的例子。</p>

<!-- ## Imports -->

<h2 id="导入">导入</h2>

<pre class="Agda"><a id="586" class="Keyword">import</a> <a id="593" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="631" class="Symbol">as</a> <a id="634" class="Module">Eq</a>
<a id="637" class="Keyword">open</a> <a id="642" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="645" class="Keyword">using</a> <a id="651" class="Symbol">(</a><a id="652" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">_≡_</a><a id="655" class="Symbol">;</a> <a id="657" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="661" class="Symbol">;</a> <a id="663" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.Core.html#838" class="Function">sym</a><a id="666" class="Symbol">;</a> <a id="668" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.Core.html#887" class="Function">trans</a><a id="673" class="Symbol">;</a> <a id="675" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a><a id="679" class="Symbol">)</a>
<a id="681" class="Keyword">open</a> <a id="686" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#3975" class="Module">Eq.≡-Reasoning</a>
<a id="701" class="Keyword">open</a> <a id="706" class="Keyword">import</a> <a id="713" href="https://agda.github.io/agda-stdlib/v0.17/Data.Bool.html" class="Module">Data.Bool</a> <a id="723" class="Keyword">using</a> <a id="729" class="Symbol">(</a><a id="730" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Bool.html#67" class="Datatype">Bool</a><a id="734" class="Symbol">;</a> <a id="736" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Bool.html#92" class="InductiveConstructor">true</a><a id="740" class="Symbol">;</a> <a id="742" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Bool.html#86" class="InductiveConstructor">false</a><a id="747" class="Symbol">;</a> <a id="749" href="https://agda.github.io/agda-stdlib/v0.17/Data.Bool.Base.html#864" class="Function">T</a><a id="750" class="Symbol">;</a> <a id="752" href="https://agda.github.io/agda-stdlib/v0.17/Data.Bool.Base.html#1012" class="Function Operator">_∧_</a><a id="755" class="Symbol">;</a> <a id="757" href="https://agda.github.io/agda-stdlib/v0.17/Data.Bool.Base.html#1070" class="Function Operator">_∨_</a><a id="760" class="Symbol">;</a> <a id="762" href="https://agda.github.io/agda-stdlib/v0.17/Data.Bool.Base.html#730" class="Function">not</a><a id="765" class="Symbol">)</a>
<a id="767" class="Keyword">open</a> <a id="772" class="Keyword">import</a> <a id="779" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.html" class="Module">Data.Nat</a> <a id="788" class="Keyword">using</a> <a id="794" class="Symbol">(</a><a id="795" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="796" class="Symbol">;</a> <a id="798" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a><a id="802" class="Symbol">;</a> <a id="804" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a><a id="807" class="Symbol">;</a> <a id="809" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a><a id="812" class="Symbol">;</a> <a id="814" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#433" class="Primitive Operator">_*_</a><a id="817" class="Symbol">;</a> <a id="819" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#320" class="Primitive Operator">_∸_</a><a id="822" class="Symbol">;</a> <a id="824" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Base.html#845" class="Datatype Operator">_≤_</a><a id="827" class="Symbol">;</a> <a id="829" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Base.html#910" class="InductiveConstructor">s≤s</a><a id="832" class="Symbol">;</a> <a id="834" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Base.html#868" class="InductiveConstructor">z≤n</a><a id="837" class="Symbol">)</a>
<a id="839" class="Keyword">open</a> <a id="844" class="Keyword">import</a> <a id="851" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="871" class="Keyword">using</a>
  <a id="879" class="Symbol">(</a><a id="880" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Properties.html#9375" class="Function">+-assoc</a><a id="887" class="Symbol">;</a> <a id="889" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Properties.html#9476" class="Function">+-identityˡ</a><a id="900" class="Symbol">;</a> <a id="902" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Properties.html#9531" class="Function">+-identityʳ</a><a id="913" class="Symbol">;</a> <a id="915" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Properties.html#15493" class="Function">*-assoc</a><a id="922" class="Symbol">;</a> <a id="924" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Properties.html#14397" class="Function">*-identityˡ</a><a id="935" class="Symbol">;</a> <a id="937" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Properties.html#14461" class="Function">*-identityʳ</a><a id="948" class="Symbol">)</a>
<a id="950" class="Keyword">open</a> <a id="955" class="Keyword">import</a> <a id="962" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="979" class="Keyword">using</a> <a id="985" class="Symbol">(</a><a id="986" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#464" class="Function Operator">¬_</a><a id="988" class="Symbol">;</a> <a id="990" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#534" class="Datatype">Dec</a><a id="993" class="Symbol">;</a> <a id="995" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#570" class="InductiveConstructor">yes</a><a id="998" class="Symbol">;</a> <a id="1000" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#597" class="InductiveConstructor">no</a><a id="1002" class="Symbol">)</a>
<a id="1004" class="Keyword">open</a> <a id="1009" class="Keyword">import</a> <a id="1016" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html" class="Module">Data.Product</a> <a id="1029" class="Keyword">using</a> <a id="1035" class="Symbol">(</a><a id="1036" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#1353" class="Function Operator">_×_</a><a id="1039" class="Symbol">;</a> <a id="1041" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#881" class="Function">∃</a><a id="1042" class="Symbol">;</a> <a id="1044" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#942" class="Function">∃-syntax</a><a id="1052" class="Symbol">)</a> <a id="1054" class="Keyword">renaming</a> <a id="1063" class="Symbol">(</a><a id="1064" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">_,_</a> <a id="1068" class="Symbol">to</a> <a id="1071" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="1076" class="Symbol">)</a>
<a id="1078" class="Keyword">open</a> <a id="1083" class="Keyword">import</a> <a id="1090" href="https://agda.github.io/agda-stdlib/v0.17/Function.html" class="Module">Function</a> <a id="1099" class="Keyword">using</a> <a id="1105" class="Symbol">(</a><a id="1106" href="https://agda.github.io/agda-stdlib/v0.17/Function.html#769" class="Function Operator">_∘_</a><a id="1109" class="Symbol">)</a>
<a id="1111" class="Keyword">open</a> <a id="1116" class="Keyword">import</a> <a id="1123" href="https://agda.github.io/agda-stdlib/v0.17/Level.html" class="Module">Level</a> <a id="1129" class="Keyword">using</a> <a id="1135" class="Symbol">(</a><a id="1136" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Primitive.html#408" class="Postulate">Level</a><a id="1141" class="Symbol">)</a>
<a id="1143" class="Keyword">open</a> <a id="1148" class="Keyword">import</a> <a id="1155" href="/PLFA-zh/Isomorphism/" class="Module">plfa.Isomorphism</a> <a id="1172" class="Keyword">using</a> <a id="1178" class="Symbol">(</a><a id="1179" href="/PLFA-zh/Isomorphism/#5561" class="Record Operator">_≃_</a><a id="1182" class="Symbol">;</a> <a id="1184" href="/PLFA-zh/Isomorphism/#15182" class="Record Operator">_⇔_</a><a id="1187" class="Symbol">)</a></pre>

<!-- ## Lists -->

<h2 id="列表">列表</h2>

<!-- Lists are defined in Agda as follows: -->

<p>Agda 中的列表如下定义：</p>
<pre class="Agda"><a id="1320" class="Keyword">data</a> <a id="List"></a><a id="1325" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="1330" class="Symbol">(</a><a id="1331" href="/PLFA-zh/Lists/#1331" class="Bound">A</a> <a id="1333" class="Symbol">:</a> <a id="1335" class="PrimitiveType">Set</a><a id="1338" class="Symbol">)</a> <a id="1340" class="Symbol">:</a> <a id="1342" class="PrimitiveType">Set</a> <a id="1346" class="Keyword">where</a>
  <a id="List.[]"></a><a id="1354" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>  <a id="1358" class="Symbol">:</a> <a id="1360" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="1365" href="/PLFA-zh/Lists/#1331" class="Bound">A</a>
  <a id="List._∷_"></a><a id="1369" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">_∷_</a> <a id="1373" class="Symbol">:</a> <a id="1375" href="/PLFA-zh/Lists/#1331" class="Bound">A</a> <a id="1377" class="Symbol">→</a> <a id="1379" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="1384" href="/PLFA-zh/Lists/#1331" class="Bound">A</a> <a id="1386" class="Symbol">→</a> <a id="1388" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="1393" href="/PLFA-zh/Lists/#1331" class="Bound">A</a>

<a id="1396" class="Keyword">infixr</a> <a id="1403" class="Number">5</a> <a id="1405" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">_∷_</a></pre>

<!-- Let's unpack this definition. If `A` is a set, then `List A` is a set.
The next two lines tell us that `[]` (pronounced _nil_) is a list of
type `A` (often called the _empty_ list), and that `_∷_` (pronounced
_cons_, short for _constructor_) takes a value of type `A` and a value
of type `List A` and returns a value of type `List A`.  Operator `_∷_`
has precedence level 5 and associates to the right. -->

<p>我们来仔细研究这个定义。如果 <code class="highlighter-rouge">A</code> 是个集合，那么 <code class="highlighter-rouge">List A</code> 也是一个集合。接下来的两行告诉我们
<code class="highlighter-rouge">[]</code> （读作 <em>nil</em>）是一个类型为 <code class="highlighter-rouge">A</code> 的列表（通常被叫做<em>空</em>列表），<code class="highlighter-rouge">_∷_</code>（读作 <em>cons</em>，是
<em>constructor</em> 的简写）取一个类型为 <code class="highlighter-rouge">A</code> 的值，和一个类型为 <code class="highlighter-rouge">List A</code> 的值，返回一个类型为
<code class="highlighter-rouge">List A</code> 的值。<code class="highlighter-rouge">_∷_</code> 运算符的优先级是 5，向右结合。</p>

<!-- For example, -->

<p>例如：</p>

<pre class="Agda"><a id="2100" href="/PLFA-zh/Lists/#2100" class="Function">_</a> <a id="2102" class="Symbol">:</a> <a id="2104" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="2109" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="2111" class="Symbol">_</a> <a id="2113" class="Symbol">=</a> <a id="2115" class="Number">0</a> <a id="2117" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="2119" class="Number">1</a> <a id="2121" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="2123" class="Number">2</a> <a id="2125" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="2127" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a></pre>

<!-- denotes the list of the first three natural numbers.  Since `_∷_`
associates to the right, the term parses as `0 ∷ (1 ∷ (2 ∷ []))`.
Here `0` is the first element of the list, called the _head_,
and `1 ∷ (2 ∷ [])` is a list of the remaining elements, called the
_tail_. A list is a strange beast: it has a head and a tail,
nothing in between, and the tail is itself another list! -->

<p>表示了一个三个自然数的列表。因为 <code class="highlighter-rouge">_∷_</code> 向右结合，这一项被解析成 <code class="highlighter-rouge">0 ∷ (1 ∷ (2 ∷ []))</code>。在这里，<code class="highlighter-rouge">0</code> 是列表的第一个元素，称之为<em>头</em>（Head），<code class="highlighter-rouge">1 ∷ (2 ∷ [])</code> 是剩下元素的列表，称之为<em>尾</em>（Tail）。列表是一个奇怪的怪兽：它有一头一尾，中间没有东西，然而它的尾巴又是一个列表！</p>

<!-- As we've seen, parameterised types can be translated to
indexed types. The definition above is equivalent to the following: -->

<p>正如我们所见，参数化的类型可以被转换成索引类型。上面的定义与下列等价：</p>

<pre class="Agda"><a id="2898" class="Keyword">data</a> <a id="List′"></a><a id="2903" href="/PLFA-zh/Lists/#2903" class="Datatype">List′</a> <a id="2909" class="Symbol">:</a> <a id="2911" class="PrimitiveType">Set</a> <a id="2915" class="Symbol">→</a> <a id="2917" class="PrimitiveType">Set</a> <a id="2921" class="Keyword">where</a>
  <a id="List′.[]′"></a><a id="2929" href="/PLFA-zh/Lists/#2929" class="InductiveConstructor">[]′</a>  <a id="2934" class="Symbol">:</a> <a id="2936" class="Symbol">∀</a> <a id="2938" class="Symbol">{</a><a id="2939" href="/PLFA-zh/Lists/#2939" class="Bound">A</a> <a id="2941" class="Symbol">:</a> <a id="2943" class="PrimitiveType">Set</a><a id="2946" class="Symbol">}</a> <a id="2948" class="Symbol">→</a> <a id="2950" href="/PLFA-zh/Lists/#2903" class="Datatype">List′</a> <a id="2956" href="/PLFA-zh/Lists/#2939" class="Bound">A</a>
  <a id="List′._∷′_"></a><a id="2960" href="/PLFA-zh/Lists/#2960" class="InductiveConstructor Operator">_∷′_</a> <a id="2965" class="Symbol">:</a> <a id="2967" class="Symbol">∀</a> <a id="2969" class="Symbol">{</a><a id="2970" href="/PLFA-zh/Lists/#2970" class="Bound">A</a> <a id="2972" class="Symbol">:</a> <a id="2974" class="PrimitiveType">Set</a><a id="2977" class="Symbol">}</a> <a id="2979" class="Symbol">→</a> <a id="2981" href="/PLFA-zh/Lists/#2970" class="Bound">A</a> <a id="2983" class="Symbol">→</a> <a id="2985" href="/PLFA-zh/Lists/#2903" class="Datatype">List′</a> <a id="2991" href="/PLFA-zh/Lists/#2970" class="Bound">A</a> <a id="2993" class="Symbol">→</a> <a id="2995" href="/PLFA-zh/Lists/#2903" class="Datatype">List′</a> <a id="3001" href="/PLFA-zh/Lists/#2970" class="Bound">A</a></pre>
<!-- Each constructor takes the parameter as an implicit argument.
Thus, our example list could also be written: -->

<p>每个构造器将参数作为隐式参数。因此我们列表的例子也可以写作：</p>

<pre class="Agda"><a id="3185" href="/PLFA-zh/Lists/#3185" class="Function">_</a> <a id="3187" class="Symbol">:</a> <a id="3189" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="3194" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="3196" class="Symbol">_</a> <a id="3198" class="Symbol">=</a> <a id="3200" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">_∷_</a> <a id="3204" class="Symbol">{</a><a id="3205" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="3206" class="Symbol">}</a> <a id="3208" class="Number">0</a> <a id="3210" class="Symbol">(</a><a id="3211" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">_∷_</a> <a id="3215" class="Symbol">{</a><a id="3216" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="3217" class="Symbol">}</a> <a id="3219" class="Number">1</a> <a id="3221" class="Symbol">(</a><a id="3222" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">_∷_</a> <a id="3226" class="Symbol">{</a><a id="3227" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="3228" class="Symbol">}</a> <a id="3230" class="Number">2</a> <a id="3232" class="Symbol">(</a><a id="3233" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="3236" class="Symbol">{</a><a id="3237" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="3238" class="Symbol">})))</a></pre>
<!-- where here we have provided the implicit parameters explicitly. -->

<p>此处我们将隐式参数显式地声明。</p>

<!-- Including the pragma: -->

<p>包含下面的编译器指令</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{-# BUILTIN LIST List #-}
</code></pre></div></div>

<!-- tells Agda that the type `List` corresponds to the Haskell type
list, and the constructors `[]` and `_∷_` correspond to nil and
cons respectively, allowing a more efficient representation of lists. -->

<p>告诉 Agda，<code class="highlighter-rouge">List</code> 类型对应了 Haskell 的列表类型，构造器 <code class="highlighter-rouge">[]</code> 和 <code class="highlighter-rouge">_∷_</code>
分别代表了 nil 和 cons，这可以让列表的表示更加的有效率。</p>

<!-- ## List syntax -->

<h2 id="列表语法">列表语法</h2>

<!-- We can write lists more conveniently by introducing the following definitions: -->

<p>我们可以用下面的定义，更简便地表示列表：</p>

<pre class="Agda"><a id="3913" class="Keyword">pattern</a> <a id="[_]"></a><a id="3921" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">[_]</a> <a id="3925" href="/PLFA-zh/Lists/#3929" class="Bound">z</a> <a id="3927" class="Symbol">=</a> <a id="3929" href="/PLFA-zh/Lists/#3929" class="Bound">z</a> <a id="3931" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="3933" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
<a id="3936" class="Keyword">pattern</a> <a id="[_,_]"></a><a id="3944" href="/PLFA-zh/Lists/#3944" class="InductiveConstructor Operator">[_,_]</a> <a id="3950" href="/PLFA-zh/Lists/#3956" class="Bound">y</a> <a id="3952" href="/PLFA-zh/Lists/#3960" class="Bound">z</a> <a id="3954" class="Symbol">=</a> <a id="3956" href="/PLFA-zh/Lists/#3956" class="Bound">y</a> <a id="3958" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="3960" href="/PLFA-zh/Lists/#3960" class="Bound">z</a> <a id="3962" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="3964" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
<a id="3967" class="Keyword">pattern</a> <a id="[_,_,_]"></a><a id="3975" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[_,_,_]</a> <a id="3983" href="/PLFA-zh/Lists/#3991" class="Bound">x</a> <a id="3985" href="/PLFA-zh/Lists/#3995" class="Bound">y</a> <a id="3987" href="/PLFA-zh/Lists/#3999" class="Bound">z</a> <a id="3989" class="Symbol">=</a> <a id="3991" href="/PLFA-zh/Lists/#3991" class="Bound">x</a> <a id="3993" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="3995" href="/PLFA-zh/Lists/#3995" class="Bound">y</a> <a id="3997" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="3999" href="/PLFA-zh/Lists/#3999" class="Bound">z</a> <a id="4001" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4003" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
<a id="4006" class="Keyword">pattern</a> <a id="[_,_,_,_]"></a><a id="4014" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">[_,_,_,_]</a> <a id="4024" href="/PLFA-zh/Lists/#4034" class="Bound">w</a> <a id="4026" href="/PLFA-zh/Lists/#4038" class="Bound">x</a> <a id="4028" href="/PLFA-zh/Lists/#4042" class="Bound">y</a> <a id="4030" href="/PLFA-zh/Lists/#4046" class="Bound">z</a> <a id="4032" class="Symbol">=</a> <a id="4034" href="/PLFA-zh/Lists/#4034" class="Bound">w</a> <a id="4036" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4038" href="/PLFA-zh/Lists/#4038" class="Bound">x</a> <a id="4040" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4042" href="/PLFA-zh/Lists/#4042" class="Bound">y</a> <a id="4044" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4046" href="/PLFA-zh/Lists/#4046" class="Bound">z</a> <a id="4048" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4050" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
<a id="4053" class="Keyword">pattern</a> <a id="[_,_,_,_,_]"></a><a id="4061" href="/PLFA-zh/Lists/#4061" class="InductiveConstructor Operator">[_,_,_,_,_]</a> <a id="4073" href="/PLFA-zh/Lists/#4085" class="Bound">v</a> <a id="4075" href="/PLFA-zh/Lists/#4089" class="Bound">w</a> <a id="4077" href="/PLFA-zh/Lists/#4093" class="Bound">x</a> <a id="4079" href="/PLFA-zh/Lists/#4097" class="Bound">y</a> <a id="4081" href="/PLFA-zh/Lists/#4101" class="Bound">z</a> <a id="4083" class="Symbol">=</a> <a id="4085" href="/PLFA-zh/Lists/#4085" class="Bound">v</a> <a id="4087" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4089" href="/PLFA-zh/Lists/#4089" class="Bound">w</a> <a id="4091" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4093" href="/PLFA-zh/Lists/#4093" class="Bound">x</a> <a id="4095" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4097" href="/PLFA-zh/Lists/#4097" class="Bound">y</a> <a id="4099" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4101" href="/PLFA-zh/Lists/#4101" class="Bound">z</a> <a id="4103" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4105" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
<a id="4108" class="Keyword">pattern</a> <a id="[_,_,_,_,_,_]"></a><a id="4116" href="/PLFA-zh/Lists/#4116" class="InductiveConstructor Operator">[_,_,_,_,_,_]</a> <a id="4130" href="/PLFA-zh/Lists/#4144" class="Bound">u</a> <a id="4132" href="/PLFA-zh/Lists/#4148" class="Bound">v</a> <a id="4134" href="/PLFA-zh/Lists/#4152" class="Bound">w</a> <a id="4136" href="/PLFA-zh/Lists/#4156" class="Bound">x</a> <a id="4138" href="/PLFA-zh/Lists/#4160" class="Bound">y</a> <a id="4140" href="/PLFA-zh/Lists/#4164" class="Bound">z</a> <a id="4142" class="Symbol">=</a> <a id="4144" href="/PLFA-zh/Lists/#4144" class="Bound">u</a> <a id="4146" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4148" href="/PLFA-zh/Lists/#4148" class="Bound">v</a> <a id="4150" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4152" href="/PLFA-zh/Lists/#4152" class="Bound">w</a> <a id="4154" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4156" href="/PLFA-zh/Lists/#4156" class="Bound">x</a> <a id="4158" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4160" href="/PLFA-zh/Lists/#4160" class="Bound">y</a> <a id="4162" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4164" href="/PLFA-zh/Lists/#4164" class="Bound">z</a> <a id="4166" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4168" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a></pre>
<!-- This is our first use of pattern declarations.  For instance,
the third line tells us that `[ x , y , z ]` is equivalent to
`x ∷ y ∷ z ∷ []`, and permits the former to appear either in
a pattern on the left-hand side of an equation, or a term
on the right-hand side of an equation. -->

<p>这是我们第一次使用模式声明。举例来说，第三行告诉我们 <code class="highlighter-rouge">[ x , y , z ]</code> 等价于
<code class="highlighter-rouge">x ∷ y ∷ z ∷ []</code>。前者可以在模式或者等式的左手边，或者是等式右手边的项中出现。</p>

<!-- ## Append -->

<h2 id="附加">附加</h2>

<!-- Our first function on lists is written `_++_` and pronounced
_append_: -->

<p>我们对于列表的第一个函数写作 <code class="highlighter-rouge">_++_</code>，读作<em>附加</em>（Append）：</p>

<pre class="Agda"><a id="4754" class="Keyword">infixr</a> <a id="4761" class="Number">5</a> <a id="4763" href="/PLFA-zh/Lists/#4769" class="Function Operator">_++_</a>

<a id="_++_"></a><a id="4769" href="/PLFA-zh/Lists/#4769" class="Function Operator">_++_</a> <a id="4774" class="Symbol">:</a> <a id="4776" class="Symbol">∀</a> <a id="4778" class="Symbol">{</a><a id="4779" href="/PLFA-zh/Lists/#4779" class="Bound">A</a> <a id="4781" class="Symbol">:</a> <a id="4783" class="PrimitiveType">Set</a><a id="4786" class="Symbol">}</a> <a id="4788" class="Symbol">→</a> <a id="4790" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="4795" href="/PLFA-zh/Lists/#4779" class="Bound">A</a> <a id="4797" class="Symbol">→</a> <a id="4799" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="4804" href="/PLFA-zh/Lists/#4779" class="Bound">A</a> <a id="4806" class="Symbol">→</a> <a id="4808" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="4813" href="/PLFA-zh/Lists/#4779" class="Bound">A</a>
<a id="4815" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>       <a id="4824" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="4827" href="/PLFA-zh/Lists/#4827" class="Bound">ys</a>  <a id="4831" class="Symbol">=</a>  <a id="4834" href="/PLFA-zh/Lists/#4827" class="Bound">ys</a>
<a id="4837" class="Symbol">(</a><a id="4838" href="/PLFA-zh/Lists/#4838" class="Bound">x</a> <a id="4840" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4842" href="/PLFA-zh/Lists/#4842" class="Bound">xs</a><a id="4844" class="Symbol">)</a> <a id="4846" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="4849" href="/PLFA-zh/Lists/#4849" class="Bound">ys</a>  <a id="4853" class="Symbol">=</a>  <a id="4856" href="/PLFA-zh/Lists/#4838" class="Bound">x</a> <a id="4858" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="4860" class="Symbol">(</a><a id="4861" href="/PLFA-zh/Lists/#4842" class="Bound">xs</a> <a id="4864" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="4867" href="/PLFA-zh/Lists/#4849" class="Bound">ys</a><a id="4869" class="Symbol">)</a></pre>
<!-- The type `A` is an implicit argument to append, making it a
_polymorphic_ function (one that can be used at many types).  The
empty list appended to another list yields the other list.  A
non-empty list appended to another list yields a list with head the
same as the head of the first list and tail the same as the tail of
the first list appended to the second list. -->

<p><code class="highlighter-rouge">A</code> 类型是附加的隐式参数，这让这个函数变为一个<em>多态</em>（Polymorphic）函数
（即可以用作多种类型）。空列表附加到另一个列表得到是第二个列表。非空列表附加到另一个列表，得到的列表的头是第一个列表的头，尾是第一个列表的尾附加至第二个列表的结果。</p>

<!-- Here is an example, showing how to compute the result
of appending two lists: -->

<p>我们举个例子，来展示将两个列表附加的计算过程：</p>

<pre class="Agda"><a id="5532" href="/PLFA-zh/Lists/#5532" class="Function">_</a> <a id="5534" class="Symbol">:</a> <a id="5536" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="5538" class="Number">0</a> <a id="5540" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="5542" class="Number">1</a> <a id="5544" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="5546" class="Number">2</a> <a id="5548" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a> <a id="5550" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="5553" href="/PLFA-zh/Lists/#3944" class="InductiveConstructor Operator">[</a> <a id="5555" class="Number">3</a> <a id="5557" href="/PLFA-zh/Lists/#3944" class="InductiveConstructor Operator">,</a> <a id="5559" class="Number">4</a> <a id="5561" href="/PLFA-zh/Lists/#3944" class="InductiveConstructor Operator">]</a> <a id="5563" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="5565" href="/PLFA-zh/Lists/#4061" class="InductiveConstructor Operator">[</a> <a id="5567" class="Number">0</a> <a id="5569" href="/PLFA-zh/Lists/#4061" class="InductiveConstructor Operator">,</a> <a id="5571" class="Number">1</a> <a id="5573" href="/PLFA-zh/Lists/#4061" class="InductiveConstructor Operator">,</a> <a id="5575" class="Number">2</a> <a id="5577" href="/PLFA-zh/Lists/#4061" class="InductiveConstructor Operator">,</a> <a id="5579" class="Number">3</a> <a id="5581" href="/PLFA-zh/Lists/#4061" class="InductiveConstructor Operator">,</a> <a id="5583" class="Number">4</a> <a id="5585" href="/PLFA-zh/Lists/#4061" class="InductiveConstructor Operator">]</a>
<a id="5587" class="Symbol">_</a> <a id="5589" class="Symbol">=</a>
  <a id="5593" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="5603" class="Number">0</a> <a id="5605" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5607" class="Number">1</a> <a id="5609" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5611" class="Number">2</a> <a id="5613" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5615" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="5618" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="5621" class="Number">3</a> <a id="5623" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5625" class="Number">4</a> <a id="5627" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5629" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="5634" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="5642" class="Number">0</a> <a id="5644" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5646" class="Symbol">(</a><a id="5647" class="Number">1</a> <a id="5649" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5651" class="Number">2</a> <a id="5653" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5655" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="5658" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="5661" class="Number">3</a> <a id="5663" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5665" class="Number">4</a> <a id="5667" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5669" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="5671" class="Symbol">)</a>
  <a id="5675" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="5683" class="Number">0</a> <a id="5685" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5687" class="Number">1</a> <a id="5689" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5691" class="Symbol">(</a><a id="5692" class="Number">2</a> <a id="5694" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5696" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="5699" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="5702" class="Number">3</a> <a id="5704" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5706" class="Number">4</a> <a id="5708" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5710" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="5712" class="Symbol">)</a>
  <a id="5716" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="5724" class="Number">0</a> <a id="5726" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5728" class="Number">1</a> <a id="5730" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5732" class="Number">2</a> <a id="5734" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5736" class="Symbol">(</a><a id="5737" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="5740" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="5743" class="Number">3</a> <a id="5745" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5747" class="Number">4</a> <a id="5749" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5751" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="5753" class="Symbol">)</a>
  <a id="5757" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="5765" class="Number">0</a> <a id="5767" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5769" class="Number">1</a> <a id="5771" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5773" class="Number">2</a> <a id="5775" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5777" class="Number">3</a> <a id="5779" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5781" class="Number">4</a> <a id="5783" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="5785" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="5790" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<!-- Appending two lists requires time linear in the
number of elements in the first list. -->

<p>附加两个列表需要对于第一个列表元素个数线性的时间。</p>

<!-- ## Reasoning about append -->

<h2 id="论证附加">论证附加</h2>

<!-- We can reason about lists in much the same way that we reason
about numbers.  Here is the proof that append is associative: -->

<p>我们可以与用论证数几乎相同的方法来论证列表。下面是附加满足结合律的证明：</p>
<pre class="Agda"><a id="++-assoc"></a><a id="6180" href="/PLFA-zh/Lists/#6180" class="Function">++-assoc</a> <a id="6189" class="Symbol">:</a> <a id="6191" class="Symbol">∀</a> <a id="6193" class="Symbol">{</a><a id="6194" href="/PLFA-zh/Lists/#6194" class="Bound">A</a> <a id="6196" class="Symbol">:</a> <a id="6198" class="PrimitiveType">Set</a><a id="6201" class="Symbol">}</a> <a id="6203" class="Symbol">(</a><a id="6204" href="/PLFA-zh/Lists/#6204" class="Bound">xs</a> <a id="6207" href="/PLFA-zh/Lists/#6207" class="Bound">ys</a> <a id="6210" href="/PLFA-zh/Lists/#6210" class="Bound">zs</a> <a id="6213" class="Symbol">:</a> <a id="6215" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="6220" href="/PLFA-zh/Lists/#6194" class="Bound">A</a><a id="6221" class="Symbol">)</a>
  <a id="6225" class="Symbol">→</a> <a id="6227" class="Symbol">(</a><a id="6228" href="/PLFA-zh/Lists/#6204" class="Bound">xs</a> <a id="6231" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6234" href="/PLFA-zh/Lists/#6207" class="Bound">ys</a><a id="6236" class="Symbol">)</a> <a id="6238" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6241" href="/PLFA-zh/Lists/#6210" class="Bound">zs</a> <a id="6244" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="6246" href="/PLFA-zh/Lists/#6204" class="Bound">xs</a> <a id="6249" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6252" class="Symbol">(</a><a id="6253" href="/PLFA-zh/Lists/#6207" class="Bound">ys</a> <a id="6256" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6259" href="/PLFA-zh/Lists/#6210" class="Bound">zs</a><a id="6261" class="Symbol">)</a>
<a id="6263" href="/PLFA-zh/Lists/#6180" class="Function">++-assoc</a> <a id="6272" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="6275" href="/PLFA-zh/Lists/#6275" class="Bound">ys</a> <a id="6278" href="/PLFA-zh/Lists/#6278" class="Bound">zs</a> <a id="6281" class="Symbol">=</a>
  <a id="6285" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="6295" class="Symbol">(</a><a id="6296" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="6299" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6302" href="/PLFA-zh/Lists/#6275" class="Bound">ys</a><a id="6304" class="Symbol">)</a> <a id="6306" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6309" href="/PLFA-zh/Lists/#6278" class="Bound">zs</a>
  <a id="6314" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="6322" href="/PLFA-zh/Lists/#6275" class="Bound">ys</a> <a id="6325" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6328" href="/PLFA-zh/Lists/#6278" class="Bound">zs</a>
  <a id="6333" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="6341" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="6344" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6347" class="Symbol">(</a><a id="6348" href="/PLFA-zh/Lists/#6275" class="Bound">ys</a> <a id="6351" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6354" href="/PLFA-zh/Lists/#6278" class="Bound">zs</a><a id="6356" class="Symbol">)</a>
  <a id="6360" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a>
<a id="6362" href="/PLFA-zh/Lists/#6180" class="Function">++-assoc</a> <a id="6371" class="Symbol">(</a><a id="6372" href="/PLFA-zh/Lists/#6372" class="Bound">x</a> <a id="6374" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="6376" href="/PLFA-zh/Lists/#6376" class="Bound">xs</a><a id="6378" class="Symbol">)</a> <a id="6380" href="/PLFA-zh/Lists/#6380" class="Bound">ys</a> <a id="6383" href="/PLFA-zh/Lists/#6383" class="Bound">zs</a> <a id="6386" class="Symbol">=</a>
  <a id="6390" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="6400" class="Symbol">(</a><a id="6401" href="/PLFA-zh/Lists/#6372" class="Bound">x</a> <a id="6403" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="6405" href="/PLFA-zh/Lists/#6376" class="Bound">xs</a> <a id="6408" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6411" href="/PLFA-zh/Lists/#6380" class="Bound">ys</a><a id="6413" class="Symbol">)</a> <a id="6415" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6418" href="/PLFA-zh/Lists/#6383" class="Bound">zs</a>
  <a id="6423" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="6431" href="/PLFA-zh/Lists/#6372" class="Bound">x</a> <a id="6433" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="6435" class="Symbol">(</a><a id="6436" href="/PLFA-zh/Lists/#6376" class="Bound">xs</a> <a id="6439" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6442" href="/PLFA-zh/Lists/#6380" class="Bound">ys</a><a id="6444" class="Symbol">)</a> <a id="6446" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6449" href="/PLFA-zh/Lists/#6383" class="Bound">zs</a>
  <a id="6454" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="6462" href="/PLFA-zh/Lists/#6372" class="Bound">x</a> <a id="6464" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="6466" class="Symbol">((</a><a id="6468" href="/PLFA-zh/Lists/#6376" class="Bound">xs</a> <a id="6471" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6474" href="/PLFA-zh/Lists/#6380" class="Bound">ys</a><a id="6476" class="Symbol">)</a> <a id="6478" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6481" href="/PLFA-zh/Lists/#6383" class="Bound">zs</a><a id="6483" class="Symbol">)</a>
  <a id="6487" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="6490" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a> <a id="6495" class="Symbol">(</a><a id="6496" href="/PLFA-zh/Lists/#6372" class="Bound">x</a> <a id="6498" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷_</a><a id="6500" class="Symbol">)</a> <a id="6502" class="Symbol">(</a><a id="6503" href="/PLFA-zh/Lists/#6180" class="Function">++-assoc</a> <a id="6512" href="/PLFA-zh/Lists/#6376" class="Bound">xs</a> <a id="6515" href="/PLFA-zh/Lists/#6380" class="Bound">ys</a> <a id="6518" href="/PLFA-zh/Lists/#6383" class="Bound">zs</a><a id="6520" class="Symbol">)</a> <a id="6522" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="6528" href="/PLFA-zh/Lists/#6372" class="Bound">x</a> <a id="6530" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="6532" class="Symbol">(</a><a id="6533" href="/PLFA-zh/Lists/#6376" class="Bound">xs</a> <a id="6536" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6539" class="Symbol">(</a><a id="6540" href="/PLFA-zh/Lists/#6380" class="Bound">ys</a> <a id="6543" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6546" href="/PLFA-zh/Lists/#6383" class="Bound">zs</a><a id="6548" class="Symbol">))</a>
  <a id="6553" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="6561" href="/PLFA-zh/Lists/#6372" class="Bound">x</a> <a id="6563" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="6565" href="/PLFA-zh/Lists/#6376" class="Bound">xs</a> <a id="6568" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6571" class="Symbol">(</a><a id="6572" href="/PLFA-zh/Lists/#6380" class="Bound">ys</a> <a id="6575" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="6578" href="/PLFA-zh/Lists/#6383" class="Bound">zs</a><a id="6580" class="Symbol">)</a>
  <a id="6584" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<!-- The proof is by induction on the first argument. The base case instantiates
to `[]`, and follows by straightforward computation.
The inductive case instantiates to `x ∷ xs`,
and follows by straightforward computation combined with the
inductive hypothesis.  As usual, the inductive hypothesis is indicated by a recursive
invocation of the proof, in this case `++-assoc xs ys zs`. -->

<p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code class="highlighter-rouge">[]</code>，由直接的运算可证。归纳步骤将列表实例化为 <code class="highlighter-rouge">x ∷ xs</code>，由直接的运算配合归纳假设可证。与往常一样，归纳假设由递归使用证明函数来表明，此处为 <code class="highlighter-rouge">++-assoc xs ys zs</code>。</p>

<!-- Recall that Agda supports [sections](/PLFA-zh/Induction/#sections).
Applying `cong (x ∷_)` promotes the inductive hypothesis: -->

<p>回忆到 Agda 支持<a href="/PLFA-zh/Induction/#sections">片段</a>。使用 <code class="highlighter-rouge">cong (x ∷_)</code>
可以将归纳假设：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)
</code></pre></div></div>

<!-- to the equality: -->

<p>提升至等式：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x ∷ ((xs ++ ys) ++ zs) ≡ x ∷ (xs ++ (ys ++ zs))
</code></pre></div></div>

<!-- which is needed in the proof. -->

<p>即证明中所需。</p>

<!-- It is also easy to show that `[]` is a left and right identity for `_++_`.
That it is a left identity is immediate from the definition: -->

<p>我们也可以简单地证明 <code class="highlighter-rouge">[]</code> 是 <code class="highlighter-rouge">_++_</code> 的左幺元和右幺元。左幺元的证明从定义中即可得：</p>

<pre class="Agda"><a id="++-identityˡ"></a><a id="7741" href="/PLFA-zh/Lists/#7741" class="Function">++-identityˡ</a> <a id="7754" class="Symbol">:</a> <a id="7756" class="Symbol">∀</a> <a id="7758" class="Symbol">{</a><a id="7759" href="/PLFA-zh/Lists/#7759" class="Bound">A</a> <a id="7761" class="Symbol">:</a> <a id="7763" class="PrimitiveType">Set</a><a id="7766" class="Symbol">}</a> <a id="7768" class="Symbol">(</a><a id="7769" href="/PLFA-zh/Lists/#7769" class="Bound">xs</a> <a id="7772" class="Symbol">:</a> <a id="7774" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="7779" href="/PLFA-zh/Lists/#7759" class="Bound">A</a><a id="7780" class="Symbol">)</a> <a id="7782" class="Symbol">→</a> <a id="7784" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="7787" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="7790" href="/PLFA-zh/Lists/#7769" class="Bound">xs</a> <a id="7793" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="7795" href="/PLFA-zh/Lists/#7769" class="Bound">xs</a>
<a id="7798" href="/PLFA-zh/Lists/#7741" class="Function">++-identityˡ</a> <a id="7811" href="/PLFA-zh/Lists/#7811" class="Bound">xs</a> <a id="7814" class="Symbol">=</a>
  <a id="7818" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="7828" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="7831" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="7834" href="/PLFA-zh/Lists/#7811" class="Bound">xs</a>
  <a id="7839" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="7847" href="/PLFA-zh/Lists/#7811" class="Bound">xs</a>
  <a id="7852" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<!-- That it is a right identity follows by simple induction: -->

<p>右幺元的证明可由简单的归纳得到：</p>
<pre class="Agda"><a id="++-identityʳ"></a><a id="7970" href="/PLFA-zh/Lists/#7970" class="Function">++-identityʳ</a> <a id="7983" class="Symbol">:</a> <a id="7985" class="Symbol">∀</a> <a id="7987" class="Symbol">{</a><a id="7988" href="/PLFA-zh/Lists/#7988" class="Bound">A</a> <a id="7990" class="Symbol">:</a> <a id="7992" class="PrimitiveType">Set</a><a id="7995" class="Symbol">}</a> <a id="7997" class="Symbol">(</a><a id="7998" href="/PLFA-zh/Lists/#7998" class="Bound">xs</a> <a id="8001" class="Symbol">:</a> <a id="8003" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="8008" href="/PLFA-zh/Lists/#7988" class="Bound">A</a><a id="8009" class="Symbol">)</a> <a id="8011" class="Symbol">→</a> <a id="8013" href="/PLFA-zh/Lists/#7998" class="Bound">xs</a> <a id="8016" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="8019" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="8022" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="8024" href="/PLFA-zh/Lists/#7998" class="Bound">xs</a>
<a id="8027" href="/PLFA-zh/Lists/#7970" class="Function">++-identityʳ</a> <a id="8040" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="8043" class="Symbol">=</a>
  <a id="8047" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="8057" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="8060" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="8063" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="8068" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="8076" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="8081" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a>
<a id="8083" href="/PLFA-zh/Lists/#7970" class="Function">++-identityʳ</a> <a id="8096" class="Symbol">(</a><a id="8097" href="/PLFA-zh/Lists/#8097" class="Bound">x</a> <a id="8099" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="8101" href="/PLFA-zh/Lists/#8101" class="Bound">xs</a><a id="8103" class="Symbol">)</a> <a id="8105" class="Symbol">=</a>
  <a id="8109" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="8119" class="Symbol">(</a><a id="8120" href="/PLFA-zh/Lists/#8097" class="Bound">x</a> <a id="8122" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="8124" href="/PLFA-zh/Lists/#8101" class="Bound">xs</a><a id="8126" class="Symbol">)</a> <a id="8128" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="8131" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="8136" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="8144" href="/PLFA-zh/Lists/#8097" class="Bound">x</a> <a id="8146" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="8148" class="Symbol">(</a><a id="8149" href="/PLFA-zh/Lists/#8101" class="Bound">xs</a> <a id="8152" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="8155" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="8157" class="Symbol">)</a>
  <a id="8161" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="8164" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a> <a id="8169" class="Symbol">(</a><a id="8170" href="/PLFA-zh/Lists/#8097" class="Bound">x</a> <a id="8172" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷_</a><a id="8174" class="Symbol">)</a> <a id="8176" class="Symbol">(</a><a id="8177" href="/PLFA-zh/Lists/#7970" class="Function">++-identityʳ</a> <a id="8190" href="/PLFA-zh/Lists/#8101" class="Bound">xs</a><a id="8192" class="Symbol">)</a> <a id="8194" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="8200" href="/PLFA-zh/Lists/#8097" class="Bound">x</a> <a id="8202" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="8204" href="/PLFA-zh/Lists/#8101" class="Bound">xs</a>
  <a id="8209" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<!-- As we will see later,
these three properties establish that `_++_` and `[]` form
a _monoid_ over lists. -->

<p>我们之后会了解到，这三条性质表明了 <code class="highlighter-rouge">_++_</code> 和 <code class="highlighter-rouge">[]</code> 在列表上构成了一个<em>幺半群</em>（Monoid）。</p>

<!-- ## Length -->

<h2 id="长度">长度</h2>

<!-- Our next function finds the length of a list: -->

<p>在下一个函数里，我们来寻找列表的长度：</p>

<pre class="Agda"><a id="length"></a><a id="8534" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="8541" class="Symbol">:</a> <a id="8543" class="Symbol">∀</a> <a id="8545" class="Symbol">{</a><a id="8546" href="/PLFA-zh/Lists/#8546" class="Bound">A</a> <a id="8548" class="Symbol">:</a> <a id="8550" class="PrimitiveType">Set</a><a id="8553" class="Symbol">}</a> <a id="8555" class="Symbol">→</a> <a id="8557" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="8562" href="/PLFA-zh/Lists/#8546" class="Bound">A</a> <a id="8564" class="Symbol">→</a> <a id="8566" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="8568" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="8575" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>        <a id="8585" class="Symbol">=</a>  <a id="8588" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a>
<a id="8593" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="8600" class="Symbol">(</a><a id="8601" href="/PLFA-zh/Lists/#8601" class="Bound">x</a> <a id="8603" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="8605" href="/PLFA-zh/Lists/#8605" class="Bound">xs</a><a id="8607" class="Symbol">)</a>  <a id="8610" class="Symbol">=</a>  <a id="8613" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="8617" class="Symbol">(</a><a id="8618" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="8625" href="/PLFA-zh/Lists/#8605" class="Bound">xs</a><a id="8627" class="Symbol">)</a></pre>
<!-- Again, it takes an implicit parameter `A`.
The length of the empty list is zero.
The length of a non-empty list
is one greater than the length of the tail of the list. -->

<p>同样，它取一个隐式参数 <code class="highlighter-rouge">A</code>。空列表的长度为零。非空列表的长度比其尾列表长度多一。</p>

<!-- Here is an example showing how to compute the length of a list: -->

<p>我们用下面的例子来展示如何计算列表的长度：</p>
<pre class="Agda"><a id="8988" href="/PLFA-zh/Lists/#8988" class="Function">_</a> <a id="8990" class="Symbol">:</a> <a id="8992" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="8999" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="9001" class="Number">0</a> <a id="9003" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="9005" class="Number">1</a> <a id="9007" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="9009" class="Number">2</a> <a id="9011" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a> <a id="9013" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="9015" class="Number">3</a>
<a id="9017" class="Symbol">_</a> <a id="9019" class="Symbol">=</a>
  <a id="9023" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="9033" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="9040" class="Symbol">(</a><a id="9041" class="Number">0</a> <a id="9043" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="9045" class="Number">1</a> <a id="9047" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="9049" class="Number">2</a> <a id="9051" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="9053" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="9055" class="Symbol">)</a>
  <a id="9059" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9067" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="9071" class="Symbol">(</a><a id="9072" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="9079" class="Symbol">(</a><a id="9080" class="Number">1</a> <a id="9082" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="9084" class="Number">2</a> <a id="9086" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="9088" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="9090" class="Symbol">))</a>
  <a id="9095" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9103" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="9107" class="Symbol">(</a><a id="9108" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="9112" class="Symbol">(</a><a id="9113" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="9120" class="Symbol">(</a><a id="9121" class="Number">2</a> <a id="9123" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="9125" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="9127" class="Symbol">)))</a>
  <a id="9133" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9141" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="9145" class="Symbol">(</a><a id="9146" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="9150" class="Symbol">(</a><a id="9151" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="9155" class="Symbol">(</a><a id="9156" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="9163" class="Symbol">{</a><a id="9164" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="9165" class="Symbol">}</a> <a id="9167" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="9169" class="Symbol">)))</a>
  <a id="9175" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9183" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="9187" class="Symbol">(</a><a id="9188" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="9192" class="Symbol">(</a><a id="9193" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="9197" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a><a id="9201" class="Symbol">))</a>
  <a id="9206" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<!-- Computing the length of a list requires time
linear in the number of elements in the list. -->

<p>计算列表的长度需要关于列表元素个数线性的时间。</p>

<!-- In the second-to-last line, we cannot write simply `length []` but
must instead write `length {ℕ} []`.  Since `[]` has no elements, Agda
has insufficient information to infer the implicit parameter. -->

<p>在倒数第二行中，我们不可以直接写 <code class="highlighter-rouge">length []</code>，而需要写 <code class="highlighter-rouge">length {ℕ} []</code>。因为 <code class="highlighter-rouge">[]</code> 没有元素，Agda 没有足够的信息来推导其隐式参数。</p>

<!-- ## Reasoning about length -->

<h2 id="论证长度">论证长度</h2>

<!-- The length of one list appended to another is the
sum of the lengths of the lists: -->

<p>两个附加在一起的列表的长度是两列表长度之和：</p>

<pre class="Agda"><a id="length-++"></a><a id="9848" href="/PLFA-zh/Lists/#9848" class="Function">length-++</a> <a id="9858" class="Symbol">:</a> <a id="9860" class="Symbol">∀</a> <a id="9862" class="Symbol">{</a><a id="9863" href="/PLFA-zh/Lists/#9863" class="Bound">A</a> <a id="9865" class="Symbol">:</a> <a id="9867" class="PrimitiveType">Set</a><a id="9870" class="Symbol">}</a> <a id="9872" class="Symbol">(</a><a id="9873" href="/PLFA-zh/Lists/#9873" class="Bound">xs</a> <a id="9876" href="/PLFA-zh/Lists/#9876" class="Bound">ys</a> <a id="9879" class="Symbol">:</a> <a id="9881" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="9886" href="/PLFA-zh/Lists/#9863" class="Bound">A</a><a id="9887" class="Symbol">)</a>
  <a id="9891" class="Symbol">→</a> <a id="9893" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="9900" class="Symbol">(</a><a id="9901" href="/PLFA-zh/Lists/#9873" class="Bound">xs</a> <a id="9904" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="9907" href="/PLFA-zh/Lists/#9876" class="Bound">ys</a><a id="9909" class="Symbol">)</a> <a id="9911" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="9913" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="9920" href="/PLFA-zh/Lists/#9873" class="Bound">xs</a> <a id="9923" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="9925" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="9932" href="/PLFA-zh/Lists/#9876" class="Bound">ys</a>
<a id="9935" href="/PLFA-zh/Lists/#9848" class="Function">length-++</a> <a id="9945" class="Symbol">{</a><a id="9946" href="/PLFA-zh/Lists/#9946" class="Bound">A</a><a id="9947" class="Symbol">}</a> <a id="9949" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="9952" href="/PLFA-zh/Lists/#9952" class="Bound">ys</a> <a id="9955" class="Symbol">=</a>
  <a id="9959" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="9969" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="9976" class="Symbol">(</a><a id="9977" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="9980" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="9983" href="/PLFA-zh/Lists/#9952" class="Bound">ys</a><a id="9985" class="Symbol">)</a>
  <a id="9989" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9997" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="10004" href="/PLFA-zh/Lists/#9952" class="Bound">ys</a>
  <a id="10009" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="10017" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="10024" class="Symbol">{</a><a id="10025" href="/PLFA-zh/Lists/#9946" class="Bound">A</a><a id="10026" class="Symbol">}</a> <a id="10028" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="10031" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="10033" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="10040" href="/PLFA-zh/Lists/#9952" class="Bound">ys</a>
  <a id="10045" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a>
<a id="10047" href="/PLFA-zh/Lists/#9848" class="Function">length-++</a> <a id="10057" class="Symbol">(</a><a id="10058" href="/PLFA-zh/Lists/#10058" class="Bound">x</a> <a id="10060" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="10062" href="/PLFA-zh/Lists/#10062" class="Bound">xs</a><a id="10064" class="Symbol">)</a> <a id="10066" href="/PLFA-zh/Lists/#10066" class="Bound">ys</a> <a id="10069" class="Symbol">=</a>
  <a id="10073" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="10083" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="10090" class="Symbol">((</a><a id="10092" href="/PLFA-zh/Lists/#10058" class="Bound">x</a> <a id="10094" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="10096" href="/PLFA-zh/Lists/#10062" class="Bound">xs</a><a id="10098" class="Symbol">)</a> <a id="10100" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="10103" href="/PLFA-zh/Lists/#10066" class="Bound">ys</a><a id="10105" class="Symbol">)</a>
  <a id="10109" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="10117" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="10121" class="Symbol">(</a><a id="10122" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="10129" class="Symbol">(</a><a id="10130" href="/PLFA-zh/Lists/#10062" class="Bound">xs</a> <a id="10133" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="10136" href="/PLFA-zh/Lists/#10066" class="Bound">ys</a><a id="10138" class="Symbol">))</a>
  <a id="10143" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="10146" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a> <a id="10151" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="10155" class="Symbol">(</a><a id="10156" href="/PLFA-zh/Lists/#9848" class="Function">length-++</a> <a id="10166" href="/PLFA-zh/Lists/#10062" class="Bound">xs</a> <a id="10169" href="/PLFA-zh/Lists/#10066" class="Bound">ys</a><a id="10171" class="Symbol">)</a> <a id="10173" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="10179" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="10183" class="Symbol">(</a><a id="10184" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="10191" href="/PLFA-zh/Lists/#10062" class="Bound">xs</a> <a id="10194" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="10196" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="10203" href="/PLFA-zh/Lists/#10066" class="Bound">ys</a><a id="10205" class="Symbol">)</a>
  <a id="10209" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="10217" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="10224" class="Symbol">(</a><a id="10225" href="/PLFA-zh/Lists/#10058" class="Bound">x</a> <a id="10227" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="10229" href="/PLFA-zh/Lists/#10062" class="Bound">xs</a><a id="10231" class="Symbol">)</a> <a id="10233" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="10235" href="/PLFA-zh/Lists/#8534" class="Function">length</a> <a id="10242" href="/PLFA-zh/Lists/#10066" class="Bound">ys</a>
  <a id="10247" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<!-- The proof is by induction on the first argument. The base case
instantiates to `[]`, and follows by straightforward computation.  As
before, Agda cannot infer the implicit type parameter to `length`, and
it must be given explicitly.  The inductive case instantiates to
`x ∷ xs`, and follows by straightforward computation combined with the
inductive hypothesis.  As usual, the inductive hypothesis is indicated
by a recursive invocation of the proof, in this case `length-++ xs ys`,
and it is promoted by the congruence `cong suc`. -->

<p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code class="highlighter-rouge">[]</code>，由直接的运算可证。如同之前一样，Agda 无法推导 <code class="highlighter-rouge">length</code> 的隐式参数，所以我们必须显式地给出这个参数。归纳步骤将列表实例化为 <code class="highlighter-rouge">x ∷ xs</code>，由直接的运算配合归纳假设可证。与往常一样，归纳假设由递归使用证明函数来表明，此处为 <code class="highlighter-rouge">length-++ xs ys</code>，由 <code class="highlighter-rouge">cong suc</code> 来提升。</p>

<!-- ## Reverse -->

<h2 id="反转">反转</h2>

<!-- Using append, it is easy to formulate a function to reverse a list: -->

<p>我们可以使用附加，来简单地构造一个函数来反转一个列表：</p>
<pre class="Agda"><a id="reverse"></a><a id="11165" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="11173" class="Symbol">:</a> <a id="11175" class="Symbol">∀</a> <a id="11177" class="Symbol">{</a><a id="11178" href="/PLFA-zh/Lists/#11178" class="Bound">A</a> <a id="11180" class="Symbol">:</a> <a id="11182" class="PrimitiveType">Set</a><a id="11185" class="Symbol">}</a> <a id="11187" class="Symbol">→</a> <a id="11189" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="11194" href="/PLFA-zh/Lists/#11178" class="Bound">A</a> <a id="11196" class="Symbol">→</a> <a id="11198" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="11203" href="/PLFA-zh/Lists/#11178" class="Bound">A</a>
<a id="11205" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="11213" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>        <a id="11223" class="Symbol">=</a>  <a id="11226" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
<a id="11229" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="11237" class="Symbol">(</a><a id="11238" href="/PLFA-zh/Lists/#11238" class="Bound">x</a> <a id="11240" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11242" href="/PLFA-zh/Lists/#11242" class="Bound">xs</a><a id="11244" class="Symbol">)</a>  <a id="11247" class="Symbol">=</a>  <a id="11250" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="11258" href="/PLFA-zh/Lists/#11242" class="Bound">xs</a> <a id="11261" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11264" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">[</a> <a id="11266" href="/PLFA-zh/Lists/#11238" class="Bound">x</a> <a id="11268" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">]</a></pre>
<!-- The reverse of the empty list is the empty list.
The reverse of a non-empty list
is the reverse of its tail appended to a unit list
containing its head. -->

<p>空列表的反转是空列表。非空列表的反转是其头元素构成的单元列表附加至其尾列表反转之后的结果。</p>

<!-- Here is an example showing how to reverse a list: -->

<p>下面的例子展示了如何反转一个列表。</p>
<pre class="Agda"><a id="11599" href="/PLFA-zh/Lists/#11599" class="Function">_</a> <a id="11601" class="Symbol">:</a> <a id="11603" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="11611" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="11613" class="Number">0</a> <a id="11615" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="11617" class="Number">1</a> <a id="11619" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="11621" class="Number">2</a> <a id="11623" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a> <a id="11625" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="11627" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="11629" class="Number">2</a> <a id="11631" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="11633" class="Number">1</a> <a id="11635" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="11637" class="Number">0</a> <a id="11639" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a>
<a id="11641" class="Symbol">_</a> <a id="11643" class="Symbol">=</a>
  <a id="11647" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="11657" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="11665" class="Symbol">(</a><a id="11666" class="Number">0</a> <a id="11668" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11670" class="Number">1</a> <a id="11672" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11674" class="Number">2</a> <a id="11676" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11678" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="11680" class="Symbol">)</a>
  <a id="11684" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="11692" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="11700" class="Symbol">(</a><a id="11701" class="Number">1</a> <a id="11703" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11705" class="Number">2</a> <a id="11707" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11709" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="11711" class="Symbol">)</a> <a id="11713" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11716" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">[</a> <a id="11718" class="Number">0</a> <a id="11720" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">]</a>
  <a id="11724" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="11732" class="Symbol">(</a><a id="11733" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="11741" class="Symbol">(</a><a id="11742" class="Number">2</a> <a id="11744" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11746" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="11748" class="Symbol">)</a> <a id="11750" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11753" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">[</a> <a id="11755" class="Number">1</a> <a id="11757" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">]</a><a id="11758" class="Symbol">)</a> <a id="11760" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11763" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">[</a> <a id="11765" class="Number">0</a> <a id="11767" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">]</a>
  <a id="11771" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="11779" class="Symbol">((</a><a id="11781" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="11789" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="11792" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11795" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">[</a> <a id="11797" class="Number">2</a> <a id="11799" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">]</a><a id="11800" class="Symbol">)</a> <a id="11802" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11805" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">[</a> <a id="11807" class="Number">1</a> <a id="11809" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">]</a><a id="11810" class="Symbol">)</a> <a id="11812" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11815" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">[</a> <a id="11817" class="Number">0</a> <a id="11819" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">]</a>
  <a id="11823" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="11831" class="Symbol">((</a><a id="11833" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="11836" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11839" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">[</a> <a id="11841" class="Number">2</a> <a id="11843" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">]</a><a id="11844" class="Symbol">)</a> <a id="11846" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11849" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">[</a> <a id="11851" class="Number">1</a> <a id="11853" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">]</a><a id="11854" class="Symbol">)</a> <a id="11856" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11859" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">[</a> <a id="11861" class="Number">0</a> <a id="11863" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">]</a>
  <a id="11867" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="11875" class="Symbol">((</a><a id="11877" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="11880" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11883" class="Number">2</a> <a id="11885" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11887" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="11889" class="Symbol">)</a> <a id="11891" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11894" class="Number">1</a> <a id="11896" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11898" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="11900" class="Symbol">)</a> <a id="11902" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11905" class="Number">0</a> <a id="11907" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11909" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="11914" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="11922" class="Symbol">(</a><a id="11923" class="Number">2</a> <a id="11925" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11927" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="11930" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11933" class="Number">1</a> <a id="11935" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11937" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="11939" class="Symbol">)</a> <a id="11941" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11944" class="Number">0</a> <a id="11946" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11948" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="11953" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="11961" class="Number">2</a> <a id="11963" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11965" class="Symbol">(</a><a id="11966" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="11969" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11972" class="Number">1</a> <a id="11974" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11976" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="11978" class="Symbol">)</a> <a id="11980" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="11983" class="Number">0</a> <a id="11985" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="11987" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="11992" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="12000" class="Symbol">(</a><a id="12001" class="Number">2</a> <a id="12003" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="12005" class="Number">1</a> <a id="12007" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="12009" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="12011" class="Symbol">)</a> <a id="12013" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="12016" class="Number">0</a> <a id="12018" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="12020" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="12025" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="12033" class="Number">2</a> <a id="12035" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="12037" class="Symbol">(</a><a id="12038" class="Number">1</a> <a id="12040" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="12042" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="12045" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="12048" class="Number">0</a> <a id="12050" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="12052" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="12054" class="Symbol">)</a>
  <a id="12058" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="12066" class="Number">2</a> <a id="12068" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="12070" class="Number">1</a> <a id="12072" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="12074" class="Symbol">(</a><a id="12075" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="12078" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="12081" class="Number">0</a> <a id="12083" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="12085" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="12087" class="Symbol">)</a>
  <a id="12091" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="12099" class="Number">2</a> <a id="12101" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="12103" class="Number">1</a> <a id="12105" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="12107" class="Number">0</a> <a id="12109" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="12111" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="12116" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="12124" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="12126" class="Number">2</a> <a id="12128" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="12130" class="Number">1</a> <a id="12132" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="12134" class="Number">0</a> <a id="12136" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a>
  <a id="12140" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<!-- Reversing a list in this way takes time _quadratic_ in the length of
the list. This is because reverse ends up appending lists of lengths
`1`, `2`, up to `n - 1`, where `n` is the length of the list being
reversed, append takes time linear in the length of the first
list, and the sum of the numbers up to `n - 1` is `n * (n - 1) / 2`.
(We will validate that last fact in an exercise later in this chapter.) -->

<p>这样子反转一个列表需要列表长度<strong>二次</strong>的时间。这是因为反转一个长度为 <code class="highlighter-rouge">n</code> 的列表需要将长度为 <code class="highlighter-rouge">1</code>、<code class="highlighter-rouge">2</code> 直到 <code class="highlighter-rouge">n - 1</code> 的列表附加起来，而附加两个列表需要第一个列表长度线性的时间，因此加起来就需要 <code class="highlighter-rouge">n * (n - 1) / 2</code> 的时间。（我们将在本章节后部分验证这一结果）</p>

<!-- #### Exercise `reverse-++-commute` (recommended) -->

<h4 id="练习-reverse--commute-推荐">练习 <code class="highlighter-rouge">reverse-++-commute</code> （推荐）</h4>

<!-- Show that the reverse of one list appended to another is the
reverse of the second appended to the reverse of the first: -->

<p>证明一个列表附加到另外一个列表的反转即是反转后的第二个列表附加至反转后的第一个列表：</p>
<pre class="Agda"><a id="13029" class="Keyword">postulate</a>
  <a id="reverse-++-commute"></a><a id="13041" href="/PLFA-zh/Lists/#13041" class="Postulate">reverse-++-commute</a> <a id="13060" class="Symbol">:</a> <a id="13062" class="Symbol">∀</a> <a id="13064" class="Symbol">{</a><a id="13065" href="/PLFA-zh/Lists/#13065" class="Bound">A</a> <a id="13067" class="Symbol">:</a> <a id="13069" class="PrimitiveType">Set</a><a id="13072" class="Symbol">}</a> <a id="13074" class="Symbol">{</a><a id="13075" href="/PLFA-zh/Lists/#13075" class="Bound">xs</a> <a id="13078" href="/PLFA-zh/Lists/#13078" class="Bound">ys</a> <a id="13081" class="Symbol">:</a> <a id="13083" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="13088" href="/PLFA-zh/Lists/#13065" class="Bound">A</a><a id="13089" class="Symbol">}</a>
    <a id="13095" class="Symbol">→</a> <a id="13097" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="13105" class="Symbol">(</a><a id="13106" href="/PLFA-zh/Lists/#13075" class="Bound">xs</a> <a id="13109" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="13112" href="/PLFA-zh/Lists/#13078" class="Bound">ys</a><a id="13114" class="Symbol">)</a> <a id="13116" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="13118" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="13126" href="/PLFA-zh/Lists/#13078" class="Bound">ys</a> <a id="13129" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="13132" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="13140" href="/PLFA-zh/Lists/#13075" class="Bound">xs</a></pre>

<!-- #### Exercise `reverse-involutive` (recommended) -->

<h4 id="练习-reverse-involutive-推荐">练习 <code class="highlighter-rouge">reverse-involutive</code> （推荐）</h4>

<!-- A function is an _involution_ if when applied twice it acts
as the identity function.  Show that reverse is an involution: -->

<p>当一个函数应用两次后与恒等函数作用相同，那么这个函数是一个<strong>对合</strong>（Involution）。证明反转是一个对合：</p>

<pre class="Agda"><a id="13472" class="Keyword">postulate</a>
  <a id="reverse-involutive"></a><a id="13484" href="/PLFA-zh/Lists/#13484" class="Postulate">reverse-involutive</a> <a id="13503" class="Symbol">:</a> <a id="13505" class="Symbol">∀</a> <a id="13507" class="Symbol">{</a><a id="13508" href="/PLFA-zh/Lists/#13508" class="Bound">A</a> <a id="13510" class="Symbol">:</a> <a id="13512" class="PrimitiveType">Set</a><a id="13515" class="Symbol">}</a> <a id="13517" class="Symbol">{</a><a id="13518" href="/PLFA-zh/Lists/#13518" class="Bound">xs</a> <a id="13521" class="Symbol">:</a> <a id="13523" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="13528" href="/PLFA-zh/Lists/#13508" class="Bound">A</a><a id="13529" class="Symbol">}</a>
    <a id="13535" class="Symbol">→</a> <a id="13537" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="13545" class="Symbol">(</a><a id="13546" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="13554" href="/PLFA-zh/Lists/#13518" class="Bound">xs</a><a id="13556" class="Symbol">)</a> <a id="13558" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="13560" href="/PLFA-zh/Lists/#13518" class="Bound">xs</a></pre>

<!-- ## Faster reverse -->

<h2 id="更快地反转">更快地反转</h2>

<!-- The definition above, while easy to reason about, is less efficient than
one might expect since it takes time quadratic in the length of the list.
The idea is that we generalise reverse to take an additional argument: -->

<p>上面的定义虽然论证起来方便，但是它比期望中的实现更低效，因为它的运行时间是关于列表长度的二次函数。我们可以将反转进行推广，使用一个额外的参数：</p>

<pre class="Agda"><a id="shunt"></a><a id="13945" href="/PLFA-zh/Lists/#13945" class="Function">shunt</a> <a id="13951" class="Symbol">:</a> <a id="13953" class="Symbol">∀</a> <a id="13955" class="Symbol">{</a><a id="13956" href="/PLFA-zh/Lists/#13956" class="Bound">A</a> <a id="13958" class="Symbol">:</a> <a id="13960" class="PrimitiveType">Set</a><a id="13963" class="Symbol">}</a> <a id="13965" class="Symbol">→</a> <a id="13967" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="13972" href="/PLFA-zh/Lists/#13956" class="Bound">A</a> <a id="13974" class="Symbol">→</a> <a id="13976" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="13981" href="/PLFA-zh/Lists/#13956" class="Bound">A</a> <a id="13983" class="Symbol">→</a> <a id="13985" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="13990" href="/PLFA-zh/Lists/#13956" class="Bound">A</a>
<a id="13992" href="/PLFA-zh/Lists/#13945" class="Function">shunt</a> <a id="13998" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>       <a id="14007" href="/PLFA-zh/Lists/#14007" class="Bound">ys</a>  <a id="14011" class="Symbol">=</a>  <a id="14014" href="/PLFA-zh/Lists/#14007" class="Bound">ys</a>
<a id="14017" href="/PLFA-zh/Lists/#13945" class="Function">shunt</a> <a id="14023" class="Symbol">(</a><a id="14024" href="/PLFA-zh/Lists/#14024" class="Bound">x</a> <a id="14026" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="14028" href="/PLFA-zh/Lists/#14028" class="Bound">xs</a><a id="14030" class="Symbol">)</a> <a id="14032" href="/PLFA-zh/Lists/#14032" class="Bound">ys</a>  <a id="14036" class="Symbol">=</a>  <a id="14039" href="/PLFA-zh/Lists/#13945" class="Function">shunt</a> <a id="14045" href="/PLFA-zh/Lists/#14028" class="Bound">xs</a> <a id="14048" class="Symbol">(</a><a id="14049" href="/PLFA-zh/Lists/#14024" class="Bound">x</a> <a id="14051" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="14053" href="/PLFA-zh/Lists/#14032" class="Bound">ys</a><a id="14055" class="Symbol">)</a></pre>
<!-- The definition is by recursion on the first argument. The second argument
actually becomes _larger_, but this is not a problem because the argument
on which we recurse becomes _smaller_. -->

<p>这个定义对于第一个参数进行递归。第二个参数会变_大_，但这样做没有问题，因为我们递归的参数在变_小_。</p>

<!-- Shunt is related to reverse as follows: -->

<p>转移（Shunt）与反转的关系如下：</p>
<pre class="Agda"><a id="shunt-reverse"></a><a id="14417" href="/PLFA-zh/Lists/#14417" class="Function">shunt-reverse</a> <a id="14431" class="Symbol">:</a> <a id="14433" class="Symbol">∀</a> <a id="14435" class="Symbol">{</a><a id="14436" href="/PLFA-zh/Lists/#14436" class="Bound">A</a> <a id="14438" class="Symbol">:</a> <a id="14440" class="PrimitiveType">Set</a><a id="14443" class="Symbol">}</a> <a id="14445" class="Symbol">(</a><a id="14446" href="/PLFA-zh/Lists/#14446" class="Bound">xs</a> <a id="14449" href="/PLFA-zh/Lists/#14449" class="Bound">ys</a> <a id="14452" class="Symbol">:</a> <a id="14454" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="14459" href="/PLFA-zh/Lists/#14436" class="Bound">A</a><a id="14460" class="Symbol">)</a>
  <a id="14464" class="Symbol">→</a> <a id="14466" href="/PLFA-zh/Lists/#13945" class="Function">shunt</a> <a id="14472" href="/PLFA-zh/Lists/#14446" class="Bound">xs</a> <a id="14475" href="/PLFA-zh/Lists/#14449" class="Bound">ys</a> <a id="14478" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="14480" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="14488" href="/PLFA-zh/Lists/#14446" class="Bound">xs</a> <a id="14491" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="14494" href="/PLFA-zh/Lists/#14449" class="Bound">ys</a>
<a id="14497" href="/PLFA-zh/Lists/#14417" class="Function">shunt-reverse</a> <a id="14511" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="14514" href="/PLFA-zh/Lists/#14514" class="Bound">ys</a> <a id="14517" class="Symbol">=</a>
  <a id="14521" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="14531" href="/PLFA-zh/Lists/#13945" class="Function">shunt</a> <a id="14537" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="14540" href="/PLFA-zh/Lists/#14514" class="Bound">ys</a>
  <a id="14545" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="14553" href="/PLFA-zh/Lists/#14514" class="Bound">ys</a>
  <a id="14558" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="14566" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="14574" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="14577" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="14580" href="/PLFA-zh/Lists/#14514" class="Bound">ys</a>
  <a id="14585" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a>
<a id="14587" href="/PLFA-zh/Lists/#14417" class="Function">shunt-reverse</a> <a id="14601" class="Symbol">(</a><a id="14602" href="/PLFA-zh/Lists/#14602" class="Bound">x</a> <a id="14604" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="14606" href="/PLFA-zh/Lists/#14606" class="Bound">xs</a><a id="14608" class="Symbol">)</a> <a id="14610" href="/PLFA-zh/Lists/#14610" class="Bound">ys</a> <a id="14613" class="Symbol">=</a>
  <a id="14617" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="14627" href="/PLFA-zh/Lists/#13945" class="Function">shunt</a> <a id="14633" class="Symbol">(</a><a id="14634" href="/PLFA-zh/Lists/#14602" class="Bound">x</a> <a id="14636" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="14638" href="/PLFA-zh/Lists/#14606" class="Bound">xs</a><a id="14640" class="Symbol">)</a> <a id="14642" href="/PLFA-zh/Lists/#14610" class="Bound">ys</a>
  <a id="14647" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="14655" href="/PLFA-zh/Lists/#13945" class="Function">shunt</a> <a id="14661" href="/PLFA-zh/Lists/#14606" class="Bound">xs</a> <a id="14664" class="Symbol">(</a><a id="14665" href="/PLFA-zh/Lists/#14602" class="Bound">x</a> <a id="14667" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="14669" href="/PLFA-zh/Lists/#14610" class="Bound">ys</a><a id="14671" class="Symbol">)</a>
  <a id="14675" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="14678" href="/PLFA-zh/Lists/#14417" class="Function">shunt-reverse</a> <a id="14692" href="/PLFA-zh/Lists/#14606" class="Bound">xs</a> <a id="14695" class="Symbol">(</a><a id="14696" href="/PLFA-zh/Lists/#14602" class="Bound">x</a> <a id="14698" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="14700" href="/PLFA-zh/Lists/#14610" class="Bound">ys</a><a id="14702" class="Symbol">)</a> <a id="14704" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="14710" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="14718" href="/PLFA-zh/Lists/#14606" class="Bound">xs</a> <a id="14721" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="14724" class="Symbol">(</a><a id="14725" href="/PLFA-zh/Lists/#14602" class="Bound">x</a> <a id="14727" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="14729" href="/PLFA-zh/Lists/#14610" class="Bound">ys</a><a id="14731" class="Symbol">)</a>
  <a id="14735" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="14743" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="14751" href="/PLFA-zh/Lists/#14606" class="Bound">xs</a> <a id="14754" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="14757" class="Symbol">(</a><a id="14758" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">[</a> <a id="14760" href="/PLFA-zh/Lists/#14602" class="Bound">x</a> <a id="14762" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">]</a> <a id="14764" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="14767" href="/PLFA-zh/Lists/#14610" class="Bound">ys</a><a id="14769" class="Symbol">)</a>
  <a id="14773" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="14776" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.Core.html#838" class="Function">sym</a> <a id="14780" class="Symbol">(</a><a id="14781" href="/PLFA-zh/Lists/#6180" class="Function">++-assoc</a> <a id="14790" class="Symbol">(</a><a id="14791" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="14799" href="/PLFA-zh/Lists/#14606" class="Bound">xs</a><a id="14801" class="Symbol">)</a> <a id="14803" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">[</a> <a id="14805" href="/PLFA-zh/Lists/#14602" class="Bound">x</a> <a id="14807" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">]</a> <a id="14809" href="/PLFA-zh/Lists/#14610" class="Bound">ys</a><a id="14811" class="Symbol">)</a> <a id="14813" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="14819" class="Symbol">(</a><a id="14820" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="14828" href="/PLFA-zh/Lists/#14606" class="Bound">xs</a> <a id="14831" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="14834" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">[</a> <a id="14836" href="/PLFA-zh/Lists/#14602" class="Bound">x</a> <a id="14838" href="/PLFA-zh/Lists/#3921" class="InductiveConstructor Operator">]</a><a id="14839" class="Symbol">)</a> <a id="14841" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="14844" href="/PLFA-zh/Lists/#14610" class="Bound">ys</a>
  <a id="14849" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="14857" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="14865" class="Symbol">(</a><a id="14866" href="/PLFA-zh/Lists/#14602" class="Bound">x</a> <a id="14868" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="14870" href="/PLFA-zh/Lists/#14606" class="Bound">xs</a><a id="14872" class="Symbol">)</a> <a id="14874" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="14877" href="/PLFA-zh/Lists/#14610" class="Bound">ys</a>
  <a id="14882" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<!-- The proof is by induction on the first argument.
The base case instantiates to `[]`, and follows by straightforward computation.
The inductive case instantiates to `x ∷ xs` and follows by the inductive
hypothesis and associativity of append.  When we invoke the inductive hypothesis,
the second argument actually becomes *larger*, but this is not a problem because
the argument on which we induct becomes *smaller*. -->

<p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code class="highlighter-rouge">[]</code>，由直接的运算可证。归纳步骤将列表实例化为 <code class="highlighter-rouge">x ∷ xs</code>，由归纳假设和附加的结合律可证。当我们使用归纳假设时，第二个参数实际上变<strong>大</strong>了，但是这样做没有问题，因为我们归纳的参数变<strong>小</strong>了。</p>

<!-- Generalising on an auxiliary argument, which becomes larger as the argument on
which we recurse or induct becomes smaller, is a common trick. It belongs in
your quiver of arrows, ready to slay the right problem. -->

<p>使用一个会在归纳或递归的参数变小时，变大的辅助参数来进行推广，是一个常用的技巧。这个技巧在以后的证明中很有用。</p>

<!-- Having defined shunt be generalisation, it is now easy to respecialise to
give a more efficient definition of reverse: -->

<p>在定义了推广的转移之后，我们可以将其特化，作为一个更高效的反转的定义：</p>

<pre class="Agda"><a id="reverse′"></a><a id="15938" href="/PLFA-zh/Lists/#15938" class="Function">reverse′</a> <a id="15947" class="Symbol">:</a> <a id="15949" class="Symbol">∀</a> <a id="15951" class="Symbol">{</a><a id="15952" href="/PLFA-zh/Lists/#15952" class="Bound">A</a> <a id="15954" class="Symbol">:</a> <a id="15956" class="PrimitiveType">Set</a><a id="15959" class="Symbol">}</a> <a id="15961" class="Symbol">→</a> <a id="15963" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="15968" href="/PLFA-zh/Lists/#15952" class="Bound">A</a> <a id="15970" class="Symbol">→</a> <a id="15972" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="15977" href="/PLFA-zh/Lists/#15952" class="Bound">A</a>
<a id="15979" href="/PLFA-zh/Lists/#15938" class="Function">reverse′</a> <a id="15988" href="/PLFA-zh/Lists/#15988" class="Bound">xs</a> <a id="15991" class="Symbol">=</a> <a id="15993" href="/PLFA-zh/Lists/#13945" class="Function">shunt</a> <a id="15999" href="/PLFA-zh/Lists/#15988" class="Bound">xs</a> <a id="16002" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a></pre>

<!-- Given our previous lemma, it is straightforward to show
the two definitions equivalent: -->

<p>因为我们之前证明的引理，我们可以直接地证明两个定义是等价的：</p>

<pre class="Agda"><a id="reverses"></a><a id="16168" href="/PLFA-zh/Lists/#16168" class="Function">reverses</a> <a id="16177" class="Symbol">:</a> <a id="16179" class="Symbol">∀</a> <a id="16181" class="Symbol">{</a><a id="16182" href="/PLFA-zh/Lists/#16182" class="Bound">A</a> <a id="16184" class="Symbol">:</a> <a id="16186" class="PrimitiveType">Set</a><a id="16189" class="Symbol">}</a> <a id="16191" class="Symbol">(</a><a id="16192" href="/PLFA-zh/Lists/#16192" class="Bound">xs</a> <a id="16195" class="Symbol">:</a> <a id="16197" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="16202" href="/PLFA-zh/Lists/#16182" class="Bound">A</a><a id="16203" class="Symbol">)</a>
  <a id="16207" class="Symbol">→</a> <a id="16209" href="/PLFA-zh/Lists/#15938" class="Function">reverse′</a> <a id="16218" href="/PLFA-zh/Lists/#16192" class="Bound">xs</a> <a id="16221" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="16223" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="16231" href="/PLFA-zh/Lists/#16192" class="Bound">xs</a>
<a id="16234" href="/PLFA-zh/Lists/#16168" class="Function">reverses</a> <a id="16243" href="/PLFA-zh/Lists/#16243" class="Bound">xs</a> <a id="16246" class="Symbol">=</a>
  <a id="16250" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="16260" href="/PLFA-zh/Lists/#15938" class="Function">reverse′</a> <a id="16269" href="/PLFA-zh/Lists/#16243" class="Bound">xs</a>
  <a id="16274" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="16282" href="/PLFA-zh/Lists/#13945" class="Function">shunt</a> <a id="16288" href="/PLFA-zh/Lists/#16243" class="Bound">xs</a> <a id="16291" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="16296" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="16299" href="/PLFA-zh/Lists/#14417" class="Function">shunt-reverse</a> <a id="16313" href="/PLFA-zh/Lists/#16243" class="Bound">xs</a> <a id="16316" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="16319" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="16325" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="16333" href="/PLFA-zh/Lists/#16243" class="Bound">xs</a> <a id="16336" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="16339" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="16344" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="16347" href="/PLFA-zh/Lists/#7970" class="Function">++-identityʳ</a> <a id="16360" class="Symbol">(</a><a id="16361" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="16369" href="/PLFA-zh/Lists/#16243" class="Bound">xs</a><a id="16371" class="Symbol">)</a> <a id="16373" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="16379" href="/PLFA-zh/Lists/#11165" class="Function">reverse</a> <a id="16387" href="/PLFA-zh/Lists/#16243" class="Bound">xs</a>
  <a id="16392" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>

<!-- Here is an example showing fast reverse of the list `[ 0 , 1 , 2 ]`: -->

<p>下面的例子展示了如何快速反转列表 <code class="highlighter-rouge">[ 0 , 1 , 2 ]</code>：</p>

<pre class="Agda"><a id="16541" href="/PLFA-zh/Lists/#16541" class="Function">_</a> <a id="16543" class="Symbol">:</a> <a id="16545" href="/PLFA-zh/Lists/#15938" class="Function">reverse′</a> <a id="16554" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="16556" class="Number">0</a> <a id="16558" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="16560" class="Number">1</a> <a id="16562" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="16564" class="Number">2</a> <a id="16566" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a> <a id="16568" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="16570" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="16572" class="Number">2</a> <a id="16574" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="16576" class="Number">1</a> <a id="16578" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="16580" class="Number">0</a> <a id="16582" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a>
<a id="16584" class="Symbol">_</a> <a id="16586" class="Symbol">=</a>
  <a id="16590" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="16600" href="/PLFA-zh/Lists/#15938" class="Function">reverse′</a> <a id="16609" class="Symbol">(</a><a id="16610" class="Number">0</a> <a id="16612" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16614" class="Number">1</a> <a id="16616" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16618" class="Number">2</a> <a id="16620" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16622" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="16624" class="Symbol">)</a>
  <a id="16628" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="16636" href="/PLFA-zh/Lists/#13945" class="Function">shunt</a> <a id="16642" class="Symbol">(</a><a id="16643" class="Number">0</a> <a id="16645" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16647" class="Number">1</a> <a id="16649" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16651" class="Number">2</a> <a id="16653" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16655" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="16657" class="Symbol">)</a> <a id="16659" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="16664" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="16672" href="/PLFA-zh/Lists/#13945" class="Function">shunt</a> <a id="16678" class="Symbol">(</a><a id="16679" class="Number">1</a> <a id="16681" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16683" class="Number">2</a> <a id="16685" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16687" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="16689" class="Symbol">)</a> <a id="16691" class="Symbol">(</a><a id="16692" class="Number">0</a> <a id="16694" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16696" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="16698" class="Symbol">)</a>
  <a id="16702" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="16710" href="/PLFA-zh/Lists/#13945" class="Function">shunt</a> <a id="16716" class="Symbol">(</a><a id="16717" class="Number">2</a> <a id="16719" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16721" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="16723" class="Symbol">)</a> <a id="16725" class="Symbol">(</a><a id="16726" class="Number">1</a> <a id="16728" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16730" class="Number">0</a> <a id="16732" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16734" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="16736" class="Symbol">)</a>
  <a id="16740" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="16748" href="/PLFA-zh/Lists/#13945" class="Function">shunt</a> <a id="16754" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="16757" class="Symbol">(</a><a id="16758" class="Number">2</a> <a id="16760" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16762" class="Number">1</a> <a id="16764" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16766" class="Number">0</a> <a id="16768" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16770" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="16772" class="Symbol">)</a>
  <a id="16776" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="16784" class="Number">2</a> <a id="16786" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16788" class="Number">1</a> <a id="16790" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16792" class="Number">0</a> <a id="16794" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="16796" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="16801" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>

<!-- Now the time to reverse a list is linear in the length of the list. -->

<p>现在反转一个列表需要的时间与列表的长度线性相关。</p>

<!-- ## Map {#Map} -->

<h2 id="Map">映射</h2>

<!-- Map applies a function to every element of a list to generate a corresponding list.
Map is an example of a _higher-order function_, one which takes a function as an
argument or returns a function as a result: -->

<p>映射将一个函数应用于列表中的所有元素，生成一个对应的列表。映射是一个<strong>高阶函数</strong>（Higher-Order Function）的例子，它取一个函数作为参数，返回一个函数作为结果：</p>
<pre class="Agda"><a id="map"></a><a id="17306" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="17310" class="Symbol">:</a> <a id="17312" class="Symbol">∀</a> <a id="17314" class="Symbol">{</a><a id="17315" href="/PLFA-zh/Lists/#17315" class="Bound">A</a> <a id="17317" href="/PLFA-zh/Lists/#17317" class="Bound">B</a> <a id="17319" class="Symbol">:</a> <a id="17321" class="PrimitiveType">Set</a><a id="17324" class="Symbol">}</a> <a id="17326" class="Symbol">→</a> <a id="17328" class="Symbol">(</a><a id="17329" href="/PLFA-zh/Lists/#17315" class="Bound">A</a> <a id="17331" class="Symbol">→</a> <a id="17333" href="/PLFA-zh/Lists/#17317" class="Bound">B</a><a id="17334" class="Symbol">)</a> <a id="17336" class="Symbol">→</a> <a id="17338" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="17343" href="/PLFA-zh/Lists/#17315" class="Bound">A</a> <a id="17345" class="Symbol">→</a> <a id="17347" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="17352" href="/PLFA-zh/Lists/#17317" class="Bound">B</a>
<a id="17354" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="17358" href="/PLFA-zh/Lists/#17358" class="Bound">f</a> <a id="17360" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>        <a id="17370" class="Symbol">=</a>  <a id="17373" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
<a id="17376" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="17380" href="/PLFA-zh/Lists/#17380" class="Bound">f</a> <a id="17382" class="Symbol">(</a><a id="17383" href="/PLFA-zh/Lists/#17383" class="Bound">x</a> <a id="17385" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="17387" href="/PLFA-zh/Lists/#17387" class="Bound">xs</a><a id="17389" class="Symbol">)</a>  <a id="17392" class="Symbol">=</a>  <a id="17395" href="/PLFA-zh/Lists/#17380" class="Bound">f</a> <a id="17397" href="/PLFA-zh/Lists/#17383" class="Bound">x</a> <a id="17399" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="17401" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="17405" href="/PLFA-zh/Lists/#17380" class="Bound">f</a> <a id="17407" href="/PLFA-zh/Lists/#17387" class="Bound">xs</a></pre>
<!-- Map of the empty list is the empty list.
Map of a non-empty list yields a list
with head the same as the function applied to the head of the given list,
and tail the same as map of the function applied to the tail of the given list. -->

<p>空列表的映射是空列表。非空列表的映射生成一个列表，其头元素是原列表的头元素在应用函数之后的结果，其尾列表是原列表的尾列表映射后的结果。</p>

<!-- Here is an example showing how to use map to increment every element of a list: -->

<p>下面的例子展示了如何使用映射来增加列表中的每一个元素：</p>
<pre class="Agda"><a id="17882" href="/PLFA-zh/Lists/#17882" class="Function">_</a> <a id="17884" class="Symbol">:</a> <a id="17886" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="17890" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="17894" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="17896" class="Number">0</a> <a id="17898" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="17900" class="Number">1</a> <a id="17902" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="17904" class="Number">2</a> <a id="17906" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a> <a id="17908" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="17910" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="17912" class="Number">1</a> <a id="17914" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="17916" class="Number">2</a> <a id="17918" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="17920" class="Number">3</a> <a id="17922" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a>
<a id="17924" class="Symbol">_</a> <a id="17926" class="Symbol">=</a>
  <a id="17930" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="17940" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="17944" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="17948" class="Symbol">(</a><a id="17949" class="Number">0</a> <a id="17951" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="17953" class="Number">1</a> <a id="17955" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="17957" class="Number">2</a> <a id="17959" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="17961" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="17963" class="Symbol">)</a>
  <a id="17967" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="17975" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="17979" class="Number">0</a> <a id="17981" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="17983" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="17987" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="17991" class="Symbol">(</a><a id="17992" class="Number">1</a> <a id="17994" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="17996" class="Number">2</a> <a id="17998" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="18000" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="18002" class="Symbol">)</a>
  <a id="18006" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="18014" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="18018" class="Number">0</a> <a id="18020" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="18022" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="18026" class="Number">1</a> <a id="18028" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="18030" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="18034" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="18038" class="Symbol">(</a><a id="18039" class="Number">2</a> <a id="18041" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="18043" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="18045" class="Symbol">)</a>
  <a id="18049" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="18057" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="18061" class="Number">0</a> <a id="18063" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="18065" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="18069" class="Number">1</a> <a id="18071" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="18073" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="18077" class="Number">2</a> <a id="18079" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="18081" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="18085" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="18089" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="18094" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="18102" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="18106" class="Number">0</a> <a id="18108" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="18110" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="18114" class="Number">1</a> <a id="18116" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="18118" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="18122" class="Number">2</a> <a id="18124" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="18126" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="18131" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="18139" class="Number">1</a> <a id="18141" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="18143" class="Number">2</a> <a id="18145" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="18147" class="Number">3</a> <a id="18149" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="18151" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="18156" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<!-- Map requires time linear in the length of the list. -->

<p>映射需要关于列表长度线性的时间。</p>

<!-- It is often convenient to exploit currying by applying
map to a function to yield a new function, and at a later
point applying the resulting function: -->

<p>我们常常可以利用柯里化，将映射作用于一个函数，获得另一个函数，然后在之后的时候应用获得的函数：</p>
<pre class="Agda"><a id="sucs"></a><a id="18488" href="/PLFA-zh/Lists/#18488" class="Function">sucs</a> <a id="18493" class="Symbol">:</a> <a id="18495" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="18500" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="18502" class="Symbol">→</a> <a id="18504" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="18509" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="18511" href="/PLFA-zh/Lists/#18488" class="Function">sucs</a> <a id="18516" class="Symbol">=</a> <a id="18518" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="18522" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a>

<a id="18527" href="/PLFA-zh/Lists/#18527" class="Function">_</a> <a id="18529" class="Symbol">:</a> <a id="18531" href="/PLFA-zh/Lists/#18488" class="Function">sucs</a> <a id="18536" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="18538" class="Number">0</a> <a id="18540" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="18542" class="Number">1</a> <a id="18544" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="18546" class="Number">2</a> <a id="18548" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a> <a id="18550" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="18552" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="18554" class="Number">1</a> <a id="18556" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="18558" class="Number">2</a> <a id="18560" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="18562" class="Number">3</a> <a id="18564" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a>
<a id="18566" class="Symbol">_</a> <a id="18568" class="Symbol">=</a>
  <a id="18572" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="18582" href="/PLFA-zh/Lists/#18488" class="Function">sucs</a> <a id="18587" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="18589" class="Number">0</a> <a id="18591" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="18593" class="Number">1</a> <a id="18595" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="18597" class="Number">2</a> <a id="18599" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a>
  <a id="18603" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="18611" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="18615" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="18619" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="18621" class="Number">0</a> <a id="18623" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="18625" class="Number">1</a> <a id="18627" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="18629" class="Number">2</a> <a id="18631" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a>
  <a id="18635" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="18643" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="18645" class="Number">1</a> <a id="18647" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="18649" class="Number">2</a> <a id="18651" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="18653" class="Number">3</a> <a id="18655" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a>
  <a id="18659" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>

<!-- Any type that is parameterised on another type, such as lists, has a
corresponding map, which accepts a function and returns a function
from the type parameterised on the domain of the function to the type
parameterised on the range of the function. Further, a type that is
parameterised on _n_ types will have a map that is parameterised on
_n_ functions. -->

<p>任何对于另外一个类型参数化的类型，例如列表，都有对应的映射，其接受一个函数，并返回另一个从由给定函数定义域参数化的类型，到由给定函数值域参数化的函数。除此之外，一个对于 <em>n</em> 个类型参数化的类型会有一个对于 <em>n</em> 个函数参数化的映射。</p>

<!-- #### Exercise `map-compose` -->

<h4 id="练习-map-compose">练习 <code class="highlighter-rouge">map-compose</code></h4>

<!-- Prove that the map of a composition is equal to the composition of two maps: -->

<p>证明函数组合的映射是两个映射的组合：</p>
<pre class="Agda"><a id="19367" class="Keyword">postulate</a>
  <a id="map-compose"></a><a id="19379" href="/PLFA-zh/Lists/#19379" class="Postulate">map-compose</a> <a id="19391" class="Symbol">:</a> <a id="19393" class="Symbol">∀</a> <a id="19395" class="Symbol">{</a><a id="19396" href="/PLFA-zh/Lists/#19396" class="Bound">A</a> <a id="19398" href="/PLFA-zh/Lists/#19398" class="Bound">B</a> <a id="19400" href="/PLFA-zh/Lists/#19400" class="Bound">C</a> <a id="19402" class="Symbol">:</a> <a id="19404" class="PrimitiveType">Set</a><a id="19407" class="Symbol">}</a> <a id="19409" class="Symbol">{</a><a id="19410" href="/PLFA-zh/Lists/#19410" class="Bound">f</a> <a id="19412" class="Symbol">:</a> <a id="19414" href="/PLFA-zh/Lists/#19396" class="Bound">A</a> <a id="19416" class="Symbol">→</a> <a id="19418" href="/PLFA-zh/Lists/#19398" class="Bound">B</a><a id="19419" class="Symbol">}</a> <a id="19421" class="Symbol">{</a><a id="19422" href="/PLFA-zh/Lists/#19422" class="Bound">g</a> <a id="19424" class="Symbol">:</a> <a id="19426" href="/PLFA-zh/Lists/#19398" class="Bound">B</a> <a id="19428" class="Symbol">→</a> <a id="19430" href="/PLFA-zh/Lists/#19400" class="Bound">C</a><a id="19431" class="Symbol">}</a>
    <a id="19437" class="Symbol">→</a> <a id="19439" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="19443" class="Symbol">(</a><a id="19444" href="/PLFA-zh/Lists/#19422" class="Bound">g</a> <a id="19446" href="https://agda.github.io/agda-stdlib/v0.17/Function.html#769" class="Function Operator">∘</a> <a id="19448" href="/PLFA-zh/Lists/#19410" class="Bound">f</a><a id="19449" class="Symbol">)</a> <a id="19451" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="19453" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="19457" href="/PLFA-zh/Lists/#19422" class="Bound">g</a> <a id="19459" href="https://agda.github.io/agda-stdlib/v0.17/Function.html#769" class="Function Operator">∘</a> <a id="19461" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="19465" href="/PLFA-zh/Lists/#19410" class="Bound">f</a></pre>
<!-- The last step of the proof requires extensionality. -->

<p>证明的最后一步需要外延性。</p>

<!-- #### Exercise `map-++-commute` -->

<h4 id="练习-map--commute">练习 <code class="highlighter-rouge">map-++-commute</code></h4>

<!-- Prove the following relationship between map and append: -->

<p>证明下列关于映射与附加的关系：</p>
<pre class="Agda"><a id="19742" class="Keyword">postulate</a>
  <a id="map-++-commute"></a><a id="19754" href="/PLFA-zh/Lists/#19754" class="Postulate">map-++-commute</a> <a id="19769" class="Symbol">:</a> <a id="19771" class="Symbol">∀</a> <a id="19773" class="Symbol">{</a><a id="19774" href="/PLFA-zh/Lists/#19774" class="Bound">A</a> <a id="19776" href="/PLFA-zh/Lists/#19776" class="Bound">B</a> <a id="19778" class="Symbol">:</a> <a id="19780" class="PrimitiveType">Set</a><a id="19783" class="Symbol">}</a> <a id="19785" class="Symbol">{</a><a id="19786" href="/PLFA-zh/Lists/#19786" class="Bound">f</a> <a id="19788" class="Symbol">:</a> <a id="19790" href="/PLFA-zh/Lists/#19774" class="Bound">A</a> <a id="19792" class="Symbol">→</a> <a id="19794" href="/PLFA-zh/Lists/#19776" class="Bound">B</a><a id="19795" class="Symbol">}</a> <a id="19797" class="Symbol">{</a><a id="19798" href="/PLFA-zh/Lists/#19798" class="Bound">xs</a> <a id="19801" href="/PLFA-zh/Lists/#19801" class="Bound">ys</a> <a id="19804" class="Symbol">:</a> <a id="19806" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="19811" href="/PLFA-zh/Lists/#19774" class="Bound">A</a><a id="19812" class="Symbol">}</a>
   <a id="19817" class="Symbol">→</a>  <a id="19820" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="19824" href="/PLFA-zh/Lists/#19786" class="Bound">f</a> <a id="19826" class="Symbol">(</a><a id="19827" href="/PLFA-zh/Lists/#19798" class="Bound">xs</a> <a id="19830" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="19833" href="/PLFA-zh/Lists/#19801" class="Bound">ys</a><a id="19835" class="Symbol">)</a> <a id="19837" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="19839" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="19843" href="/PLFA-zh/Lists/#19786" class="Bound">f</a> <a id="19845" href="/PLFA-zh/Lists/#19798" class="Bound">xs</a> <a id="19848" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="19851" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="19855" href="/PLFA-zh/Lists/#19786" class="Bound">f</a> <a id="19857" href="/PLFA-zh/Lists/#19801" class="Bound">ys</a></pre>

<!-- #### Exercise `map-Tree` -->

<h4 id="练习-map-tree">练习 <code class="highlighter-rouge">map-Tree</code></h4>

<!-- Define a type of trees with leaves of type `A` and internal
nodes of type `B`: -->

<p>定义一个树数据类型，其叶节点类型为 <code class="highlighter-rouge">A</code>，内部节点类型为 <code class="highlighter-rouge">B</code>：</p>
<pre class="Agda"><a id="20080" class="Keyword">data</a> <a id="Tree"></a><a id="20085" href="/PLFA-zh/Lists/#20085" class="Datatype">Tree</a> <a id="20090" class="Symbol">(</a><a id="20091" href="/PLFA-zh/Lists/#20091" class="Bound">A</a> <a id="20093" href="/PLFA-zh/Lists/#20093" class="Bound">B</a> <a id="20095" class="Symbol">:</a> <a id="20097" class="PrimitiveType">Set</a><a id="20100" class="Symbol">)</a> <a id="20102" class="Symbol">:</a> <a id="20104" class="PrimitiveType">Set</a> <a id="20108" class="Keyword">where</a>
  <a id="Tree.leaf"></a><a id="20116" href="/PLFA-zh/Lists/#20116" class="InductiveConstructor">leaf</a> <a id="20121" class="Symbol">:</a> <a id="20123" href="/PLFA-zh/Lists/#20091" class="Bound">A</a> <a id="20125" class="Symbol">→</a> <a id="20127" href="/PLFA-zh/Lists/#20085" class="Datatype">Tree</a> <a id="20132" href="/PLFA-zh/Lists/#20091" class="Bound">A</a> <a id="20134" href="/PLFA-zh/Lists/#20093" class="Bound">B</a>
  <a id="Tree.node"></a><a id="20138" href="/PLFA-zh/Lists/#20138" class="InductiveConstructor">node</a> <a id="20143" class="Symbol">:</a> <a id="20145" href="/PLFA-zh/Lists/#20085" class="Datatype">Tree</a> <a id="20150" href="/PLFA-zh/Lists/#20091" class="Bound">A</a> <a id="20152" href="/PLFA-zh/Lists/#20093" class="Bound">B</a> <a id="20154" class="Symbol">→</a> <a id="20156" href="/PLFA-zh/Lists/#20093" class="Bound">B</a> <a id="20158" class="Symbol">→</a> <a id="20160" href="/PLFA-zh/Lists/#20085" class="Datatype">Tree</a> <a id="20165" href="/PLFA-zh/Lists/#20091" class="Bound">A</a> <a id="20167" href="/PLFA-zh/Lists/#20093" class="Bound">B</a> <a id="20169" class="Symbol">→</a> <a id="20171" href="/PLFA-zh/Lists/#20085" class="Datatype">Tree</a> <a id="20176" href="/PLFA-zh/Lists/#20091" class="Bound">A</a> <a id="20178" href="/PLFA-zh/Lists/#20093" class="Bound">B</a></pre>
<!-- Define a suitable map operator over trees: -->

<p>定义一个对于树的映射运算符：</p>
<pre class="Agda"><a id="20280" class="Keyword">postulate</a>
  <a id="map-Tree"></a><a id="20292" href="/PLFA-zh/Lists/#20292" class="Postulate">map-Tree</a> <a id="20301" class="Symbol">:</a> <a id="20303" class="Symbol">∀</a> <a id="20305" class="Symbol">{</a><a id="20306" href="/PLFA-zh/Lists/#20306" class="Bound">A</a> <a id="20308" href="/PLFA-zh/Lists/#20308" class="Bound">B</a> <a id="20310" href="/PLFA-zh/Lists/#20310" class="Bound">C</a> <a id="20312" href="/PLFA-zh/Lists/#20312" class="Bound">D</a> <a id="20314" class="Symbol">:</a> <a id="20316" class="PrimitiveType">Set</a><a id="20319" class="Symbol">}</a>
    <a id="20325" class="Symbol">→</a> <a id="20327" class="Symbol">(</a><a id="20328" href="/PLFA-zh/Lists/#20306" class="Bound">A</a> <a id="20330" class="Symbol">→</a> <a id="20332" href="/PLFA-zh/Lists/#20310" class="Bound">C</a><a id="20333" class="Symbol">)</a> <a id="20335" class="Symbol">→</a> <a id="20337" class="Symbol">(</a><a id="20338" href="/PLFA-zh/Lists/#20308" class="Bound">B</a> <a id="20340" class="Symbol">→</a> <a id="20342" href="/PLFA-zh/Lists/#20312" class="Bound">D</a><a id="20343" class="Symbol">)</a> <a id="20345" class="Symbol">→</a> <a id="20347" href="/PLFA-zh/Lists/#20085" class="Datatype">Tree</a> <a id="20352" href="/PLFA-zh/Lists/#20306" class="Bound">A</a> <a id="20354" href="/PLFA-zh/Lists/#20308" class="Bound">B</a> <a id="20356" class="Symbol">→</a> <a id="20358" href="/PLFA-zh/Lists/#20085" class="Datatype">Tree</a> <a id="20363" href="/PLFA-zh/Lists/#20310" class="Bound">C</a> <a id="20365" href="/PLFA-zh/Lists/#20312" class="Bound">D</a></pre>

<!-- ## Fold {#Fold} -->

<h2 id="Fold">折叠</h2>

<!-- Fold takes an operator and a value, and uses the operator to combine
each of the elements of the list, taking the given value as the result
for the empty list: -->

<p>折叠取一个运算符和一个值，并使用运算符将列表中的元素合并至一个值，如果给定的列表为空，则使用给定的值：</p>
<pre class="Agda"><a id="foldr"></a><a id="20673" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="20679" class="Symbol">:</a> <a id="20681" class="Symbol">∀</a> <a id="20683" class="Symbol">{</a><a id="20684" href="/PLFA-zh/Lists/#20684" class="Bound">A</a> <a id="20686" href="/PLFA-zh/Lists/#20686" class="Bound">B</a> <a id="20688" class="Symbol">:</a> <a id="20690" class="PrimitiveType">Set</a><a id="20693" class="Symbol">}</a> <a id="20695" class="Symbol">→</a> <a id="20697" class="Symbol">(</a><a id="20698" href="/PLFA-zh/Lists/#20684" class="Bound">A</a> <a id="20700" class="Symbol">→</a> <a id="20702" href="/PLFA-zh/Lists/#20686" class="Bound">B</a> <a id="20704" class="Symbol">→</a> <a id="20706" href="/PLFA-zh/Lists/#20686" class="Bound">B</a><a id="20707" class="Symbol">)</a> <a id="20709" class="Symbol">→</a> <a id="20711" href="/PLFA-zh/Lists/#20686" class="Bound">B</a> <a id="20713" class="Symbol">→</a> <a id="20715" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="20720" href="/PLFA-zh/Lists/#20684" class="Bound">A</a> <a id="20722" class="Symbol">→</a> <a id="20724" href="/PLFA-zh/Lists/#20686" class="Bound">B</a>
<a id="20726" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="20732" href="/PLFA-zh/Lists/#20732" class="Bound Operator">_⊗_</a> <a id="20736" href="/PLFA-zh/Lists/#20736" class="Bound">e</a> <a id="20738" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>        <a id="20748" class="Symbol">=</a>  <a id="20751" href="/PLFA-zh/Lists/#20736" class="Bound">e</a>
<a id="20753" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="20759" href="/PLFA-zh/Lists/#20759" class="Bound Operator">_⊗_</a> <a id="20763" href="/PLFA-zh/Lists/#20763" class="Bound">e</a> <a id="20765" class="Symbol">(</a><a id="20766" href="/PLFA-zh/Lists/#20766" class="Bound">x</a> <a id="20768" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="20770" href="/PLFA-zh/Lists/#20770" class="Bound">xs</a><a id="20772" class="Symbol">)</a>  <a id="20775" class="Symbol">=</a>  <a id="20778" href="/PLFA-zh/Lists/#20766" class="Bound">x</a> <a id="20780" href="/PLFA-zh/Lists/#20759" class="Bound Operator">⊗</a> <a id="20782" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="20788" href="/PLFA-zh/Lists/#20759" class="Bound Operator">_⊗_</a> <a id="20792" href="/PLFA-zh/Lists/#20763" class="Bound">e</a> <a id="20794" href="/PLFA-zh/Lists/#20770" class="Bound">xs</a></pre>
<!-- Fold of the empty list is the given value.
Fold of a non-empty list uses the operator to combine
the head of the list and the fold of the tail of the list. -->

<p>空列表的折叠是给定的值。非空列表的折叠使用给定的运算符，将头元素和尾列表的折叠合并起来。</p>

<!-- Here is an example showing how to use fold to find the sum of a list: -->

<p>下面的例子展示了如何使用折叠来对一个列表求和：</p>
<pre class="Agda"><a id="21154" href="/PLFA-zh/Lists/#21154" class="Function">_</a> <a id="21156" class="Symbol">:</a> <a id="21158" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="21164" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="21168" class="Number">0</a> <a id="21170" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">[</a> <a id="21172" class="Number">1</a> <a id="21174" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="21176" class="Number">2</a> <a id="21178" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="21180" class="Number">3</a> <a id="21182" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="21184" class="Number">4</a> <a id="21186" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">]</a> <a id="21188" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="21190" class="Number">10</a>
<a id="21193" class="Symbol">_</a> <a id="21195" class="Symbol">=</a>
  <a id="21199" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="21209" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="21215" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="21219" class="Number">0</a> <a id="21221" class="Symbol">(</a><a id="21222" class="Number">1</a> <a id="21224" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="21226" class="Number">2</a> <a id="21228" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="21230" class="Number">3</a> <a id="21232" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="21234" class="Number">4</a> <a id="21236" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="21238" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="21240" class="Symbol">)</a>
  <a id="21244" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="21252" class="Number">1</a> <a id="21254" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="21256" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="21262" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="21266" class="Number">0</a> <a id="21268" class="Symbol">(</a><a id="21269" class="Number">2</a> <a id="21271" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="21273" class="Number">3</a> <a id="21275" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="21277" class="Number">4</a> <a id="21279" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="21281" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="21283" class="Symbol">)</a>
  <a id="21287" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="21295" class="Number">1</a> <a id="21297" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="21299" class="Symbol">(</a><a id="21300" class="Number">2</a> <a id="21302" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="21304" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="21310" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="21314" class="Number">0</a> <a id="21316" class="Symbol">(</a><a id="21317" class="Number">3</a> <a id="21319" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="21321" class="Number">4</a> <a id="21323" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="21325" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="21327" class="Symbol">))</a>
  <a id="21332" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="21340" class="Number">1</a> <a id="21342" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="21344" class="Symbol">(</a><a id="21345" class="Number">2</a> <a id="21347" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="21349" class="Symbol">(</a><a id="21350" class="Number">3</a> <a id="21352" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="21354" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="21360" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="21364" class="Number">0</a> <a id="21366" class="Symbol">(</a><a id="21367" class="Number">4</a> <a id="21369" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="21371" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="21373" class="Symbol">)))</a>
  <a id="21379" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="21387" class="Number">1</a> <a id="21389" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="21391" class="Symbol">(</a><a id="21392" class="Number">2</a> <a id="21394" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="21396" class="Symbol">(</a><a id="21397" class="Number">3</a> <a id="21399" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="21401" class="Symbol">(</a><a id="21402" class="Number">4</a> <a id="21404" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="21406" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="21412" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="21416" class="Number">0</a> <a id="21418" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a><a id="21420" class="Symbol">)))</a>
  <a id="21426" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="21434" class="Number">1</a> <a id="21436" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="21438" class="Symbol">(</a><a id="21439" class="Number">2</a> <a id="21441" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="21443" class="Symbol">(</a><a id="21444" class="Number">3</a> <a id="21446" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="21448" class="Symbol">(</a><a id="21449" class="Number">4</a> <a id="21451" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="21453" class="Number">0</a><a id="21454" class="Symbol">)))</a>
  <a id="21460" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<!-- Fold requires time linear in the length of the list. -->

<p>折叠需要关于列表长度线性的时间。</p>

<!-- It is often convenient to exploit currying by applying
fold to an operator and a value to yield a new function,
and at a later point applying the resulting function: -->

<p>我们常常可以利用柯里化，将折叠作用于一个运算符和一个值，获得另一个函数，然后在之后的时候应用获得的函数：</p>
<pre class="Agda"><a id="sum"></a><a id="21813" href="/PLFA-zh/Lists/#21813" class="Function">sum</a> <a id="21817" class="Symbol">:</a> <a id="21819" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="21824" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="21826" class="Symbol">→</a> <a id="21828" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="21830" href="/PLFA-zh/Lists/#21813" class="Function">sum</a> <a id="21834" class="Symbol">=</a> <a id="21836" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="21842" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="21846" class="Number">0</a>

<a id="21849" href="/PLFA-zh/Lists/#21849" class="Function">_</a> <a id="21851" class="Symbol">:</a> <a id="21853" href="/PLFA-zh/Lists/#21813" class="Function">sum</a> <a id="21857" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">[</a> <a id="21859" class="Number">1</a> <a id="21861" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="21863" class="Number">2</a> <a id="21865" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="21867" class="Number">3</a> <a id="21869" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="21871" class="Number">4</a> <a id="21873" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">]</a> <a id="21875" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="21877" class="Number">10</a>
<a id="21880" class="Symbol">_</a> <a id="21882" class="Symbol">=</a>
  <a id="21886" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="21896" href="/PLFA-zh/Lists/#21813" class="Function">sum</a> <a id="21900" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">[</a> <a id="21902" class="Number">1</a> <a id="21904" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="21906" class="Number">2</a> <a id="21908" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="21910" class="Number">3</a> <a id="21912" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="21914" class="Number">4</a> <a id="21916" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">]</a>
  <a id="21920" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="21928" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="21934" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="21938" class="Number">0</a> <a id="21940" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">[</a> <a id="21942" class="Number">1</a> <a id="21944" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="21946" class="Number">2</a> <a id="21948" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="21950" class="Number">3</a> <a id="21952" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="21954" class="Number">4</a> <a id="21956" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">]</a>
  <a id="21960" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="21968" class="Number">10</a>
  <a id="21973" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>

<!-- Just as the list type has two constructors, `[]` and `_∷_`,
so the fold function takes two arguments, `e` and `_⊗_`
(in addition to the list argument).
In general, a data type with _n_ constructors will have
a corresponding fold function that takes _n_ arguments. -->

<p>正如列表由两个构造器 <code class="highlighter-rouge">[]</code> 和 <code class="highlighter-rouge">_∷_</code>，折叠函数取两个参数 <code class="highlighter-rouge">e</code> 和 <code class="highlighter-rouge">_⊗_</code>
（除去列表参数）。推广来说，一个有 <em>n</em> 个构造器的数据类型，会有对应的取 <em>n</em> 个参数的折叠函数。</p>

<!-- #### Exercise `product` (recommended) -->

<h4 id="练习-product-推荐">练习 <code class="highlighter-rouge">product</code> （推荐）</h4>

<!-- Use fold to define a function to find the product of a list of numbers.
For example: -->

<p>使用折叠来定义一个计算列表数字之积的函数。例如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>product [ 1 , 2 , 3 , 4 ] ≡ 24
</code></pre></div></div>

<!-- <pre class="Agda"><a id="22640" class="Comment">-- Your code goes here</a></pre> -->

<pre class="Agda"><a id="22693" class="Comment">-- 请将代码写在此处。</a></pre>

<!-- #### Exercise `foldr-++` (recommended) -->

<h4 id="练习-foldr--推荐">练习 <code class="highlighter-rouge">foldr-++</code> （推荐）</h4>

<!-- Show that fold and append are related as follows: -->

<p>证明折叠和附加有如下的关系：</p>
<pre class="Agda"><a id="22896" class="Keyword">postulate</a>
  <a id="foldr-++"></a><a id="22908" href="/PLFA-zh/Lists/#22908" class="Postulate">foldr-++</a> <a id="22917" class="Symbol">:</a> <a id="22919" class="Symbol">∀</a> <a id="22921" class="Symbol">{</a><a id="22922" href="/PLFA-zh/Lists/#22922" class="Bound">A</a> <a id="22924" href="/PLFA-zh/Lists/#22924" class="Bound">B</a> <a id="22926" class="Symbol">:</a> <a id="22928" class="PrimitiveType">Set</a><a id="22931" class="Symbol">}</a> <a id="22933" class="Symbol">(</a><a id="22934" href="/PLFA-zh/Lists/#22934" class="Bound Operator">_⊗_</a> <a id="22938" class="Symbol">:</a> <a id="22940" href="/PLFA-zh/Lists/#22922" class="Bound">A</a> <a id="22942" class="Symbol">→</a> <a id="22944" href="/PLFA-zh/Lists/#22924" class="Bound">B</a> <a id="22946" class="Symbol">→</a> <a id="22948" href="/PLFA-zh/Lists/#22924" class="Bound">B</a><a id="22949" class="Symbol">)</a> <a id="22951" class="Symbol">(</a><a id="22952" href="/PLFA-zh/Lists/#22952" class="Bound">e</a> <a id="22954" class="Symbol">:</a> <a id="22956" href="/PLFA-zh/Lists/#22924" class="Bound">B</a><a id="22957" class="Symbol">)</a> <a id="22959" class="Symbol">(</a><a id="22960" href="/PLFA-zh/Lists/#22960" class="Bound">xs</a> <a id="22963" href="/PLFA-zh/Lists/#22963" class="Bound">ys</a> <a id="22966" class="Symbol">:</a> <a id="22968" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="22973" href="/PLFA-zh/Lists/#22922" class="Bound">A</a><a id="22974" class="Symbol">)</a> <a id="22976" class="Symbol">→</a>
    <a id="22982" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="22988" href="/PLFA-zh/Lists/#22934" class="Bound Operator">_⊗_</a> <a id="22992" href="/PLFA-zh/Lists/#22952" class="Bound">e</a> <a id="22994" class="Symbol">(</a><a id="22995" href="/PLFA-zh/Lists/#22960" class="Bound">xs</a> <a id="22998" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="23001" href="/PLFA-zh/Lists/#22963" class="Bound">ys</a><a id="23003" class="Symbol">)</a> <a id="23005" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="23007" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="23013" href="/PLFA-zh/Lists/#22934" class="Bound Operator">_⊗_</a> <a id="23017" class="Symbol">(</a><a id="23018" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="23024" href="/PLFA-zh/Lists/#22934" class="Bound Operator">_⊗_</a> <a id="23028" href="/PLFA-zh/Lists/#22952" class="Bound">e</a> <a id="23030" href="/PLFA-zh/Lists/#22963" class="Bound">ys</a><a id="23032" class="Symbol">)</a> <a id="23034" href="/PLFA-zh/Lists/#22960" class="Bound">xs</a></pre>

<!-- #### Exercise `map-is-foldr` -->

<h4 id="练习-map-is-foldr">练习 <code class="highlighter-rouge">map-is-foldr</code></h4>

<!-- Show that map can be defined using fold: -->

<p>证明映射可以用折叠定义：</p>
<pre class="Agda"><a id="23206" class="Keyword">postulate</a>
  <a id="map-is-foldr"></a><a id="23218" href="/PLFA-zh/Lists/#23218" class="Postulate">map-is-foldr</a> <a id="23231" class="Symbol">:</a> <a id="23233" class="Symbol">∀</a> <a id="23235" class="Symbol">{</a><a id="23236" href="/PLFA-zh/Lists/#23236" class="Bound">A</a> <a id="23238" href="/PLFA-zh/Lists/#23238" class="Bound">B</a> <a id="23240" class="Symbol">:</a> <a id="23242" class="PrimitiveType">Set</a><a id="23245" class="Symbol">}</a> <a id="23247" class="Symbol">{</a><a id="23248" href="/PLFA-zh/Lists/#23248" class="Bound">f</a> <a id="23250" class="Symbol">:</a> <a id="23252" href="/PLFA-zh/Lists/#23236" class="Bound">A</a> <a id="23254" class="Symbol">→</a> <a id="23256" href="/PLFA-zh/Lists/#23238" class="Bound">B</a><a id="23257" class="Symbol">}</a> <a id="23259" class="Symbol">→</a>
    <a id="23265" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="23269" href="/PLFA-zh/Lists/#23248" class="Bound">f</a> <a id="23271" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="23273" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="23279" class="Symbol">(λ</a> <a id="23282" href="/PLFA-zh/Lists/#23282" class="Bound">x</a> <a id="23284" href="/PLFA-zh/Lists/#23284" class="Bound">xs</a> <a id="23287" class="Symbol">→</a> <a id="23289" href="/PLFA-zh/Lists/#23248" class="Bound">f</a> <a id="23291" href="/PLFA-zh/Lists/#23282" class="Bound">x</a> <a id="23293" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="23295" href="/PLFA-zh/Lists/#23284" class="Bound">xs</a><a id="23297" class="Symbol">)</a> <a id="23299" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a></pre>
<!-- This requires extensionality. -->

<p>此证明需要外延性。</p>

<!-- #### Exercise `fold-Tree` -->

<h4 id="练习-fold-tree">练习 <code class="highlighter-rouge">fold-Tree</code></h4>

<!-- Define a suitable fold function for the type of trees given earlier: -->

<p>为之前给出的树数据类型定义一个折叠函数：</p>
<pre class="Agda"><a id="23558" class="Keyword">postulate</a>
  <a id="fold-Tree"></a><a id="23570" href="/PLFA-zh/Lists/#23570" class="Postulate">fold-Tree</a> <a id="23580" class="Symbol">:</a> <a id="23582" class="Symbol">∀</a> <a id="23584" class="Symbol">{</a><a id="23585" href="/PLFA-zh/Lists/#23585" class="Bound">A</a> <a id="23587" href="/PLFA-zh/Lists/#23587" class="Bound">B</a> <a id="23589" href="/PLFA-zh/Lists/#23589" class="Bound">C</a> <a id="23591" class="Symbol">:</a> <a id="23593" class="PrimitiveType">Set</a><a id="23596" class="Symbol">}</a>
    <a id="23602" class="Symbol">→</a> <a id="23604" class="Symbol">(</a><a id="23605" href="/PLFA-zh/Lists/#23585" class="Bound">A</a> <a id="23607" class="Symbol">→</a> <a id="23609" href="/PLFA-zh/Lists/#23589" class="Bound">C</a><a id="23610" class="Symbol">)</a> <a id="23612" class="Symbol">→</a> <a id="23614" class="Symbol">(</a><a id="23615" href="/PLFA-zh/Lists/#23589" class="Bound">C</a> <a id="23617" class="Symbol">→</a> <a id="23619" href="/PLFA-zh/Lists/#23587" class="Bound">B</a> <a id="23621" class="Symbol">→</a> <a id="23623" href="/PLFA-zh/Lists/#23589" class="Bound">C</a> <a id="23625" class="Symbol">→</a> <a id="23627" href="/PLFA-zh/Lists/#23589" class="Bound">C</a><a id="23628" class="Symbol">)</a> <a id="23630" class="Symbol">→</a> <a id="23632" href="/PLFA-zh/Lists/#20085" class="Datatype">Tree</a> <a id="23637" href="/PLFA-zh/Lists/#23585" class="Bound">A</a> <a id="23639" href="/PLFA-zh/Lists/#23587" class="Bound">B</a> <a id="23641" class="Symbol">→</a> <a id="23643" href="/PLFA-zh/Lists/#23589" class="Bound">C</a></pre>

<!-- <pre class="Agda"><a id="23682" class="Comment">-- Your code goes here</a></pre> -->

<pre class="Agda"><a id="23735" class="Comment">-- 请将代码写在此处。</a></pre>

<!-- #### Exercise `map-is-fold-Tree` -->

<h4 id="练习-map-is-fold-tree">练习 <code class="highlighter-rouge">map-is-fold-Tree</code></h4>

<!-- Demonstrate an analogue of `map-is-foldr` for the type of trees. -->

<p>对于树数据类型，证明与 <code class="highlighter-rouge">map-is-foldr</code> 相似的性质。</p>

<!-- <pre class="Agda"><a id="23982" class="Comment">-- Your code goes here</a></pre> -->

<pre class="Agda"><a id="24035" class="Comment">-- 请将代码写在此处。</a></pre>

<!-- #### Exercise `sum-downFrom` (stretch) -->

<h4 id="证明-sum-downfrom-延伸">证明 <code class="highlighter-rouge">sum-downFrom</code> （延伸）</h4>

<!-- Define a function that counts down as follows: -->

<p>定义一个向下数数的函数：</p>
<pre class="Agda"><a id="downFrom"></a><a id="24237" href="/PLFA-zh/Lists/#24237" class="Function">downFrom</a> <a id="24246" class="Symbol">:</a> <a id="24248" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="24250" class="Symbol">→</a> <a id="24252" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="24257" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="24259" href="/PLFA-zh/Lists/#24237" class="Function">downFrom</a> <a id="24268" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a>     <a id="24277" class="Symbol">=</a>  <a id="24280" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
<a id="24283" href="/PLFA-zh/Lists/#24237" class="Function">downFrom</a> <a id="24292" class="Symbol">(</a><a id="24293" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="24297" href="/PLFA-zh/Lists/#24297" class="Bound">n</a><a id="24298" class="Symbol">)</a>  <a id="24301" class="Symbol">=</a>  <a id="24304" href="/PLFA-zh/Lists/#24297" class="Bound">n</a> <a id="24306" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="24308" href="/PLFA-zh/Lists/#24237" class="Function">downFrom</a> <a id="24317" href="/PLFA-zh/Lists/#24297" class="Bound">n</a></pre>
<!-- For example: -->

<p>例如：</p>
<pre class="Agda"><a id="24378" href="/PLFA-zh/Lists/#24378" class="Function">_</a> <a id="24380" class="Symbol">:</a> <a id="24382" href="/PLFA-zh/Lists/#24237" class="Function">downFrom</a> <a id="24391" class="Number">3</a> <a id="24393" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="24395" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="24397" class="Number">2</a> <a id="24399" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="24401" class="Number">1</a> <a id="24403" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="24405" class="Number">0</a> <a id="24407" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a>
<a id="24409" class="Symbol">_</a> <a id="24411" class="Symbol">=</a> <a id="24413" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<!-- Prove that the sum of the numbers `(n - 1) + ⋯ + 0` is
equal to `n * (n ∸ 1) / 2`: -->

<p>证明数列之和 <code class="highlighter-rouge">(n - 1) + ⋯ + 0</code> 等于 <code class="highlighter-rouge">n * (n ∸ 1) / 2</code>：</p>

<pre class="Agda"><a id="24591" class="Keyword">postulate</a>
  <a id="sum-downFrom"></a><a id="24603" href="/PLFA-zh/Lists/#24603" class="Postulate">sum-downFrom</a> <a id="24616" class="Symbol">:</a> <a id="24618" class="Symbol">∀</a> <a id="24620" class="Symbol">(</a><a id="24621" href="/PLFA-zh/Lists/#24621" class="Bound">n</a> <a id="24623" class="Symbol">:</a> <a id="24625" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="24626" class="Symbol">)</a>
    <a id="24632" class="Symbol">→</a> <a id="24634" href="/PLFA-zh/Lists/#21813" class="Function">sum</a> <a id="24638" class="Symbol">(</a><a id="24639" href="/PLFA-zh/Lists/#24237" class="Function">downFrom</a> <a id="24648" href="/PLFA-zh/Lists/#24621" class="Bound">n</a><a id="24649" class="Symbol">)</a> <a id="24651" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#433" class="Primitive Operator">*</a> <a id="24653" class="Number">2</a> <a id="24655" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="24657" href="/PLFA-zh/Lists/#24621" class="Bound">n</a> <a id="24659" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#433" class="Primitive Operator">*</a> <a id="24661" class="Symbol">(</a><a id="24662" href="/PLFA-zh/Lists/#24621" class="Bound">n</a> <a id="24664" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#320" class="Primitive Operator">∸</a> <a id="24666" class="Number">1</a><a id="24667" class="Symbol">)</a></pre>

<!-- ## Monoids -->

<h2 id="幺半群">幺半群</h2>

<!-- Typically when we use a fold the operator is associative and the
value is a left and right identity for the operator, meaning that the
operator and the value form a _monoid_. -->

<p>一般来说，我们会对于折叠函数使用一个满足结合律的运算符，和这个运算符的左右幺元。这意味着这个运算符和这个值形成了一个<strong>幺半群</strong>（Monoid）。</p>

<!-- We can define a monoid as a suitable record type: -->

<p>我们可以用一个合适的记录类型来定义幺半群：</p>
<pre class="Agda"><a id="25092" class="Keyword">record</a> <a id="IsMonoid"></a><a id="25099" href="/PLFA-zh/Lists/#25099" class="Record">IsMonoid</a> <a id="25108" class="Symbol">{</a><a id="25109" href="/PLFA-zh/Lists/#25109" class="Bound">A</a> <a id="25111" class="Symbol">:</a> <a id="25113" class="PrimitiveType">Set</a><a id="25116" class="Symbol">}</a> <a id="25118" class="Symbol">(</a><a id="25119" href="/PLFA-zh/Lists/#25119" class="Bound Operator">_⊗_</a> <a id="25123" class="Symbol">:</a> <a id="25125" href="/PLFA-zh/Lists/#25109" class="Bound">A</a> <a id="25127" class="Symbol">→</a> <a id="25129" href="/PLFA-zh/Lists/#25109" class="Bound">A</a> <a id="25131" class="Symbol">→</a> <a id="25133" href="/PLFA-zh/Lists/#25109" class="Bound">A</a><a id="25134" class="Symbol">)</a> <a id="25136" class="Symbol">(</a><a id="25137" href="/PLFA-zh/Lists/#25137" class="Bound">e</a> <a id="25139" class="Symbol">:</a> <a id="25141" href="/PLFA-zh/Lists/#25109" class="Bound">A</a><a id="25142" class="Symbol">)</a> <a id="25144" class="Symbol">:</a> <a id="25146" class="PrimitiveType">Set</a> <a id="25150" class="Keyword">where</a>
  <a id="25158" class="Keyword">field</a>
    <a id="IsMonoid.assoc"></a><a id="25168" href="/PLFA-zh/Lists/#25168" class="Field">assoc</a> <a id="25174" class="Symbol">:</a> <a id="25176" class="Symbol">∀</a> <a id="25178" class="Symbol">(</a><a id="25179" href="/PLFA-zh/Lists/#25179" class="Bound">x</a> <a id="25181" href="/PLFA-zh/Lists/#25181" class="Bound">y</a> <a id="25183" href="/PLFA-zh/Lists/#25183" class="Bound">z</a> <a id="25185" class="Symbol">:</a> <a id="25187" href="/PLFA-zh/Lists/#25109" class="Bound">A</a><a id="25188" class="Symbol">)</a> <a id="25190" class="Symbol">→</a> <a id="25192" class="Symbol">(</a><a id="25193" href="/PLFA-zh/Lists/#25179" class="Bound">x</a> <a id="25195" href="/PLFA-zh/Lists/#25119" class="Bound Operator">⊗</a> <a id="25197" href="/PLFA-zh/Lists/#25181" class="Bound">y</a><a id="25198" class="Symbol">)</a> <a id="25200" href="/PLFA-zh/Lists/#25119" class="Bound Operator">⊗</a> <a id="25202" href="/PLFA-zh/Lists/#25183" class="Bound">z</a> <a id="25204" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="25206" href="/PLFA-zh/Lists/#25179" class="Bound">x</a> <a id="25208" href="/PLFA-zh/Lists/#25119" class="Bound Operator">⊗</a> <a id="25210" class="Symbol">(</a><a id="25211" href="/PLFA-zh/Lists/#25181" class="Bound">y</a> <a id="25213" href="/PLFA-zh/Lists/#25119" class="Bound Operator">⊗</a> <a id="25215" href="/PLFA-zh/Lists/#25183" class="Bound">z</a><a id="25216" class="Symbol">)</a>
    <a id="IsMonoid.identityˡ"></a><a id="25222" href="/PLFA-zh/Lists/#25222" class="Field">identityˡ</a> <a id="25232" class="Symbol">:</a> <a id="25234" class="Symbol">∀</a> <a id="25236" class="Symbol">(</a><a id="25237" href="/PLFA-zh/Lists/#25237" class="Bound">x</a> <a id="25239" class="Symbol">:</a> <a id="25241" href="/PLFA-zh/Lists/#25109" class="Bound">A</a><a id="25242" class="Symbol">)</a> <a id="25244" class="Symbol">→</a> <a id="25246" href="/PLFA-zh/Lists/#25137" class="Bound">e</a> <a id="25248" href="/PLFA-zh/Lists/#25119" class="Bound Operator">⊗</a> <a id="25250" href="/PLFA-zh/Lists/#25237" class="Bound">x</a> <a id="25252" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="25254" href="/PLFA-zh/Lists/#25237" class="Bound">x</a>
    <a id="IsMonoid.identityʳ"></a><a id="25260" href="/PLFA-zh/Lists/#25260" class="Field">identityʳ</a> <a id="25270" class="Symbol">:</a> <a id="25272" class="Symbol">∀</a> <a id="25274" class="Symbol">(</a><a id="25275" href="/PLFA-zh/Lists/#25275" class="Bound">x</a> <a id="25277" class="Symbol">:</a> <a id="25279" href="/PLFA-zh/Lists/#25109" class="Bound">A</a><a id="25280" class="Symbol">)</a> <a id="25282" class="Symbol">→</a> <a id="25284" href="/PLFA-zh/Lists/#25275" class="Bound">x</a> <a id="25286" href="/PLFA-zh/Lists/#25119" class="Bound Operator">⊗</a> <a id="25288" href="/PLFA-zh/Lists/#25137" class="Bound">e</a> <a id="25290" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="25292" href="/PLFA-zh/Lists/#25275" class="Bound">x</a>

<a id="25295" class="Keyword">open</a> <a id="25300" href="/PLFA-zh/Lists/#25099" class="Module">IsMonoid</a></pre>

<!-- As examples, sum and zero, multiplication and one, and append and the empty
list, are all examples of monoids: -->

<p>举例来说，加法和零，乘法和一，附加和空列表，都是幺半群：</p>
<pre class="Agda"><a id="+-monoid"></a><a id="25492" href="/PLFA-zh/Lists/#25492" class="Function">+-monoid</a> <a id="25501" class="Symbol">:</a> <a id="25503" href="/PLFA-zh/Lists/#25099" class="Record">IsMonoid</a> <a id="25512" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="25516" class="Number">0</a>
<a id="25518" href="/PLFA-zh/Lists/#25492" class="Function">+-monoid</a> <a id="25527" class="Symbol">=</a>
  <a id="25531" class="Keyword">record</a>
    <a id="25542" class="Symbol">{</a> <a id="25544" class="Field">assoc</a> <a id="25550" class="Symbol">=</a> <a id="25552" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Properties.html#9375" class="Function">+-assoc</a>
    <a id="25564" class="Symbol">;</a> <a id="25566" class="Field">identityˡ</a> <a id="25576" class="Symbol">=</a> <a id="25578" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Properties.html#9476" class="Function">+-identityˡ</a>
    <a id="25594" class="Symbol">;</a> <a id="25596" class="Field">identityʳ</a> <a id="25606" class="Symbol">=</a> <a id="25608" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Properties.html#9531" class="Function">+-identityʳ</a>
    <a id="25624" class="Symbol">}</a>

<a id="*-monoid"></a><a id="25627" href="/PLFA-zh/Lists/#25627" class="Function">*-monoid</a> <a id="25636" class="Symbol">:</a> <a id="25638" href="/PLFA-zh/Lists/#25099" class="Record">IsMonoid</a> <a id="25647" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#433" class="Primitive Operator">_*_</a> <a id="25651" class="Number">1</a>
<a id="25653" href="/PLFA-zh/Lists/#25627" class="Function">*-monoid</a> <a id="25662" class="Symbol">=</a>
  <a id="25666" class="Keyword">record</a>
    <a id="25677" class="Symbol">{</a> <a id="25679" class="Field">assoc</a> <a id="25685" class="Symbol">=</a> <a id="25687" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Properties.html#15493" class="Function">*-assoc</a>
    <a id="25699" class="Symbol">;</a> <a id="25701" class="Field">identityˡ</a> <a id="25711" class="Symbol">=</a> <a id="25713" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Properties.html#14397" class="Function">*-identityˡ</a>
    <a id="25729" class="Symbol">;</a> <a id="25731" class="Field">identityʳ</a> <a id="25741" class="Symbol">=</a> <a id="25743" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Properties.html#14461" class="Function">*-identityʳ</a>
    <a id="25759" class="Symbol">}</a>

<a id="++-monoid"></a><a id="25762" href="/PLFA-zh/Lists/#25762" class="Function">++-monoid</a> <a id="25772" class="Symbol">:</a> <a id="25774" class="Symbol">∀</a> <a id="25776" class="Symbol">{</a><a id="25777" href="/PLFA-zh/Lists/#25777" class="Bound">A</a> <a id="25779" class="Symbol">:</a> <a id="25781" class="PrimitiveType">Set</a><a id="25784" class="Symbol">}</a> <a id="25786" class="Symbol">→</a> <a id="25788" href="/PLFA-zh/Lists/#25099" class="Record">IsMonoid</a> <a id="25797" class="Symbol">{</a><a id="25798" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="25803" href="/PLFA-zh/Lists/#25777" class="Bound">A</a><a id="25804" class="Symbol">}</a> <a id="25806" href="/PLFA-zh/Lists/#4769" class="Function Operator">_++_</a> <a id="25811" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
<a id="25814" href="/PLFA-zh/Lists/#25762" class="Function">++-monoid</a> <a id="25824" class="Symbol">=</a>
  <a id="25828" class="Keyword">record</a>
    <a id="25839" class="Symbol">{</a> <a id="25841" class="Field">assoc</a> <a id="25847" class="Symbol">=</a> <a id="25849" href="/PLFA-zh/Lists/#6180" class="Function">++-assoc</a>
    <a id="25862" class="Symbol">;</a> <a id="25864" class="Field">identityˡ</a> <a id="25874" class="Symbol">=</a> <a id="25876" href="/PLFA-zh/Lists/#7741" class="Function">++-identityˡ</a>
    <a id="25893" class="Symbol">;</a> <a id="25895" class="Field">identityʳ</a> <a id="25905" class="Symbol">=</a> <a id="25907" href="/PLFA-zh/Lists/#7970" class="Function">++-identityʳ</a>
    <a id="25924" class="Symbol">}</a></pre>

<!-- If `_⊗_` and `e` form a monoid, then we can re-express fold on the
same operator and an arbitrary value: -->

<p>如果 <code class="highlighter-rouge">_⊗_</code> 和 <code class="highlighter-rouge">e</code> 构成一个幺半群，那么我们可以用相同的运算符和一个任意的值来表示折叠：</p>
<pre class="Agda"><a id="foldr-monoid"></a><a id="26125" href="/PLFA-zh/Lists/#26125" class="Function">foldr-monoid</a> <a id="26138" class="Symbol">:</a> <a id="26140" class="Symbol">∀</a> <a id="26142" class="Symbol">{</a><a id="26143" href="/PLFA-zh/Lists/#26143" class="Bound">A</a> <a id="26145" class="Symbol">:</a> <a id="26147" class="PrimitiveType">Set</a><a id="26150" class="Symbol">}</a> <a id="26152" class="Symbol">(</a><a id="26153" href="/PLFA-zh/Lists/#26153" class="Bound Operator">_⊗_</a> <a id="26157" class="Symbol">:</a> <a id="26159" href="/PLFA-zh/Lists/#26143" class="Bound">A</a> <a id="26161" class="Symbol">→</a> <a id="26163" href="/PLFA-zh/Lists/#26143" class="Bound">A</a> <a id="26165" class="Symbol">→</a> <a id="26167" href="/PLFA-zh/Lists/#26143" class="Bound">A</a><a id="26168" class="Symbol">)</a> <a id="26170" class="Symbol">(</a><a id="26171" href="/PLFA-zh/Lists/#26171" class="Bound">e</a> <a id="26173" class="Symbol">:</a> <a id="26175" href="/PLFA-zh/Lists/#26143" class="Bound">A</a><a id="26176" class="Symbol">)</a> <a id="26178" class="Symbol">→</a> <a id="26180" href="/PLFA-zh/Lists/#25099" class="Record">IsMonoid</a> <a id="26189" href="/PLFA-zh/Lists/#26153" class="Bound Operator">_⊗_</a> <a id="26193" href="/PLFA-zh/Lists/#26171" class="Bound">e</a> <a id="26195" class="Symbol">→</a>
  <a id="26199" class="Symbol">∀</a> <a id="26201" class="Symbol">(</a><a id="26202" href="/PLFA-zh/Lists/#26202" class="Bound">xs</a> <a id="26205" class="Symbol">:</a> <a id="26207" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="26212" href="/PLFA-zh/Lists/#26143" class="Bound">A</a><a id="26213" class="Symbol">)</a> <a id="26215" class="Symbol">(</a><a id="26216" href="/PLFA-zh/Lists/#26216" class="Bound">y</a> <a id="26218" class="Symbol">:</a> <a id="26220" href="/PLFA-zh/Lists/#26143" class="Bound">A</a><a id="26221" class="Symbol">)</a> <a id="26223" class="Symbol">→</a> <a id="26225" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="26231" href="/PLFA-zh/Lists/#26153" class="Bound Operator">_⊗_</a> <a id="26235" href="/PLFA-zh/Lists/#26216" class="Bound">y</a> <a id="26237" href="/PLFA-zh/Lists/#26202" class="Bound">xs</a> <a id="26240" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="26242" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="26248" href="/PLFA-zh/Lists/#26153" class="Bound Operator">_⊗_</a> <a id="26252" href="/PLFA-zh/Lists/#26171" class="Bound">e</a> <a id="26254" href="/PLFA-zh/Lists/#26202" class="Bound">xs</a> <a id="26257" href="/PLFA-zh/Lists/#26153" class="Bound Operator">⊗</a> <a id="26259" href="/PLFA-zh/Lists/#26216" class="Bound">y</a>
<a id="26261" href="/PLFA-zh/Lists/#26125" class="Function">foldr-monoid</a> <a id="26274" href="/PLFA-zh/Lists/#26274" class="Bound Operator">_⊗_</a> <a id="26278" href="/PLFA-zh/Lists/#26278" class="Bound">e</a> <a id="26280" href="/PLFA-zh/Lists/#26280" class="Bound">⊗-monoid</a> <a id="26289" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="26292" href="/PLFA-zh/Lists/#26292" class="Bound">y</a> <a id="26294" class="Symbol">=</a>
  <a id="26298" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="26308" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="26314" href="/PLFA-zh/Lists/#26274" class="Bound Operator">_⊗_</a> <a id="26318" href="/PLFA-zh/Lists/#26292" class="Bound">y</a> <a id="26320" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="26325" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="26333" href="/PLFA-zh/Lists/#26292" class="Bound">y</a>
  <a id="26337" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="26340" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.Core.html#838" class="Function">sym</a> <a id="26344" class="Symbol">(</a><a id="26345" href="/PLFA-zh/Lists/#25222" class="Field">identityˡ</a> <a id="26355" href="/PLFA-zh/Lists/#26280" class="Bound">⊗-monoid</a> <a id="26364" href="/PLFA-zh/Lists/#26292" class="Bound">y</a><a id="26365" class="Symbol">)</a> <a id="26367" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="26373" class="Symbol">(</a><a id="26374" href="/PLFA-zh/Lists/#26278" class="Bound">e</a> <a id="26376" href="/PLFA-zh/Lists/#26274" class="Bound Operator">⊗</a> <a id="26378" href="/PLFA-zh/Lists/#26292" class="Bound">y</a><a id="26379" class="Symbol">)</a>
  <a id="26383" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="26391" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="26397" href="/PLFA-zh/Lists/#26274" class="Bound Operator">_⊗_</a> <a id="26401" href="/PLFA-zh/Lists/#26278" class="Bound">e</a> <a id="26403" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="26406" href="/PLFA-zh/Lists/#26274" class="Bound Operator">⊗</a> <a id="26408" href="/PLFA-zh/Lists/#26292" class="Bound">y</a>
  <a id="26412" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a>
<a id="26414" href="/PLFA-zh/Lists/#26125" class="Function">foldr-monoid</a> <a id="26427" href="/PLFA-zh/Lists/#26427" class="Bound Operator">_⊗_</a> <a id="26431" href="/PLFA-zh/Lists/#26431" class="Bound">e</a> <a id="26433" href="/PLFA-zh/Lists/#26433" class="Bound">⊗-monoid</a> <a id="26442" class="Symbol">(</a><a id="26443" href="/PLFA-zh/Lists/#26443" class="Bound">x</a> <a id="26445" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="26447" href="/PLFA-zh/Lists/#26447" class="Bound">xs</a><a id="26449" class="Symbol">)</a> <a id="26451" href="/PLFA-zh/Lists/#26451" class="Bound">y</a> <a id="26453" class="Symbol">=</a>
  <a id="26457" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="26467" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="26473" href="/PLFA-zh/Lists/#26427" class="Bound Operator">_⊗_</a> <a id="26477" href="/PLFA-zh/Lists/#26451" class="Bound">y</a> <a id="26479" class="Symbol">(</a><a id="26480" href="/PLFA-zh/Lists/#26443" class="Bound">x</a> <a id="26482" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="26484" href="/PLFA-zh/Lists/#26447" class="Bound">xs</a><a id="26486" class="Symbol">)</a>
  <a id="26490" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="26498" href="/PLFA-zh/Lists/#26443" class="Bound">x</a> <a id="26500" href="/PLFA-zh/Lists/#26427" class="Bound Operator">⊗</a> <a id="26502" class="Symbol">(</a><a id="26503" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="26509" href="/PLFA-zh/Lists/#26427" class="Bound Operator">_⊗_</a> <a id="26513" href="/PLFA-zh/Lists/#26451" class="Bound">y</a> <a id="26515" href="/PLFA-zh/Lists/#26447" class="Bound">xs</a><a id="26517" class="Symbol">)</a>
  <a id="26521" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="26524" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a> <a id="26529" class="Symbol">(</a><a id="26530" href="/PLFA-zh/Lists/#26443" class="Bound">x</a> <a id="26532" href="/PLFA-zh/Lists/#26427" class="Bound Operator">⊗_</a><a id="26534" class="Symbol">)</a> <a id="26536" class="Symbol">(</a><a id="26537" href="/PLFA-zh/Lists/#26125" class="Function">foldr-monoid</a> <a id="26550" href="/PLFA-zh/Lists/#26427" class="Bound Operator">_⊗_</a> <a id="26554" href="/PLFA-zh/Lists/#26431" class="Bound">e</a> <a id="26556" href="/PLFA-zh/Lists/#26433" class="Bound">⊗-monoid</a> <a id="26565" href="/PLFA-zh/Lists/#26447" class="Bound">xs</a> <a id="26568" href="/PLFA-zh/Lists/#26451" class="Bound">y</a><a id="26569" class="Symbol">)</a> <a id="26571" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="26577" href="/PLFA-zh/Lists/#26443" class="Bound">x</a> <a id="26579" href="/PLFA-zh/Lists/#26427" class="Bound Operator">⊗</a> <a id="26581" class="Symbol">(</a><a id="26582" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="26588" href="/PLFA-zh/Lists/#26427" class="Bound Operator">_⊗_</a> <a id="26592" href="/PLFA-zh/Lists/#26431" class="Bound">e</a> <a id="26594" href="/PLFA-zh/Lists/#26447" class="Bound">xs</a> <a id="26597" href="/PLFA-zh/Lists/#26427" class="Bound Operator">⊗</a> <a id="26599" href="/PLFA-zh/Lists/#26451" class="Bound">y</a><a id="26600" class="Symbol">)</a>
  <a id="26604" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="26607" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.Core.html#838" class="Function">sym</a> <a id="26611" class="Symbol">(</a><a id="26612" href="/PLFA-zh/Lists/#25168" class="Field">assoc</a> <a id="26618" href="/PLFA-zh/Lists/#26433" class="Bound">⊗-monoid</a> <a id="26627" href="/PLFA-zh/Lists/#26443" class="Bound">x</a> <a id="26629" class="Symbol">(</a><a id="26630" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="26636" href="/PLFA-zh/Lists/#26427" class="Bound Operator">_⊗_</a> <a id="26640" href="/PLFA-zh/Lists/#26431" class="Bound">e</a> <a id="26642" href="/PLFA-zh/Lists/#26447" class="Bound">xs</a><a id="26644" class="Symbol">)</a> <a id="26646" href="/PLFA-zh/Lists/#26451" class="Bound">y</a><a id="26647" class="Symbol">)</a> <a id="26649" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="26655" class="Symbol">(</a><a id="26656" href="/PLFA-zh/Lists/#26443" class="Bound">x</a> <a id="26658" href="/PLFA-zh/Lists/#26427" class="Bound Operator">⊗</a> <a id="26660" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="26666" href="/PLFA-zh/Lists/#26427" class="Bound Operator">_⊗_</a> <a id="26670" href="/PLFA-zh/Lists/#26431" class="Bound">e</a> <a id="26672" href="/PLFA-zh/Lists/#26447" class="Bound">xs</a><a id="26674" class="Symbol">)</a> <a id="26676" href="/PLFA-zh/Lists/#26427" class="Bound Operator">⊗</a> <a id="26678" href="/PLFA-zh/Lists/#26451" class="Bound">y</a>
  <a id="26682" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="26690" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="26696" href="/PLFA-zh/Lists/#26427" class="Bound Operator">_⊗_</a> <a id="26700" href="/PLFA-zh/Lists/#26431" class="Bound">e</a> <a id="26702" class="Symbol">(</a><a id="26703" href="/PLFA-zh/Lists/#26443" class="Bound">x</a> <a id="26705" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="26707" href="/PLFA-zh/Lists/#26447" class="Bound">xs</a><a id="26709" class="Symbol">)</a> <a id="26711" href="/PLFA-zh/Lists/#26427" class="Bound Operator">⊗</a> <a id="26713" href="/PLFA-zh/Lists/#26451" class="Bound">y</a>
  <a id="26717" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>

<!-- As a consequence, using a previous exercise, we have the following: -->

<p>使用之前练习中的一个结论，我们可以得到如下：</p>
<pre class="Agda"><a id="foldr-monoid-++"></a><a id="26853" href="/PLFA-zh/Lists/#26853" class="Function">foldr-monoid-++</a> <a id="26869" class="Symbol">:</a> <a id="26871" class="Symbol">∀</a> <a id="26873" class="Symbol">{</a><a id="26874" href="/PLFA-zh/Lists/#26874" class="Bound">A</a> <a id="26876" class="Symbol">:</a> <a id="26878" class="PrimitiveType">Set</a><a id="26881" class="Symbol">}</a> <a id="26883" class="Symbol">(</a><a id="26884" href="/PLFA-zh/Lists/#26884" class="Bound Operator">_⊗_</a> <a id="26888" class="Symbol">:</a> <a id="26890" href="/PLFA-zh/Lists/#26874" class="Bound">A</a> <a id="26892" class="Symbol">→</a> <a id="26894" href="/PLFA-zh/Lists/#26874" class="Bound">A</a> <a id="26896" class="Symbol">→</a> <a id="26898" href="/PLFA-zh/Lists/#26874" class="Bound">A</a><a id="26899" class="Symbol">)</a> <a id="26901" class="Symbol">(</a><a id="26902" href="/PLFA-zh/Lists/#26902" class="Bound">e</a> <a id="26904" class="Symbol">:</a> <a id="26906" href="/PLFA-zh/Lists/#26874" class="Bound">A</a><a id="26907" class="Symbol">)</a> <a id="26909" class="Symbol">→</a> <a id="26911" href="/PLFA-zh/Lists/#25099" class="Record">IsMonoid</a> <a id="26920" href="/PLFA-zh/Lists/#26884" class="Bound Operator">_⊗_</a> <a id="26924" href="/PLFA-zh/Lists/#26902" class="Bound">e</a> <a id="26926" class="Symbol">→</a>
  <a id="26930" class="Symbol">∀</a> <a id="26932" class="Symbol">(</a><a id="26933" href="/PLFA-zh/Lists/#26933" class="Bound">xs</a> <a id="26936" href="/PLFA-zh/Lists/#26936" class="Bound">ys</a> <a id="26939" class="Symbol">:</a> <a id="26941" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="26946" href="/PLFA-zh/Lists/#26874" class="Bound">A</a><a id="26947" class="Symbol">)</a> <a id="26949" class="Symbol">→</a> <a id="26951" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="26957" href="/PLFA-zh/Lists/#26884" class="Bound Operator">_⊗_</a> <a id="26961" href="/PLFA-zh/Lists/#26902" class="Bound">e</a> <a id="26963" class="Symbol">(</a><a id="26964" href="/PLFA-zh/Lists/#26933" class="Bound">xs</a> <a id="26967" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="26970" href="/PLFA-zh/Lists/#26936" class="Bound">ys</a><a id="26972" class="Symbol">)</a> <a id="26974" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="26976" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="26982" href="/PLFA-zh/Lists/#26884" class="Bound Operator">_⊗_</a> <a id="26986" href="/PLFA-zh/Lists/#26902" class="Bound">e</a> <a id="26988" href="/PLFA-zh/Lists/#26933" class="Bound">xs</a> <a id="26991" href="/PLFA-zh/Lists/#26884" class="Bound Operator">⊗</a> <a id="26993" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="26999" href="/PLFA-zh/Lists/#26884" class="Bound Operator">_⊗_</a> <a id="27003" href="/PLFA-zh/Lists/#26902" class="Bound">e</a> <a id="27005" href="/PLFA-zh/Lists/#26936" class="Bound">ys</a>
<a id="27008" href="/PLFA-zh/Lists/#26853" class="Function">foldr-monoid-++</a> <a id="27024" href="/PLFA-zh/Lists/#27024" class="Bound Operator">_⊗_</a> <a id="27028" href="/PLFA-zh/Lists/#27028" class="Bound">e</a> <a id="27030" href="/PLFA-zh/Lists/#27030" class="Bound">monoid-⊗</a> <a id="27039" href="/PLFA-zh/Lists/#27039" class="Bound">xs</a> <a id="27042" href="/PLFA-zh/Lists/#27042" class="Bound">ys</a> <a id="27045" class="Symbol">=</a>
  <a id="27049" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="27059" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="27065" href="/PLFA-zh/Lists/#27024" class="Bound Operator">_⊗_</a> <a id="27069" href="/PLFA-zh/Lists/#27028" class="Bound">e</a> <a id="27071" class="Symbol">(</a><a id="27072" href="/PLFA-zh/Lists/#27039" class="Bound">xs</a> <a id="27075" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="27078" href="/PLFA-zh/Lists/#27042" class="Bound">ys</a><a id="27080" class="Symbol">)</a>
  <a id="27084" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="27087" href="/PLFA-zh/Lists/#22908" class="Postulate">foldr-++</a> <a id="27096" href="/PLFA-zh/Lists/#27024" class="Bound Operator">_⊗_</a> <a id="27100" href="/PLFA-zh/Lists/#27028" class="Bound">e</a> <a id="27102" href="/PLFA-zh/Lists/#27039" class="Bound">xs</a> <a id="27105" href="/PLFA-zh/Lists/#27042" class="Bound">ys</a> <a id="27108" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="27114" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="27120" href="/PLFA-zh/Lists/#27024" class="Bound Operator">_⊗_</a> <a id="27124" class="Symbol">(</a><a id="27125" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="27131" href="/PLFA-zh/Lists/#27024" class="Bound Operator">_⊗_</a> <a id="27135" href="/PLFA-zh/Lists/#27028" class="Bound">e</a> <a id="27137" href="/PLFA-zh/Lists/#27042" class="Bound">ys</a><a id="27139" class="Symbol">)</a> <a id="27141" href="/PLFA-zh/Lists/#27039" class="Bound">xs</a>
  <a id="27146" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="27149" href="/PLFA-zh/Lists/#26125" class="Function">foldr-monoid</a> <a id="27162" href="/PLFA-zh/Lists/#27024" class="Bound Operator">_⊗_</a> <a id="27166" href="/PLFA-zh/Lists/#27028" class="Bound">e</a> <a id="27168" href="/PLFA-zh/Lists/#27030" class="Bound">monoid-⊗</a> <a id="27177" href="/PLFA-zh/Lists/#27039" class="Bound">xs</a> <a id="27180" class="Symbol">(</a><a id="27181" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="27187" href="/PLFA-zh/Lists/#27024" class="Bound Operator">_⊗_</a> <a id="27191" href="/PLFA-zh/Lists/#27028" class="Bound">e</a> <a id="27193" href="/PLFA-zh/Lists/#27042" class="Bound">ys</a><a id="27195" class="Symbol">)</a> <a id="27197" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="27203" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="27209" href="/PLFA-zh/Lists/#27024" class="Bound Operator">_⊗_</a> <a id="27213" href="/PLFA-zh/Lists/#27028" class="Bound">e</a> <a id="27215" href="/PLFA-zh/Lists/#27039" class="Bound">xs</a> <a id="27218" href="/PLFA-zh/Lists/#27024" class="Bound Operator">⊗</a> <a id="27220" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="27226" href="/PLFA-zh/Lists/#27024" class="Bound Operator">_⊗_</a> <a id="27230" href="/PLFA-zh/Lists/#27028" class="Bound">e</a> <a id="27232" href="/PLFA-zh/Lists/#27042" class="Bound">ys</a>
  <a id="27237" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>

<!-- #### Exercise `foldl` -->

<h4 id="练习-foldl">练习 <code class="highlighter-rouge">foldl</code></h4>

<!-- Define a function `foldl` which is analogous to `foldr`, but where
operations associate to the left rather than the right.  For example: -->

<p>定义一个函数 <code class="highlighter-rouge">foldl</code>，与 <code class="highlighter-rouge">foldr</code> 相似，但是运算符向左结合，而不是向右。例如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foldr _⊗_ e [ x , y , z ]  =  x ⊗ (y ⊗ (z ⊗ e))
foldl _⊗_ e [ x , y , z ]  =  ((e ⊗ x) ⊗ y) ⊗ z
</code></pre></div></div>

<!-- <pre class="Agda"><a id="27642" class="Comment">-- Your code goes here</a></pre> -->

<pre class="Agda"><a id="27695" class="Comment">-- 请将代码写在此处。</a></pre>

<!-- #### Exercise `foldr-monoid-foldl` -->

<h4 id="练习-foldr-monoid-foldl">练习 <code class="highlighter-rouge">foldr-monoid-foldl</code></h4>

<!-- Show that if `_⊗_` and `e` form a monoid, then `foldr _⊗_ e` and
`foldl _⊗_ e` always compute the same result. -->

<p>证明如果 <code class="highlighter-rouge">_⊗_</code> 和 <code class="highlighter-rouge">e</code> 构成幺半群，那么 <code class="highlighter-rouge">foldr _⊗_ e</code> 和 <code class="highlighter-rouge">foldl _⊗_ e</code> 的结果永远是相同的。</p>

<!-- <pre class="Agda"><a id="28027" class="Comment">-- Your code goes here</a></pre> -->

<pre class="Agda"><a id="28080" class="Comment">-- 请将代码写在此处。</a></pre>

<!-- ## All {#All} -->

<h2 id="All">所有</h2>

<!-- We can also define predicates over lists. Two of the most important
are `All` and `Any`. -->

<p>我们也可以定义关于列表的谓词。最重要的两个谓词是 <code class="highlighter-rouge">All</code> 和 <code class="highlighter-rouge">Any</code>。</p>

<!-- Predicate `All P` holds if predicate `P` is satisfied by every element of a list: -->

<p>谓词 <code class="highlighter-rouge">All P</code> 当列表里的所有元素满足 <code class="highlighter-rouge">P</code> 时成立：</p>
<pre class="Agda"><a id="28445" class="Keyword">data</a> <a id="All"></a><a id="28450" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="28454" class="Symbol">{</a><a id="28455" href="/PLFA-zh/Lists/#28455" class="Bound">A</a> <a id="28457" class="Symbol">:</a> <a id="28459" class="PrimitiveType">Set</a><a id="28462" class="Symbol">}</a> <a id="28464" class="Symbol">(</a><a id="28465" href="/PLFA-zh/Lists/#28465" class="Bound">P</a> <a id="28467" class="Symbol">:</a> <a id="28469" href="/PLFA-zh/Lists/#28455" class="Bound">A</a> <a id="28471" class="Symbol">→</a> <a id="28473" class="PrimitiveType">Set</a><a id="28476" class="Symbol">)</a> <a id="28478" class="Symbol">:</a> <a id="28480" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="28485" href="/PLFA-zh/Lists/#28455" class="Bound">A</a> <a id="28487" class="Symbol">→</a> <a id="28489" class="PrimitiveType">Set</a> <a id="28493" class="Keyword">where</a>
  <a id="All.[]"></a><a id="28501" href="/PLFA-zh/Lists/#28501" class="InductiveConstructor">[]</a>  <a id="28505" class="Symbol">:</a> <a id="28507" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="28511" href="/PLFA-zh/Lists/#28465" class="Bound">P</a> <a id="28513" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>
  <a id="All._∷_"></a><a id="28518" href="/PLFA-zh/Lists/#28518" class="InductiveConstructor Operator">_∷_</a> <a id="28522" class="Symbol">:</a> <a id="28524" class="Symbol">∀</a> <a id="28526" class="Symbol">{</a><a id="28527" href="/PLFA-zh/Lists/#28527" class="Bound">x</a> <a id="28529" class="Symbol">:</a> <a id="28531" href="/PLFA-zh/Lists/#28455" class="Bound">A</a><a id="28532" class="Symbol">}</a> <a id="28534" class="Symbol">{</a><a id="28535" href="/PLFA-zh/Lists/#28535" class="Bound">xs</a> <a id="28538" class="Symbol">:</a> <a id="28540" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="28545" href="/PLFA-zh/Lists/#28455" class="Bound">A</a><a id="28546" class="Symbol">}</a> <a id="28548" class="Symbol">→</a> <a id="28550" href="/PLFA-zh/Lists/#28465" class="Bound">P</a> <a id="28552" href="/PLFA-zh/Lists/#28527" class="Bound">x</a> <a id="28554" class="Symbol">→</a> <a id="28556" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="28560" href="/PLFA-zh/Lists/#28465" class="Bound">P</a> <a id="28562" href="/PLFA-zh/Lists/#28535" class="Bound">xs</a> <a id="28565" class="Symbol">→</a> <a id="28567" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="28571" href="/PLFA-zh/Lists/#28465" class="Bound">P</a> <a id="28573" class="Symbol">(</a><a id="28574" href="/PLFA-zh/Lists/#28527" class="Bound">x</a> <a id="28576" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="28578" href="/PLFA-zh/Lists/#28535" class="Bound">xs</a><a id="28580" class="Symbol">)</a></pre>
<!-- The type has two constructors, reusing the names of the same constructors for lists.
The first asserts that `P` holds for every element of the empty list.
The second asserts that if `P` holds of the head of a list and for every
element of the tail of a list, then `P` holds for every element of the list.
Agda uses types to disambiguate whether the constructor is building
a list or evidence that `All P` holds. -->

<p>这个类型有两个构造器，使用了与列表构造器相同的名称。第一个断言了 <code class="highlighter-rouge">P</code> 对于空列表的任何元素成立。第二个断言了如果 <code class="highlighter-rouge">P</code> 对于列表的头元素和尾列表的所有元素成立，那么 <code class="highlighter-rouge">P</code> 对于这个列表的任何元素成立。
Agda 使用类型来区分构造器是用于构造一个列表，还是构造 <code class="highlighter-rouge">All P</code> 成立的证明。</p>

<!-- For example, `All (_≤ 2)` holds of a list where every element is less
than or equal to two.  Recall that `z≤n` proves `zero ≤ n` for any
`n`, and that if `m≤n` proves `m ≤ n` then `s≤s m≤n` proves `suc m ≤
suc n`, for any `m` and `n`: -->

<p>比如说，<code class="highlighter-rouge">All (_≤ 2)</code> 对于一个每一个元素都小于等于二的列表成立。回忆 <code class="highlighter-rouge">z≤n</code> 证明了对于任意 <code class="highlighter-rouge">n</code>， <code class="highlighter-rouge">zero ≤ n</code> 成立；对于任意 <code class="highlighter-rouge">m</code> 和 <code class="highlighter-rouge">n</code>，如果 <code class="highlighter-rouge">m≤n</code> 证明了 <code class="highlighter-rouge">m ≤ n</code>，那么 <code class="highlighter-rouge">s≤s m≤n</code> 证明了 <code class="highlighter-rouge">suc m ≤
suc n</code>:</p>
<pre class="Agda"><a id="29587" href="/PLFA-zh/Lists/#29587" class="Function">_</a> <a id="29589" class="Symbol">:</a> <a id="29591" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="29595" class="Symbol">(</a><a id="29596" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Base.html#845" class="Datatype Operator">_≤</a> <a id="29599" class="Number">2</a><a id="29600" class="Symbol">)</a> <a id="29602" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">[</a> <a id="29604" class="Number">0</a> <a id="29606" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="29608" class="Number">1</a> <a id="29610" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">,</a> <a id="29612" class="Number">2</a> <a id="29614" href="/PLFA-zh/Lists/#3975" class="InductiveConstructor Operator">]</a>
<a id="29616" class="Symbol">_</a> <a id="29618" class="Symbol">=</a> <a id="29620" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Base.html#868" class="InductiveConstructor">z≤n</a> <a id="29624" href="/PLFA-zh/Lists/#28518" class="InductiveConstructor Operator">∷</a> <a id="29626" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Base.html#910" class="InductiveConstructor">s≤s</a> <a id="29630" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Base.html#868" class="InductiveConstructor">z≤n</a> <a id="29634" href="/PLFA-zh/Lists/#28518" class="InductiveConstructor Operator">∷</a> <a id="29636" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Base.html#910" class="InductiveConstructor">s≤s</a> <a id="29640" class="Symbol">(</a><a id="29641" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Base.html#910" class="InductiveConstructor">s≤s</a> <a id="29645" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.Base.html#868" class="InductiveConstructor">z≤n</a><a id="29648" class="Symbol">)</a> <a id="29650" href="/PLFA-zh/Lists/#28518" class="InductiveConstructor Operator">∷</a> <a id="29652" href="/PLFA-zh/Lists/#28501" class="InductiveConstructor">[]</a></pre>
<!-- Here `_∷_` and `[]` are the constructors of `All P` rather than of `List A`.
The three items are proofs of `0 ≤ 2`, `1 ≤ 2`, and `2 ≤ 2`, respectively. -->

<p>这里 <code class="highlighter-rouge">_∷_</code> 和 <code class="highlighter-rouge">[]</code> 是 <code class="highlighter-rouge">All P</code> 的构造器，而不是 <code class="highlighter-rouge">List A</code> 的。这三项分别是 <code class="highlighter-rouge">0 ≤ 2</code>、 <code class="highlighter-rouge">1 ≤ 2</code> 和 <code class="highlighter-rouge">2 ≤ 2</code> 的证明。</p>

<!-- (One might wonder whether a pattern such as `[_,_,_]` can be used to
construct values of type `All` as well as type `List`, since both use
the same constructors. Indeed it can, so long as both types are in
scope when the pattern is declared.  That's not the case here, since
`List` is defined before `[_,_,_]`, but `All` is defined later.) -->

<p>（读者可能会思考诸如 <code class="highlighter-rouge">[_,_,_]</code> 的模式是否可以用于构造 <code class="highlighter-rouge">All</code> 类型的值，像构造 <code class="highlighter-rouge">List</code> 类型的一样，因为两者使用了相同的构造器。事实上这样做是可以的，只要两个类型在模式声明时在作用域内。然而现在不是这样的情况，因为 <code class="highlighter-rouge">List</code> 先于 <code class="highlighter-rouge">[_,_,_]</code> 定义，而 <code class="highlighter-rouge">All</code> 在之后定义。）</p>

<!-- ## Any -->

<h2 id="任意">任意</h2>

<!-- Predicate `Any P` holds if predicate `P` is satisfied by some element of a list: -->

<p>谓词 <code class="highlighter-rouge">Any P</code> 当列表里的一些元素满足 <code class="highlighter-rouge">P</code> 时成立：</p>
<pre class="Agda"><a id="30619" class="Keyword">data</a> <a id="Any"></a><a id="30624" href="/PLFA-zh/Lists/#30624" class="Datatype">Any</a> <a id="30628" class="Symbol">{</a><a id="30629" href="/PLFA-zh/Lists/#30629" class="Bound">A</a> <a id="30631" class="Symbol">:</a> <a id="30633" class="PrimitiveType">Set</a><a id="30636" class="Symbol">}</a> <a id="30638" class="Symbol">(</a><a id="30639" href="/PLFA-zh/Lists/#30639" class="Bound">P</a> <a id="30641" class="Symbol">:</a> <a id="30643" href="/PLFA-zh/Lists/#30629" class="Bound">A</a> <a id="30645" class="Symbol">→</a> <a id="30647" class="PrimitiveType">Set</a><a id="30650" class="Symbol">)</a> <a id="30652" class="Symbol">:</a> <a id="30654" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="30659" href="/PLFA-zh/Lists/#30629" class="Bound">A</a> <a id="30661" class="Symbol">→</a> <a id="30663" class="PrimitiveType">Set</a> <a id="30667" class="Keyword">where</a>
  <a id="Any.here"></a><a id="30675" href="/PLFA-zh/Lists/#30675" class="InductiveConstructor">here</a>  <a id="30681" class="Symbol">:</a> <a id="30683" class="Symbol">∀</a> <a id="30685" class="Symbol">{</a><a id="30686" href="/PLFA-zh/Lists/#30686" class="Bound">x</a> <a id="30688" class="Symbol">:</a> <a id="30690" href="/PLFA-zh/Lists/#30629" class="Bound">A</a><a id="30691" class="Symbol">}</a> <a id="30693" class="Symbol">{</a><a id="30694" href="/PLFA-zh/Lists/#30694" class="Bound">xs</a> <a id="30697" class="Symbol">:</a> <a id="30699" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="30704" href="/PLFA-zh/Lists/#30629" class="Bound">A</a><a id="30705" class="Symbol">}</a> <a id="30707" class="Symbol">→</a> <a id="30709" href="/PLFA-zh/Lists/#30639" class="Bound">P</a> <a id="30711" href="/PLFA-zh/Lists/#30686" class="Bound">x</a> <a id="30713" class="Symbol">→</a> <a id="30715" href="/PLFA-zh/Lists/#30624" class="Datatype">Any</a> <a id="30719" href="/PLFA-zh/Lists/#30639" class="Bound">P</a> <a id="30721" class="Symbol">(</a><a id="30722" href="/PLFA-zh/Lists/#30686" class="Bound">x</a> <a id="30724" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="30726" href="/PLFA-zh/Lists/#30694" class="Bound">xs</a><a id="30728" class="Symbol">)</a>
  <a id="Any.there"></a><a id="30732" href="/PLFA-zh/Lists/#30732" class="InductiveConstructor">there</a> <a id="30738" class="Symbol">:</a> <a id="30740" class="Symbol">∀</a> <a id="30742" class="Symbol">{</a><a id="30743" href="/PLFA-zh/Lists/#30743" class="Bound">x</a> <a id="30745" class="Symbol">:</a> <a id="30747" href="/PLFA-zh/Lists/#30629" class="Bound">A</a><a id="30748" class="Symbol">}</a> <a id="30750" class="Symbol">{</a><a id="30751" href="/PLFA-zh/Lists/#30751" class="Bound">xs</a> <a id="30754" class="Symbol">:</a> <a id="30756" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="30761" href="/PLFA-zh/Lists/#30629" class="Bound">A</a><a id="30762" class="Symbol">}</a> <a id="30764" class="Symbol">→</a> <a id="30766" href="/PLFA-zh/Lists/#30624" class="Datatype">Any</a> <a id="30770" href="/PLFA-zh/Lists/#30639" class="Bound">P</a> <a id="30772" href="/PLFA-zh/Lists/#30751" class="Bound">xs</a> <a id="30775" class="Symbol">→</a> <a id="30777" href="/PLFA-zh/Lists/#30624" class="Datatype">Any</a> <a id="30781" href="/PLFA-zh/Lists/#30639" class="Bound">P</a> <a id="30783" class="Symbol">(</a><a id="30784" href="/PLFA-zh/Lists/#30743" class="Bound">x</a> <a id="30786" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="30788" href="/PLFA-zh/Lists/#30751" class="Bound">xs</a><a id="30790" class="Symbol">)</a></pre>
<!-- The first constructor provides evidence that the head of the list
satisfies `P`, while the second provides evidence that some element of
the tail of the list satisfies `P`.  For example, we can define list
membership as follows: -->

<p>第一个构造器证明了列表的头元素满足 <code class="highlighter-rouge">P</code>，第二个构造器证明的列表的尾列表中的一些元素满足 <code class="highlighter-rouge">P</code>。举例来说，我们可以如下定义列表的成员关系：</p>
<pre class="Agda"><a id="31136" class="Keyword">infix</a> <a id="31142" class="Number">4</a> <a id="31144" href="/PLFA-zh/Lists/#31153" class="Function Operator">_∈_</a> <a id="31148" href="/PLFA-zh/Lists/#31223" class="Function Operator">_∉_</a>

<a id="_∈_"></a><a id="31153" href="/PLFA-zh/Lists/#31153" class="Function Operator">_∈_</a> <a id="31157" class="Symbol">:</a> <a id="31159" class="Symbol">∀</a> <a id="31161" class="Symbol">{</a><a id="31162" href="/PLFA-zh/Lists/#31162" class="Bound">A</a> <a id="31164" class="Symbol">:</a> <a id="31166" class="PrimitiveType">Set</a><a id="31169" class="Symbol">}</a> <a id="31171" class="Symbol">(</a><a id="31172" href="/PLFA-zh/Lists/#31172" class="Bound">x</a> <a id="31174" class="Symbol">:</a> <a id="31176" href="/PLFA-zh/Lists/#31162" class="Bound">A</a><a id="31177" class="Symbol">)</a> <a id="31179" class="Symbol">(</a><a id="31180" href="/PLFA-zh/Lists/#31180" class="Bound">xs</a> <a id="31183" class="Symbol">:</a> <a id="31185" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="31190" href="/PLFA-zh/Lists/#31162" class="Bound">A</a><a id="31191" class="Symbol">)</a> <a id="31193" class="Symbol">→</a> <a id="31195" class="PrimitiveType">Set</a>
<a id="31199" href="/PLFA-zh/Lists/#31199" class="Bound">x</a> <a id="31201" href="/PLFA-zh/Lists/#31153" class="Function Operator">∈</a> <a id="31203" href="/PLFA-zh/Lists/#31203" class="Bound">xs</a> <a id="31206" class="Symbol">=</a> <a id="31208" href="/PLFA-zh/Lists/#30624" class="Datatype">Any</a> <a id="31212" class="Symbol">(</a><a id="31213" href="/PLFA-zh/Lists/#31199" class="Bound">x</a> <a id="31215" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡_</a><a id="31217" class="Symbol">)</a> <a id="31219" href="/PLFA-zh/Lists/#31203" class="Bound">xs</a>

<a id="_∉_"></a><a id="31223" href="/PLFA-zh/Lists/#31223" class="Function Operator">_∉_</a> <a id="31227" class="Symbol">:</a> <a id="31229" class="Symbol">∀</a> <a id="31231" class="Symbol">{</a><a id="31232" href="/PLFA-zh/Lists/#31232" class="Bound">A</a> <a id="31234" class="Symbol">:</a> <a id="31236" class="PrimitiveType">Set</a><a id="31239" class="Symbol">}</a> <a id="31241" class="Symbol">(</a><a id="31242" href="/PLFA-zh/Lists/#31242" class="Bound">x</a> <a id="31244" class="Symbol">:</a> <a id="31246" href="/PLFA-zh/Lists/#31232" class="Bound">A</a><a id="31247" class="Symbol">)</a> <a id="31249" class="Symbol">(</a><a id="31250" href="/PLFA-zh/Lists/#31250" class="Bound">xs</a> <a id="31253" class="Symbol">:</a> <a id="31255" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="31260" href="/PLFA-zh/Lists/#31232" class="Bound">A</a><a id="31261" class="Symbol">)</a> <a id="31263" class="Symbol">→</a> <a id="31265" class="PrimitiveType">Set</a>
<a id="31269" href="/PLFA-zh/Lists/#31269" class="Bound">x</a> <a id="31271" href="/PLFA-zh/Lists/#31223" class="Function Operator">∉</a> <a id="31273" href="/PLFA-zh/Lists/#31273" class="Bound">xs</a> <a id="31276" class="Symbol">=</a> <a id="31278" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="31280" class="Symbol">(</a><a id="31281" href="/PLFA-zh/Lists/#31269" class="Bound">x</a> <a id="31283" href="/PLFA-zh/Lists/#31153" class="Function Operator">∈</a> <a id="31285" href="/PLFA-zh/Lists/#31273" class="Bound">xs</a><a id="31287" class="Symbol">)</a></pre>
<!-- For example, zero is an element of the list `[ 0 , 1 , 0 , 2 ]`.  Indeed, we can demonstrate
this fact in two different ways, corresponding to the two different
occurrences of zero in the list, as the first element and as the third element: -->

<p>比如说，零是列表 <code class="highlighter-rouge">[ 0 , 1 , 0 , 2 ]</code> 中的一个元素。我们可以用两种方法来展示这个事实，对应零在列表中出现了两次：第一个元素和第三个元素：</p>

<pre class="Agda"><a id="31653" href="/PLFA-zh/Lists/#31653" class="Function">_</a> <a id="31655" class="Symbol">:</a> <a id="31657" class="Number">0</a> <a id="31659" href="/PLFA-zh/Lists/#31153" class="Function Operator">∈</a> <a id="31661" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">[</a> <a id="31663" class="Number">0</a> <a id="31665" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="31667" class="Number">1</a> <a id="31669" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="31671" class="Number">0</a> <a id="31673" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="31675" class="Number">2</a> <a id="31677" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">]</a>
<a id="31679" class="Symbol">_</a> <a id="31681" class="Symbol">=</a> <a id="31683" href="/PLFA-zh/Lists/#30675" class="InductiveConstructor">here</a> <a id="31688" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="31694" href="/PLFA-zh/Lists/#31694" class="Function">_</a> <a id="31696" class="Symbol">:</a> <a id="31698" class="Number">0</a> <a id="31700" href="/PLFA-zh/Lists/#31153" class="Function Operator">∈</a> <a id="31702" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">[</a> <a id="31704" class="Number">0</a> <a id="31706" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="31708" class="Number">1</a> <a id="31710" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="31712" class="Number">0</a> <a id="31714" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="31716" class="Number">2</a> <a id="31718" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">]</a>
<a id="31720" class="Symbol">_</a> <a id="31722" class="Symbol">=</a> <a id="31724" href="/PLFA-zh/Lists/#30732" class="InductiveConstructor">there</a> <a id="31730" class="Symbol">(</a><a id="31731" href="/PLFA-zh/Lists/#30732" class="InductiveConstructor">there</a> <a id="31737" class="Symbol">(</a><a id="31738" href="/PLFA-zh/Lists/#30675" class="InductiveConstructor">here</a> <a id="31743" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="31747" class="Symbol">))</a></pre>
<!-- Further, we can demonstrate that three is not in the list, because
any possible proof that it is in the list leads to contradiction: -->

<p>除此之外，我们可以展示三不在列表之中，因为任何它在列表中的证明会推导出矛盾：</p>
<pre class="Agda"><a id="not-in"></a><a id="31964" href="/PLFA-zh/Lists/#31964" class="Function">not-in</a> <a id="31971" class="Symbol">:</a> <a id="31973" class="Number">3</a> <a id="31975" href="/PLFA-zh/Lists/#31223" class="Function Operator">∉</a> <a id="31977" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">[</a> <a id="31979" class="Number">0</a> <a id="31981" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="31983" class="Number">1</a> <a id="31985" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="31987" class="Number">0</a> <a id="31989" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">,</a> <a id="31991" class="Number">2</a> <a id="31993" href="/PLFA-zh/Lists/#4014" class="InductiveConstructor Operator">]</a>
<a id="31995" href="/PLFA-zh/Lists/#31964" class="Function">not-in</a> <a id="32002" class="Symbol">(</a><a id="32003" href="/PLFA-zh/Lists/#30675" class="InductiveConstructor">here</a> <a id="32008" class="Symbol">())</a>
<a id="32012" href="/PLFA-zh/Lists/#31964" class="Function">not-in</a> <a id="32019" class="Symbol">(</a><a id="32020" href="/PLFA-zh/Lists/#30732" class="InductiveConstructor">there</a> <a id="32026" class="Symbol">(</a><a id="32027" href="/PLFA-zh/Lists/#30675" class="InductiveConstructor">here</a> <a id="32032" class="Symbol">()))</a>
<a id="32037" href="/PLFA-zh/Lists/#31964" class="Function">not-in</a> <a id="32044" class="Symbol">(</a><a id="32045" href="/PLFA-zh/Lists/#30732" class="InductiveConstructor">there</a> <a id="32051" class="Symbol">(</a><a id="32052" href="/PLFA-zh/Lists/#30732" class="InductiveConstructor">there</a> <a id="32058" class="Symbol">(</a><a id="32059" href="/PLFA-zh/Lists/#30675" class="InductiveConstructor">here</a> <a id="32064" class="Symbol">())))</a>
<a id="32070" href="/PLFA-zh/Lists/#31964" class="Function">not-in</a> <a id="32077" class="Symbol">(</a><a id="32078" href="/PLFA-zh/Lists/#30732" class="InductiveConstructor">there</a> <a id="32084" class="Symbol">(</a><a id="32085" href="/PLFA-zh/Lists/#30732" class="InductiveConstructor">there</a> <a id="32091" class="Symbol">(</a><a id="32092" href="/PLFA-zh/Lists/#30732" class="InductiveConstructor">there</a> <a id="32098" class="Symbol">(</a><a id="32099" href="/PLFA-zh/Lists/#30675" class="InductiveConstructor">here</a> <a id="32104" class="Symbol">()))))</a>
<a id="32111" href="/PLFA-zh/Lists/#31964" class="Function">not-in</a> <a id="32118" class="Symbol">(</a><a id="32119" href="/PLFA-zh/Lists/#30732" class="InductiveConstructor">there</a> <a id="32125" class="Symbol">(</a><a id="32126" href="/PLFA-zh/Lists/#30732" class="InductiveConstructor">there</a> <a id="32132" class="Symbol">(</a><a id="32133" href="/PLFA-zh/Lists/#30732" class="InductiveConstructor">there</a> <a id="32139" class="Symbol">(</a><a id="32140" href="/PLFA-zh/Lists/#30732" class="InductiveConstructor">there</a> <a id="32146" class="Symbol">()))))</a></pre>
<!-- The five occurrences of `()` attest to the fact that there is no
possible evidence for `3 ≡ 0`, `3 ≡ 1`, `3 ≡ 0`, `3 ≡ 2`, and
`3 ∈ []`, respectively. -->

<p><code class="highlighter-rouge">()</code> 出现了五次，分别表示没有 <code class="highlighter-rouge">3 ≡ 0</code>、 <code class="highlighter-rouge">3 ≡ 1</code>、 <code class="highlighter-rouge">3 ≡ 0</code>、 <code class="highlighter-rouge">3 ≡ 2</code> 和
<code class="highlighter-rouge">3 ∈ []</code> 的证明。</p>

<!-- ## All and append -->

<h2 id="所有和附加">所有和附加</h2>

<!-- A predicate holds for every element of one list appended to another if and
only if it holds for every element of both lists: -->

<p>一个谓词对两个附加在一起的列表的每个元素都成立，当且仅当这个谓词对两个列表的每个元素都成立：</p>
<pre class="Agda"><a id="All-++-⇔"></a><a id="32652" href="/PLFA-zh/Lists/#32652" class="Function">All-++-⇔</a> <a id="32661" class="Symbol">:</a> <a id="32663" class="Symbol">∀</a> <a id="32665" class="Symbol">{</a><a id="32666" href="/PLFA-zh/Lists/#32666" class="Bound">A</a> <a id="32668" class="Symbol">:</a> <a id="32670" class="PrimitiveType">Set</a><a id="32673" class="Symbol">}</a> <a id="32675" class="Symbol">{</a><a id="32676" href="/PLFA-zh/Lists/#32676" class="Bound">P</a> <a id="32678" class="Symbol">:</a> <a id="32680" href="/PLFA-zh/Lists/#32666" class="Bound">A</a> <a id="32682" class="Symbol">→</a> <a id="32684" class="PrimitiveType">Set</a><a id="32687" class="Symbol">}</a> <a id="32689" class="Symbol">(</a><a id="32690" href="/PLFA-zh/Lists/#32690" class="Bound">xs</a> <a id="32693" href="/PLFA-zh/Lists/#32693" class="Bound">ys</a> <a id="32696" class="Symbol">:</a> <a id="32698" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="32703" href="/PLFA-zh/Lists/#32666" class="Bound">A</a><a id="32704" class="Symbol">)</a> <a id="32706" class="Symbol">→</a>
  <a id="32710" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="32714" href="/PLFA-zh/Lists/#32676" class="Bound">P</a> <a id="32716" class="Symbol">(</a><a id="32717" href="/PLFA-zh/Lists/#32690" class="Bound">xs</a> <a id="32720" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="32723" href="/PLFA-zh/Lists/#32693" class="Bound">ys</a><a id="32725" class="Symbol">)</a> <a id="32727" href="/PLFA-zh/Isomorphism/#15182" class="Record Operator">⇔</a> <a id="32729" class="Symbol">(</a><a id="32730" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="32734" href="/PLFA-zh/Lists/#32676" class="Bound">P</a> <a id="32736" href="/PLFA-zh/Lists/#32690" class="Bound">xs</a> <a id="32739" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#1353" class="Function Operator">×</a> <a id="32741" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="32745" href="/PLFA-zh/Lists/#32676" class="Bound">P</a> <a id="32747" href="/PLFA-zh/Lists/#32693" class="Bound">ys</a><a id="32749" class="Symbol">)</a>
<a id="32751" href="/PLFA-zh/Lists/#32652" class="Function">All-++-⇔</a> <a id="32760" href="/PLFA-zh/Lists/#32760" class="Bound">xs</a> <a id="32763" href="/PLFA-zh/Lists/#32763" class="Bound">ys</a> <a id="32766" class="Symbol">=</a>
  <a id="32770" class="Keyword">record</a>
    <a id="32781" class="Symbol">{</a> <a id="32783" class="Field">to</a>       <a id="32792" class="Symbol">=</a>  <a id="32795" href="/PLFA-zh/Lists/#32850" class="Function">to</a> <a id="32798" href="/PLFA-zh/Lists/#32760" class="Bound">xs</a> <a id="32801" href="/PLFA-zh/Lists/#32763" class="Bound">ys</a>
    <a id="32808" class="Symbol">;</a> <a id="32810" class="Field">from</a>     <a id="32819" class="Symbol">=</a>  <a id="32822" href="/PLFA-zh/Lists/#33075" class="Function">from</a> <a id="32827" href="/PLFA-zh/Lists/#32760" class="Bound">xs</a> <a id="32830" href="/PLFA-zh/Lists/#32763" class="Bound">ys</a>
    <a id="32837" class="Symbol">}</a>
  <a id="32841" class="Keyword">where</a>

  <a id="32850" href="/PLFA-zh/Lists/#32850" class="Function">to</a> <a id="32853" class="Symbol">:</a> <a id="32855" class="Symbol">∀</a> <a id="32857" class="Symbol">{</a><a id="32858" href="/PLFA-zh/Lists/#32858" class="Bound">A</a> <a id="32860" class="Symbol">:</a> <a id="32862" class="PrimitiveType">Set</a><a id="32865" class="Symbol">}</a> <a id="32867" class="Symbol">{</a><a id="32868" href="/PLFA-zh/Lists/#32868" class="Bound">P</a> <a id="32870" class="Symbol">:</a> <a id="32872" href="/PLFA-zh/Lists/#32858" class="Bound">A</a> <a id="32874" class="Symbol">→</a> <a id="32876" class="PrimitiveType">Set</a><a id="32879" class="Symbol">}</a> <a id="32881" class="Symbol">(</a><a id="32882" href="/PLFA-zh/Lists/#32882" class="Bound">xs</a> <a id="32885" href="/PLFA-zh/Lists/#32885" class="Bound">ys</a> <a id="32888" class="Symbol">:</a> <a id="32890" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="32895" href="/PLFA-zh/Lists/#32858" class="Bound">A</a><a id="32896" class="Symbol">)</a> <a id="32898" class="Symbol">→</a>
    <a id="32904" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="32908" href="/PLFA-zh/Lists/#32868" class="Bound">P</a> <a id="32910" class="Symbol">(</a><a id="32911" href="/PLFA-zh/Lists/#32882" class="Bound">xs</a> <a id="32914" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="32917" href="/PLFA-zh/Lists/#32885" class="Bound">ys</a><a id="32919" class="Symbol">)</a> <a id="32921" class="Symbol">→</a> <a id="32923" class="Symbol">(</a><a id="32924" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="32928" href="/PLFA-zh/Lists/#32868" class="Bound">P</a> <a id="32930" href="/PLFA-zh/Lists/#32882" class="Bound">xs</a> <a id="32933" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#1353" class="Function Operator">×</a> <a id="32935" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="32939" href="/PLFA-zh/Lists/#32868" class="Bound">P</a> <a id="32941" href="/PLFA-zh/Lists/#32885" class="Bound">ys</a><a id="32943" class="Symbol">)</a>
  <a id="32947" href="/PLFA-zh/Lists/#32850" class="Function">to</a> <a id="32950" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="32953" href="/PLFA-zh/Lists/#32953" class="Bound">ys</a> <a id="32956" href="/PLFA-zh/Lists/#32956" class="Bound">Pys</a> <a id="32960" class="Symbol">=</a> <a id="32962" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="32964" href="/PLFA-zh/Lists/#28501" class="InductiveConstructor">[]</a> <a id="32967" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="32969" href="/PLFA-zh/Lists/#32956" class="Bound">Pys</a> <a id="32973" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
  <a id="32977" href="/PLFA-zh/Lists/#32850" class="Function">to</a> <a id="32980" class="Symbol">(</a><a id="32981" href="/PLFA-zh/Lists/#32981" class="Bound">x</a> <a id="32983" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="32985" href="/PLFA-zh/Lists/#32985" class="Bound">xs</a><a id="32987" class="Symbol">)</a> <a id="32989" href="/PLFA-zh/Lists/#32989" class="Bound">ys</a> <a id="32992" class="Symbol">(</a><a id="32993" href="/PLFA-zh/Lists/#32993" class="Bound">Px</a> <a id="32996" href="/PLFA-zh/Lists/#28518" class="InductiveConstructor Operator">∷</a> <a id="32998" href="/PLFA-zh/Lists/#32998" class="Bound">Pxs++ys</a><a id="33005" class="Symbol">)</a> <a id="33007" class="Keyword">with</a> <a id="33012" href="/PLFA-zh/Lists/#32850" class="Function">to</a> <a id="33015" href="/PLFA-zh/Lists/#32985" class="Bound">xs</a> <a id="33018" href="/PLFA-zh/Lists/#32989" class="Bound">ys</a> <a id="33021" href="/PLFA-zh/Lists/#32998" class="Bound">Pxs++ys</a>
  <a id="33031" class="Symbol">...</a> <a id="33035" class="Symbol">|</a> <a id="33037" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="33039" href="/PLFA-zh/Lists/#33039" class="Bound">Pxs</a> <a id="33043" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="33045" href="/PLFA-zh/Lists/#33045" class="Bound">Pys</a> <a id="33049" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="33051" class="Symbol">=</a> <a id="33053" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="33055" class="Bound">Px</a> <a id="33058" href="/PLFA-zh/Lists/#28518" class="InductiveConstructor Operator">∷</a> <a id="33060" href="/PLFA-zh/Lists/#33039" class="Bound">Pxs</a> <a id="33064" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="33066" href="/PLFA-zh/Lists/#33045" class="Bound">Pys</a> <a id="33070" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>

  <a id="33075" href="/PLFA-zh/Lists/#33075" class="Function">from</a> <a id="33080" class="Symbol">:</a> <a id="33082" class="Symbol">∀</a> <a id="33084" class="Symbol">{</a> <a id="33086" href="/PLFA-zh/Lists/#33086" class="Bound">A</a> <a id="33088" class="Symbol">:</a> <a id="33090" class="PrimitiveType">Set</a><a id="33093" class="Symbol">}</a> <a id="33095" class="Symbol">{</a><a id="33096" href="/PLFA-zh/Lists/#33096" class="Bound">P</a> <a id="33098" class="Symbol">:</a> <a id="33100" href="/PLFA-zh/Lists/#33086" class="Bound">A</a> <a id="33102" class="Symbol">→</a> <a id="33104" class="PrimitiveType">Set</a><a id="33107" class="Symbol">}</a> <a id="33109" class="Symbol">(</a><a id="33110" href="/PLFA-zh/Lists/#33110" class="Bound">xs</a> <a id="33113" href="/PLFA-zh/Lists/#33113" class="Bound">ys</a> <a id="33116" class="Symbol">:</a> <a id="33118" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="33123" href="/PLFA-zh/Lists/#33086" class="Bound">A</a><a id="33124" class="Symbol">)</a> <a id="33126" class="Symbol">→</a>
    <a id="33132" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="33136" href="/PLFA-zh/Lists/#33096" class="Bound">P</a> <a id="33138" href="/PLFA-zh/Lists/#33110" class="Bound">xs</a> <a id="33141" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#1353" class="Function Operator">×</a> <a id="33143" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="33147" href="/PLFA-zh/Lists/#33096" class="Bound">P</a> <a id="33149" href="/PLFA-zh/Lists/#33113" class="Bound">ys</a> <a id="33152" class="Symbol">→</a> <a id="33154" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="33158" href="/PLFA-zh/Lists/#33096" class="Bound">P</a> <a id="33160" class="Symbol">(</a><a id="33161" href="/PLFA-zh/Lists/#33110" class="Bound">xs</a> <a id="33164" href="/PLFA-zh/Lists/#4769" class="Function Operator">++</a> <a id="33167" href="/PLFA-zh/Lists/#33113" class="Bound">ys</a><a id="33169" class="Symbol">)</a>
  <a id="33173" href="/PLFA-zh/Lists/#33075" class="Function">from</a> <a id="33178" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a> <a id="33181" href="/PLFA-zh/Lists/#33181" class="Bound">ys</a> <a id="33184" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="33186" href="/PLFA-zh/Lists/#28501" class="InductiveConstructor">[]</a> <a id="33189" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="33191" href="/PLFA-zh/Lists/#33191" class="Bound">Pys</a> <a id="33195" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="33197" class="Symbol">=</a> <a id="33199" href="/PLFA-zh/Lists/#33191" class="Bound">Pys</a>
  <a id="33205" href="/PLFA-zh/Lists/#33075" class="Function">from</a> <a id="33210" class="Symbol">(</a><a id="33211" href="/PLFA-zh/Lists/#33211" class="Bound">x</a> <a id="33213" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="33215" href="/PLFA-zh/Lists/#33215" class="Bound">xs</a><a id="33217" class="Symbol">)</a> <a id="33219" href="/PLFA-zh/Lists/#33219" class="Bound">ys</a> <a id="33222" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="33224" href="/PLFA-zh/Lists/#33224" class="Bound">Px</a> <a id="33227" href="/PLFA-zh/Lists/#28518" class="InductiveConstructor Operator">∷</a> <a id="33229" href="/PLFA-zh/Lists/#33229" class="Bound">Pxs</a> <a id="33233" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="33235" href="/PLFA-zh/Lists/#33235" class="Bound">Pys</a> <a id="33239" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="33241" class="Symbol">=</a>  <a id="33244" href="/PLFA-zh/Lists/#33224" class="Bound">Px</a> <a id="33247" href="/PLFA-zh/Lists/#28518" class="InductiveConstructor Operator">∷</a> <a id="33249" href="/PLFA-zh/Lists/#33075" class="Function">from</a> <a id="33254" href="/PLFA-zh/Lists/#33215" class="Bound">xs</a> <a id="33257" href="/PLFA-zh/Lists/#33219" class="Bound">ys</a> <a id="33260" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="33262" href="/PLFA-zh/Lists/#33229" class="Bound">Pxs</a> <a id="33266" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="33268" href="/PLFA-zh/Lists/#33235" class="Bound">Pys</a> <a id="33272" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a></pre>

<!-- #### Exercise `Any-++-⇔` (recommended) -->

<h4 id="练习-any---推荐">练习 <code class="highlighter-rouge">Any-++-⇔</code> （推荐）</h4>

<!-- Prove a result similar to `All-++-⇔`, but with `Any` in place of `All`, and a suitable
replacement for `_×_`.  As a consequence, demonstrate an equivalence relating
`_∈_` and `_++_`. -->
<p>使用 <code class="highlighter-rouge">Any</code> 代替 <code class="highlighter-rouge">All</code> 与一个合适的 <code class="highlighter-rouge">_×_</code> 的替代，证明一个类似于 <code class="highlighter-rouge">All-++-⇔</code> 的结果。作为结论，展示关联 <code class="highlighter-rouge">_∈_</code> 和 <code class="highlighter-rouge">_++_</code> 的一个等价关系。</p>

<!-- <pre class="Agda"><a id="33687" class="Comment">-- Your code goes here</a></pre> -->

<pre class="Agda"><a id="33740" class="Comment">-- 请将代码写在此处。</a></pre>

<!-- #### Exercise `All-++-≃` (stretch) -->

<h4 id="练习-all---延伸">练习 <code class="highlighter-rouge">All-++-≃</code> （延伸）</h4>

<!-- Show that the equivalence `All-++-⇔` can be extended to an isomorphism. -->

<p>证明 <code class="highlighter-rouge">All-++-⇔</code> 的等价关系可以被扩展至一个同构关系。</p>

<!-- <pre class="Agda"><a id="33992" class="Comment">-- Your code goes here</a></pre> -->

<pre class="Agda"><a id="34045" class="Comment">-- 请将代码写在此处。</a></pre>

<!-- #### Exercise `¬Any≃All¬` (stretch) -->

<h4 id="练习-anyall-拓展">练习 <code class="highlighter-rouge">¬Any≃All¬</code> （拓展）</h4>

<!-- First generalise composition to arbitrary levels, using
[universe polymorphism](/PLFA-zh/Equality/#unipoly): -->

<p>首先我们将函数组合使用<a href="/PLFA-zh/Equality/#unipoly">全体多态</a>推广到任意等级：</p>
<pre class="Agda"><a id="_∘′_"></a><a id="34334" href="/PLFA-zh/Lists/#34334" class="Function Operator">_∘′_</a> <a id="34339" class="Symbol">:</a> <a id="34341" class="Symbol">∀</a> <a id="34343" class="Symbol">{</a><a id="34344" href="/PLFA-zh/Lists/#34344" class="Bound">ℓ₁</a> <a id="34347" href="/PLFA-zh/Lists/#34347" class="Bound">ℓ₂</a> <a id="34350" href="/PLFA-zh/Lists/#34350" class="Bound">ℓ₃</a> <a id="34353" class="Symbol">:</a> <a id="34355" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Primitive.html#408" class="Postulate">Level</a><a id="34360" class="Symbol">}</a> <a id="34362" class="Symbol">{</a><a id="34363" href="/PLFA-zh/Lists/#34363" class="Bound">A</a> <a id="34365" class="Symbol">:</a> <a id="34367" class="PrimitiveType">Set</a> <a id="34371" href="/PLFA-zh/Lists/#34344" class="Bound">ℓ₁</a><a id="34373" class="Symbol">}</a> <a id="34375" class="Symbol">{</a><a id="34376" href="/PLFA-zh/Lists/#34376" class="Bound">B</a> <a id="34378" class="Symbol">:</a> <a id="34380" class="PrimitiveType">Set</a> <a id="34384" href="/PLFA-zh/Lists/#34347" class="Bound">ℓ₂</a><a id="34386" class="Symbol">}</a> <a id="34388" class="Symbol">{</a><a id="34389" href="/PLFA-zh/Lists/#34389" class="Bound">C</a> <a id="34391" class="Symbol">:</a> <a id="34393" class="PrimitiveType">Set</a> <a id="34397" href="/PLFA-zh/Lists/#34350" class="Bound">ℓ₃</a><a id="34399" class="Symbol">}</a>
  <a id="34403" class="Symbol">→</a> <a id="34405" class="Symbol">(</a><a id="34406" href="/PLFA-zh/Lists/#34376" class="Bound">B</a> <a id="34408" class="Symbol">→</a> <a id="34410" href="/PLFA-zh/Lists/#34389" class="Bound">C</a><a id="34411" class="Symbol">)</a> <a id="34413" class="Symbol">→</a> <a id="34415" class="Symbol">(</a><a id="34416" href="/PLFA-zh/Lists/#34363" class="Bound">A</a> <a id="34418" class="Symbol">→</a> <a id="34420" href="/PLFA-zh/Lists/#34376" class="Bound">B</a><a id="34421" class="Symbol">)</a> <a id="34423" class="Symbol">→</a> <a id="34425" href="/PLFA-zh/Lists/#34363" class="Bound">A</a> <a id="34427" class="Symbol">→</a> <a id="34429" href="/PLFA-zh/Lists/#34389" class="Bound">C</a>
<a id="34431" class="Symbol">(</a><a id="34432" href="/PLFA-zh/Lists/#34432" class="Bound">g</a> <a id="34434" href="/PLFA-zh/Lists/#34334" class="Function Operator">∘′</a> <a id="34437" href="/PLFA-zh/Lists/#34437" class="Bound">f</a><a id="34438" class="Symbol">)</a> <a id="34440" href="/PLFA-zh/Lists/#34440" class="Bound">x</a>  <a id="34443" class="Symbol">=</a>  <a id="34446" href="/PLFA-zh/Lists/#34432" class="Bound">g</a> <a id="34448" class="Symbol">(</a><a id="34449" href="/PLFA-zh/Lists/#34437" class="Bound">f</a> <a id="34451" href="/PLFA-zh/Lists/#34440" class="Bound">x</a><a id="34452" class="Symbol">)</a></pre>

<!-- Show that `Any` and `All` satisfy a version of De Morgan's Law: -->

<p>证明 <code class="highlighter-rouge">Any</code> 和 <code class="highlighter-rouge">All</code> 满足某个形式的德摩根定律：</p>
<pre class="Agda"><a id="34592" class="Keyword">postulate</a>
  <a id="¬Any≃All¬"></a><a id="34604" href="/PLFA-zh/Lists/#34604" class="Postulate">¬Any≃All¬</a> <a id="34614" class="Symbol">:</a> <a id="34616" class="Symbol">∀</a> <a id="34618" class="Symbol">{</a><a id="34619" href="/PLFA-zh/Lists/#34619" class="Bound">A</a> <a id="34621" class="Symbol">:</a> <a id="34623" class="PrimitiveType">Set</a><a id="34626" class="Symbol">}</a> <a id="34628" class="Symbol">(</a><a id="34629" href="/PLFA-zh/Lists/#34629" class="Bound">P</a> <a id="34631" class="Symbol">:</a> <a id="34633" href="/PLFA-zh/Lists/#34619" class="Bound">A</a> <a id="34635" class="Symbol">→</a> <a id="34637" class="PrimitiveType">Set</a><a id="34640" class="Symbol">)</a> <a id="34642" class="Symbol">(</a><a id="34643" href="/PLFA-zh/Lists/#34643" class="Bound">xs</a> <a id="34646" class="Symbol">:</a> <a id="34648" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="34653" href="/PLFA-zh/Lists/#34619" class="Bound">A</a><a id="34654" class="Symbol">)</a>
    <a id="34660" class="Symbol">→</a> <a id="34662" class="Symbol">(</a><a id="34663" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#464" class="Function Operator">¬_</a> <a id="34666" href="/PLFA-zh/Lists/#34334" class="Function Operator">∘′</a> <a id="34669" href="/PLFA-zh/Lists/#30624" class="Datatype">Any</a> <a id="34673" href="/PLFA-zh/Lists/#34629" class="Bound">P</a><a id="34674" class="Symbol">)</a> <a id="34676" href="/PLFA-zh/Lists/#34643" class="Bound">xs</a> <a id="34679" href="/PLFA-zh/Isomorphism/#5561" class="Record Operator">≃</a> <a id="34681" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="34685" class="Symbol">(</a><a id="34686" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#464" class="Function Operator">¬_</a> <a id="34689" href="/PLFA-zh/Lists/#34334" class="Function Operator">∘′</a> <a id="34692" href="/PLFA-zh/Lists/#34629" class="Bound">P</a><a id="34693" class="Symbol">)</a> <a id="34695" href="/PLFA-zh/Lists/#34643" class="Bound">xs</a></pre>

<!-- Do we also have the following? -->

<p>下列命题是否成立？</p>

<pre class="Agda"><a id="34783" class="Keyword">postulate</a>
  <a id="¬All≃Any¬"></a><a id="34795" href="/PLFA-zh/Lists/#34795" class="Postulate">¬All≃Any¬</a> <a id="34805" class="Symbol">:</a> <a id="34807" class="Symbol">∀</a> <a id="34809" class="Symbol">{</a><a id="34810" href="/PLFA-zh/Lists/#34810" class="Bound">A</a> <a id="34812" class="Symbol">:</a> <a id="34814" class="PrimitiveType">Set</a><a id="34817" class="Symbol">}</a> <a id="34819" class="Symbol">(</a><a id="34820" href="/PLFA-zh/Lists/#34820" class="Bound">P</a> <a id="34822" class="Symbol">:</a> <a id="34824" href="/PLFA-zh/Lists/#34810" class="Bound">A</a> <a id="34826" class="Symbol">→</a> <a id="34828" class="PrimitiveType">Set</a><a id="34831" class="Symbol">)</a> <a id="34833" class="Symbol">(</a><a id="34834" href="/PLFA-zh/Lists/#34834" class="Bound">xs</a> <a id="34837" class="Symbol">:</a> <a id="34839" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="34844" href="/PLFA-zh/Lists/#34810" class="Bound">A</a><a id="34845" class="Symbol">)</a>
    <a id="34851" class="Symbol">→</a> <a id="34853" class="Symbol">(</a><a id="34854" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#464" class="Function Operator">¬_</a> <a id="34857" href="/PLFA-zh/Lists/#34334" class="Function Operator">∘′</a> <a id="34860" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="34864" href="/PLFA-zh/Lists/#34820" class="Bound">P</a><a id="34865" class="Symbol">)</a> <a id="34867" href="/PLFA-zh/Lists/#34834" class="Bound">xs</a> <a id="34870" href="/PLFA-zh/Isomorphism/#5561" class="Record Operator">≃</a> <a id="34872" href="/PLFA-zh/Lists/#30624" class="Datatype">Any</a> <a id="34876" class="Symbol">(</a><a id="34877" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#464" class="Function Operator">¬_</a> <a id="34880" href="/PLFA-zh/Lists/#34334" class="Function Operator">∘′</a> <a id="34883" href="/PLFA-zh/Lists/#34820" class="Bound">P</a><a id="34884" class="Symbol">)</a> <a id="34886" href="/PLFA-zh/Lists/#34834" class="Bound">xs</a></pre>
<!-- If so, prove; if not, explain why. -->

<p>如果成立，请证明；如果不成立，请解释原因。</p>

<!-- ## Decidability of All -->

<h2 id="所有的可判定性">所有的可判定性</h2>

<!-- If we consider a predicate as a function that yields a boolean,
it is easy to define an analogue of `All`, which returns true if
a given predicate returns true for every element of a list: -->

<p>如果我们将一个谓词看作一个返回布尔值的函数，那么我们可以简单的定义一个类似于 <code class="highlighter-rouge">All</code>
的函数，其当给定谓词对于列表每个元素返回真时返回真：</p>

<pre class="Agda"><a id="all"></a><a id="35323" href="/PLFA-zh/Lists/#35323" class="Function">all</a> <a id="35327" class="Symbol">:</a> <a id="35329" class="Symbol">∀</a> <a id="35331" class="Symbol">{</a><a id="35332" href="/PLFA-zh/Lists/#35332" class="Bound">A</a> <a id="35334" class="Symbol">:</a> <a id="35336" class="PrimitiveType">Set</a><a id="35339" class="Symbol">}</a> <a id="35341" class="Symbol">→</a> <a id="35343" class="Symbol">(</a><a id="35344" href="/PLFA-zh/Lists/#35332" class="Bound">A</a> <a id="35346" class="Symbol">→</a> <a id="35348" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Bool.html#67" class="Datatype">Bool</a><a id="35352" class="Symbol">)</a> <a id="35354" class="Symbol">→</a> <a id="35356" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="35361" href="/PLFA-zh/Lists/#35332" class="Bound">A</a> <a id="35363" class="Symbol">→</a> <a id="35365" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Bool.html#67" class="Datatype">Bool</a>
<a id="35370" href="/PLFA-zh/Lists/#35323" class="Function">all</a> <a id="35374" href="/PLFA-zh/Lists/#35374" class="Bound">p</a>  <a id="35377" class="Symbol">=</a>  <a id="35380" href="/PLFA-zh/Lists/#20673" class="Function">foldr</a> <a id="35386" href="https://agda.github.io/agda-stdlib/v0.17/Data.Bool.Base.html#1012" class="Function Operator">_∧_</a> <a id="35390" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Bool.html#92" class="InductiveConstructor">true</a> <a id="35395" href="https://agda.github.io/agda-stdlib/v0.17/Function.html#769" class="Function Operator">∘</a> <a id="35397" href="/PLFA-zh/Lists/#17306" class="Function">map</a> <a id="35401" href="/PLFA-zh/Lists/#35374" class="Bound">p</a></pre>
<!-- The function can be written in a particularly compact style by
using the higher-order functions `map` and `foldr`. -->

<p>我们可以使用高阶函数 <code class="highlighter-rouge">map</code> 和 <code class="highlighter-rouge">foldr</code> 来简洁地写出这个函数。</p>

<!-- As one would hope, if we replace booleans by decidables there is again
an analogue of `All`.  First, return to the notion of a predicate `P` as
a function of type `A → Set`, taking a value `x` of type `A` into evidence
`P x` that a property holds for `x`.  Say that a predicate `P` is _decidable_
if we have a function that for a given `x` can decide `P x`: -->

<p>正如所希望的那样，如果我们将布尔值替换成可判定值，这与 <code class="highlighter-rouge">All</code> 是相似的。首先，回到将 <code class="highlighter-rouge">P</code>
当作一个类型为 <code class="highlighter-rouge">A → Set</code> 的函数的概念，将一个类型为 <code class="highlighter-rouge">A</code> 的值 <code class="highlighter-rouge">x</code> 转换成 <code class="highlighter-rouge">P x</code> 对 <code class="highlighter-rouge">x</code> 成立的证明。我们成 <code class="highlighter-rouge">P</code> 为<strong>可判定的</strong>（Decidable），如果我们有一个函数，其在给定 <code class="highlighter-rouge">x</code> 时能够判定 <code class="highlighter-rouge">P x</code>：</p>

<pre class="Agda"><a id="Decidable"></a><a id="36155" href="/PLFA-zh/Lists/#36155" class="Function">Decidable</a> <a id="36165" class="Symbol">:</a> <a id="36167" class="Symbol">∀</a> <a id="36169" class="Symbol">{</a><a id="36170" href="/PLFA-zh/Lists/#36170" class="Bound">A</a> <a id="36172" class="Symbol">:</a> <a id="36174" class="PrimitiveType">Set</a><a id="36177" class="Symbol">}</a> <a id="36179" class="Symbol">→</a> <a id="36181" class="Symbol">(</a><a id="36182" href="/PLFA-zh/Lists/#36170" class="Bound">A</a> <a id="36184" class="Symbol">→</a> <a id="36186" class="PrimitiveType">Set</a><a id="36189" class="Symbol">)</a> <a id="36191" class="Symbol">→</a> <a id="36193" class="PrimitiveType">Set</a>
<a id="36197" href="/PLFA-zh/Lists/#36155" class="Function">Decidable</a> <a id="36207" class="Symbol">{</a><a id="36208" href="/PLFA-zh/Lists/#36208" class="Bound">A</a><a id="36209" class="Symbol">}</a> <a id="36211" href="/PLFA-zh/Lists/#36211" class="Bound">P</a>  <a id="36214" class="Symbol">=</a>  <a id="36217" class="Symbol">∀</a> <a id="36219" class="Symbol">(</a><a id="36220" href="/PLFA-zh/Lists/#36220" class="Bound">x</a> <a id="36222" class="Symbol">:</a> <a id="36224" href="/PLFA-zh/Lists/#36208" class="Bound">A</a><a id="36225" class="Symbol">)</a> <a id="36227" class="Symbol">→</a> <a id="36229" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#534" class="Datatype">Dec</a> <a id="36233" class="Symbol">(</a><a id="36234" href="/PLFA-zh/Lists/#36211" class="Bound">P</a> <a id="36236" href="/PLFA-zh/Lists/#36220" class="Bound">x</a><a id="36237" class="Symbol">)</a></pre>
<!-- Then if predicate `P` is decidable, it is also decidable whether every
element of a list satisfies the predicate: -->

<p>那么当谓词 <code class="highlighter-rouge">P</code> 可判定时，我们亦可判定列表中的每一个元素是否满足这个谓词：</p>
<pre class="Agda"><a id="All?"></a><a id="36435" href="/PLFA-zh/Lists/#36435" class="Function">All?</a> <a id="36440" class="Symbol">:</a> <a id="36442" class="Symbol">∀</a> <a id="36444" class="Symbol">{</a><a id="36445" href="/PLFA-zh/Lists/#36445" class="Bound">A</a> <a id="36447" class="Symbol">:</a> <a id="36449" class="PrimitiveType">Set</a><a id="36452" class="Symbol">}</a> <a id="36454" class="Symbol">{</a><a id="36455" href="/PLFA-zh/Lists/#36455" class="Bound">P</a> <a id="36457" class="Symbol">:</a> <a id="36459" href="/PLFA-zh/Lists/#36445" class="Bound">A</a> <a id="36461" class="Symbol">→</a> <a id="36463" class="PrimitiveType">Set</a><a id="36466" class="Symbol">}</a> <a id="36468" class="Symbol">→</a> <a id="36470" href="/PLFA-zh/Lists/#36155" class="Function">Decidable</a> <a id="36480" href="/PLFA-zh/Lists/#36455" class="Bound">P</a> <a id="36482" class="Symbol">→</a> <a id="36484" href="/PLFA-zh/Lists/#36155" class="Function">Decidable</a> <a id="36494" class="Symbol">(</a><a id="36495" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="36499" href="/PLFA-zh/Lists/#36455" class="Bound">P</a><a id="36500" class="Symbol">)</a>
<a id="36502" href="/PLFA-zh/Lists/#36435" class="Function">All?</a> <a id="36507" href="/PLFA-zh/Lists/#36507" class="Bound">P?</a> <a id="36510" href="/PLFA-zh/Lists/#1354" class="InductiveConstructor">[]</a>                                 <a id="36545" class="Symbol">=</a>  <a id="36548" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="36552" href="/PLFA-zh/Lists/#28501" class="InductiveConstructor">[]</a>
<a id="36555" href="/PLFA-zh/Lists/#36435" class="Function">All?</a> <a id="36560" href="/PLFA-zh/Lists/#36560" class="Bound">P?</a> <a id="36563" class="Symbol">(</a><a id="36564" href="/PLFA-zh/Lists/#36564" class="Bound">x</a> <a id="36566" href="/PLFA-zh/Lists/#1369" class="InductiveConstructor Operator">∷</a> <a id="36568" href="/PLFA-zh/Lists/#36568" class="Bound">xs</a><a id="36570" class="Symbol">)</a> <a id="36572" class="Keyword">with</a> <a id="36577" href="/PLFA-zh/Lists/#36560" class="Bound">P?</a> <a id="36580" href="/PLFA-zh/Lists/#36564" class="Bound">x</a>   <a id="36584" class="Symbol">|</a> <a id="36586" href="/PLFA-zh/Lists/#36435" class="Function">All?</a> <a id="36591" href="/PLFA-zh/Lists/#36560" class="Bound">P?</a> <a id="36594" href="/PLFA-zh/Lists/#36568" class="Bound">xs</a>
<a id="36597" class="Symbol">...</a>                 <a id="36617" class="Symbol">|</a> <a id="36619" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="36623" href="/PLFA-zh/Lists/#36623" class="Bound">Px</a> <a id="36626" class="Symbol">|</a> <a id="36628" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="36632" href="/PLFA-zh/Lists/#36632" class="Bound">Pxs</a>     <a id="36640" class="Symbol">=</a>  <a id="36643" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="36647" class="Symbol">(</a><a id="36648" href="/PLFA-zh/Lists/#36623" class="Bound">Px</a> <a id="36651" href="/PLFA-zh/Lists/#28518" class="InductiveConstructor Operator">∷</a> <a id="36653" href="/PLFA-zh/Lists/#36632" class="Bound">Pxs</a><a id="36656" class="Symbol">)</a>
<a id="36658" class="Symbol">...</a>                 <a id="36678" class="Symbol">|</a> <a id="36680" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="36683" href="/PLFA-zh/Lists/#36683" class="Bound">¬Px</a> <a id="36687" class="Symbol">|</a> <a id="36689" class="Symbol">_</a>           <a id="36701" class="Symbol">=</a>  <a id="36704" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="36707" class="Symbol">λ{</a> <a id="36710" class="Symbol">(</a><a id="36711" href="/PLFA-zh/Lists/#36711" class="Bound">Px</a> <a id="36714" href="/PLFA-zh/Lists/#28518" class="InductiveConstructor Operator">∷</a> <a id="36716" href="/PLFA-zh/Lists/#36716" class="Bound">Pxs</a><a id="36719" class="Symbol">)</a> <a id="36721" class="Symbol">→</a> <a id="36723" href="/PLFA-zh/Lists/#36683" class="Bound">¬Px</a> <a id="36727" href="/PLFA-zh/Lists/#36711" class="Bound">Px</a>   <a id="36732" class="Symbol">}</a>
<a id="36734" class="CatchallClause Symbol">...</a><a id="36737" class="CatchallClause">                 </a><a id="36754" class="CatchallClause Symbol">|</a><a id="36755" class="CatchallClause"> </a><a id="36756" class="CatchallClause Symbol">_</a><a id="36757" class="CatchallClause">      </a><a id="36763" class="CatchallClause Symbol">|</a><a id="36764" class="CatchallClause"> </a><a id="36765" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#597" class="CatchallClause InductiveConstructor">no</a><a id="36767" class="CatchallClause"> </a><a id="36768" href="/PLFA-zh/Lists/#36768" class="CatchallClause Bound">¬Pxs</a>     <a id="36777" class="Symbol">=</a>  <a id="36780" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="36783" class="Symbol">λ{</a> <a id="36786" class="Symbol">(</a><a id="36787" href="/PLFA-zh/Lists/#36787" class="Bound">Px</a> <a id="36790" href="/PLFA-zh/Lists/#28518" class="InductiveConstructor Operator">∷</a> <a id="36792" href="/PLFA-zh/Lists/#36792" class="Bound">Pxs</a><a id="36795" class="Symbol">)</a> <a id="36797" class="Symbol">→</a> <a id="36799" href="/PLFA-zh/Lists/#36768" class="Bound">¬Pxs</a> <a id="36804" href="/PLFA-zh/Lists/#36792" class="Bound">Pxs</a> <a id="36808" class="Symbol">}</a></pre>
<!-- If the list is empty, then trivially `P` holds for every element of
the list.  Otherwise, the structure of the proof is similar to that
showing that the conjunction of two decidable propositions is itself
decidable, using `_∷_` rather than `⟨_,_⟩` to combine the evidence for
the head and tail of the list. -->

<p>如果列表为空，那么 <code class="highlighter-rouge">P</code> 显然对列表的每个元素成立。否则，证明的结构与两个可判定的命题是可判定的证明相似，不过我们使用 <code class="highlighter-rouge">_∷_</code> 而不是 <code class="highlighter-rouge">⟨_,_⟩</code>
来整合头元素和尾列表的证明。</p>

<!-- #### Exercise `any?` (stretch) -->

<h4 id="练习-any-延伸">练习 <code class="highlighter-rouge">any?</code> （延伸）</h4>

<!-- Just as `All` has analogues `all` and `All?` which determine whether a
predicate holds for every element of a list, so does `Any` have
analogues `any` and `Any?` which determine whether a predicate holds
for some element of a list.  Give their definitions. -->

<p>正如 <code class="highlighter-rouge">All</code> 有类似的 <code class="highlighter-rouge">all</code> 和 <code class="highlighter-rouge">All?</code> 形式，来判断列表的每个元素是否满足给定的谓词，那么 <code class="highlighter-rouge">Any</code> 也有类似的 <code class="highlighter-rouge">any</code> 和 <code class="highlighter-rouge">Any?</code> 形式，来判断列表的一些元素是否满足给定的谓词。给出它们的定义。</p>

<!-- <pre class="Agda"><a id="37730" class="Comment">-- Your code goes here</a></pre> -->

<pre class="Agda"><a id="37783" class="Comment">-- 请将代码写在此处。</a></pre>

<!-- #### Exercise `All-∀` -->

<h4 id="练习-all-">练习 <code class="highlighter-rouge">All-∀</code></h4>

<!-- Show that `All P xs` is isomorphic to `∀ {x} → x ∈ xs → P x`. -->

<p>证明 <code class="highlighter-rouge">All P xs</code> 与 <code class="highlighter-rouge">∀ {x} → x ∈ xs → P x</code> 同构。</p>

<!-- <pre class="Agda"><a id="38015" class="Comment">-- You code goes here</a></pre> -->

<pre class="Agda"><a id="38067" class="Comment">-- 请将代码写在此处。</a></pre>

<!-- #### Exercise `Any-∃` -->

<h4 id="练习-any-">练习 <code class="highlighter-rouge">Any-∃</code></h4>

<!-- Show that `Any P xs` is isomorphic to `∃[ x ∈ xs ] P x`. -->

<p>证明 <code class="highlighter-rouge">Any P xs</code> 与 <code class="highlighter-rouge">∃[ x ∈ xs ] P x</code> 同构。</p>

<!-- <pre class="Agda"><a id="38289" class="Comment">-- You code goes here</a></pre> -->

<pre class="Agda"><a id="38341" class="Comment">-- 请将代码写在此处。</a></pre>

<!-- #### Exercise `filter?` (stretch) -->

<h4 id="练习-filter-延伸">练习 <code class="highlighter-rouge">filter?</code> （延伸）</h4>

<!-- Define the following variant of the traditional `filter` function on lists,
which given a decidable predicate and a list returns all elements of the
list satisfying the predicate: -->

<p>定义下面给出的列表 <code class="highlighter-rouge">filter</code> 函数的变种，给定一个可判定的谓词和一个列表，返回列表中所有满足谓词的元素：</p>
<pre class="Agda"><a id="38713" class="Keyword">postulate</a>
  <a id="filter?"></a><a id="38725" href="/PLFA-zh/Lists/#38725" class="Postulate">filter?</a> <a id="38733" class="Symbol">:</a> <a id="38735" class="Symbol">∀</a> <a id="38737" class="Symbol">{</a><a id="38738" href="/PLFA-zh/Lists/#38738" class="Bound">A</a> <a id="38740" class="Symbol">:</a> <a id="38742" class="PrimitiveType">Set</a><a id="38745" class="Symbol">}</a> <a id="38747" class="Symbol">{</a><a id="38748" href="/PLFA-zh/Lists/#38748" class="Bound">P</a> <a id="38750" class="Symbol">:</a> <a id="38752" href="/PLFA-zh/Lists/#38738" class="Bound">A</a> <a id="38754" class="Symbol">→</a> <a id="38756" class="PrimitiveType">Set</a><a id="38759" class="Symbol">}</a>
    <a id="38765" class="Symbol">→</a> <a id="38767" class="Symbol">(</a><a id="38768" href="/PLFA-zh/Lists/#38768" class="Bound">P?</a> <a id="38771" class="Symbol">:</a> <a id="38773" href="/PLFA-zh/Lists/#36155" class="Function">Decidable</a> <a id="38783" href="/PLFA-zh/Lists/#38748" class="Bound">P</a><a id="38784" class="Symbol">)</a> <a id="38786" class="Symbol">→</a> <a id="38788" href="/PLFA-zh/Lists/#1325" class="Datatype">List</a> <a id="38793" href="/PLFA-zh/Lists/#38738" class="Bound">A</a> <a id="38795" class="Symbol">→</a> <a id="38797" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#942" class="Function">∃[</a> <a id="38800" href="/PLFA-zh/Lists/#38800" class="Bound">ys</a> <a id="38803" href="https://agda.github.io/agda-stdlib/v0.17/Data.Product.html#942" class="Function">]</a><a id="38804" class="Symbol">(</a> <a id="38806" href="/PLFA-zh/Lists/#28450" class="Datatype">All</a> <a id="38810" href="/PLFA-zh/Lists/#38748" class="Bound">P</a> <a id="38812" href="/PLFA-zh/Lists/#38800" class="Bound">ys</a> <a id="38815" class="Symbol">)</a></pre>

<!-- ## Standard Library -->

<h2 id="标准库">标准库</h2>

<!-- Definitions similar to those in this chapter can be found in the standard library: -->

<p>标准库中可以找到与本章节中相似的定义：</p>
<pre class="Agda"><a id="39010" class="Keyword">import</a> <a id="39017" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.html" class="Module">Data.List</a> <a id="39027" class="Keyword">using</a> <a id="39033" class="Symbol">(</a><a id="39034" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.List.html#80" class="Datatype">List</a><a id="39038" class="Symbol">;</a> <a id="39040" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Base.html#1454" class="Function Operator">_++_</a><a id="39044" class="Symbol">;</a> <a id="39046" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Base.html#4008" class="Function">length</a><a id="39052" class="Symbol">;</a> <a id="39054" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Base.html#8504" class="Function">reverse</a><a id="39061" class="Symbol">;</a> <a id="39063" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Base.html#1120" class="Function">map</a><a id="39066" class="Symbol">;</a> <a id="39068" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Base.html#3142" class="Function">foldr</a><a id="39073" class="Symbol">;</a> <a id="39075" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Base.html#5708" class="Function">downFrom</a><a id="39083" class="Symbol">)</a>
<a id="39085" class="Keyword">import</a> <a id="39092" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.All.html" class="Module">Data.List.All</a> <a id="39106" class="Keyword">using</a> <a id="39112" class="Symbol">(</a><a id="39113" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.All.html#826" class="Datatype">All</a><a id="39116" class="Symbol">;</a> <a id="39118" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.All.html#904" class="InductiveConstructor">[]</a><a id="39120" class="Symbol">;</a> <a id="39122" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.All.html#921" class="InductiveConstructor Operator">_∷_</a><a id="39125" class="Symbol">)</a>
<a id="39127" class="Keyword">import</a> <a id="39134" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Any.html" class="Module">Data.List.Any</a> <a id="39148" class="Keyword">using</a> <a id="39154" class="Symbol">(</a><a id="39155" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Any.html#856" class="Datatype">Any</a><a id="39158" class="Symbol">;</a> <a id="39160" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Any.html#911" class="InductiveConstructor">here</a><a id="39164" class="Symbol">;</a> <a id="39166" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Any.html#964" class="InductiveConstructor">there</a><a id="39171" class="Symbol">)</a>
<a id="39173" class="Keyword">import</a> <a id="39180" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="39215" class="Keyword">using</a> <a id="39221" class="Symbol">(</a><a id="39222" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Membership.Setoid.html#709" class="Function Operator">_∈_</a><a id="39225" class="Symbol">)</a>
<a id="39227" class="Keyword">import</a> <a id="39234" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Properties.html" class="Module">Data.List.Properties</a>
  <a id="39257" class="Keyword">using</a> <a id="39263" class="Symbol">(</a><a id="39264" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Properties.html#23846" class="Function">reverse-++-commute</a><a id="39282" class="Symbol">;</a> <a id="39284" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Properties.html#2896" class="Function">map-compose</a><a id="39295" class="Symbol">;</a> <a id="39297" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Properties.html#2117" class="Function">map-++-commute</a><a id="39311" class="Symbol">;</a> <a id="39313" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Properties.html#15132" class="Function">foldr-++</a><a id="39321" class="Symbol">)</a>
  <a id="39325" class="Keyword">renaming</a> <a id="39334" class="Symbol">(</a><a id="39335" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Properties.html#31352" class="Function">mapIsFold</a> <a id="39345" class="Symbol">to</a> <a id="39348" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Properties.html#31352" class="Function">map-is-foldr</a><a id="39360" class="Symbol">)</a>
<a id="39362" class="Keyword">import</a> <a id="39369" href="https://agda.github.io/agda-stdlib/v0.17/Algebra.Structures.html" class="Module">Algebra.Structures</a> <a id="39388" class="Keyword">using</a> <a id="39394" class="Symbol">(</a><a id="39395" href="https://agda.github.io/agda-stdlib/v0.17/Algebra.Structures.html#1339" class="Record">IsMonoid</a><a id="39403" class="Symbol">)</a>
<a id="39405" class="Keyword">import</a> <a id="39412" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Unary.html" class="Module">Relation.Unary</a> <a id="39427" class="Keyword">using</a> <a id="39433" class="Symbol">(</a><a id="39434" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Unary.html#3313" class="Function">Decidable</a><a id="39443" class="Symbol">)</a>
<a id="39445" class="Keyword">import</a> <a id="39452" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="39468" class="Keyword">using</a> <a id="39474" class="Symbol">(</a><a id="39475" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.Core.html#4499" class="Function">Decidable</a><a id="39484" class="Symbol">)</a></pre>
<!-- The standard library version of `IsMonoid` differs from the
one given here, in that it is also parameterised on an equivalence relation. -->

<p>标准库中的 <code class="highlighter-rouge">IsMonoid</code> 与给出的定义不同，因为它可以针对特定的等价关系参数化。</p>

<!-- Both `Relation.Unary` and `Relation.Binary` define a version of `Decidable`,
one for unary relations (as used in this chapter where `P` ranges over
unary predicates) and one for binary relations (as used earlier, where `_≤_`
ranges over a binary relation). -->

<p><code class="highlighter-rouge">Relation.Unary</code> 和 <code class="highlighter-rouge">Relation.Binary</code> 都定义了 <code class="highlighter-rouge">Decidable</code> 的某个版本，一个用于单元关系（正如本章中的单元谓词 <code class="highlighter-rouge">P</code>），一个用于二元关系（正如之前使用的 <code class="highlighter-rouge">_≤_</code>）。</p>

<h2 id="unicode">Unicode</h2>

<!-- This chapter uses the following unicode: -->

<p>本章节使用下列 Unicode：</p>

<!--     ∷  U+2237  PROPORTION  (\::)
    ⊗  U+2297  CIRCLED TIMES  (\otimes, \ox)
    ∈  U+2208  ELEMENT OF  (\in)
    ∉  U+2209  NOT AN ELEMENT OF  (\inn, \notin)
 -->

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∷  U+2237  比例  (\::)
⊗  U+2297  带圈的乘号  (\otimes, \ox)
∈  U+2208  是……的元素  (\in)
∉  U+2209  不是……的元素  (\inn, \notin)
</code></pre></div></div>

  </div>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Decidable/">前一章</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/Lists.lagda">源代码</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/PLFA-zh/Lambda/">后一章</a>
    
</p>


</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/PLFA-zh/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">编程语言基础：Agda 描述
</h2>

    <h3 class="footer-heading">原作者：</h3><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li>
          <li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li>
          <li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><h3 class="footer-heading">本章翻译进度：100%</h3>
        <h3 class="footer-heading">本章译者：</h3>
        <p>Fangyi Zhou</p>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可。<br />
    This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
  </div>
</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/PLFA-zh/assets/jquery.js"></script>

<!-- Script which draws background for progress tags -->
<script type="text/javascript">
$('span.progress').each(function(){
    const progress = parseInt($(this).text());
    $(this).css({
        'border-style': 'solid',
        'border-radius': '5px',
        'border-width': 'thin',
        'border-color': progress === 100 ? 'limegreen' : 'dimgray',
        'font-size': '70%',
        'padding': '0% 0.5% 0% 0.5%',
        'margin': '0em 0em 0em 0.5em',
        'box-sizing': 'border-box',
        'vertical-align': '10%'
    });
    $(this).text(progress.toString() + " %");
})
</script>

<!-- Script which allows for foldable code blocks -->
<script type="text/javascript">
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/PLFA-zh/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
