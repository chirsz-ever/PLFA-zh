<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Lambda: Introduction to Lambda Calculus | 编程语言基础：Agda 描述
</title><!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Lambda: Introduction to Lambda Calculus" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="编程语言基础：Agda 描述" />
<meta property="og:description" content="编程语言基础：Agda 描述" />
<link rel="canonical" href="https://agda-zh.github.io/PLFA-zh/Lambda/" />
<meta property="og:url" content="https://agda-zh.github.io/PLFA-zh/Lambda/" />
<meta property="og:site_name" content="编程语言基础：Agda 描述" />
<script type="application/ld+json">
{"description":"编程语言基础：Agda 描述","@type":"WebPage","url":"https://agda-zh.github.io/PLFA-zh/Lambda/","headline":"Lambda: Introduction to Lambda Calculus","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/PLFA-zh/assets/main.css"></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/PLFA-zh/">编程语言基础：Agda 描述
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/PLFA-zh/">本书</a>
                <!--!>
                <a class="page-link" href="/PLFA-zh/Announcements/">公告</a>
                <---->
                <a class="page-link" href="/PLFA-zh/GettingStarted/">使用说明</a>
                <a class="page-link" href="/PLFA-zh/Citing/">引用</a>
                <a class="page-link" href="https://plfa.github.io/">English</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
      <h1 class="post-title">Lambda: Introduction to Lambda Calculus</h1>
  </header>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Lists/">前一章</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/Lambda.lagda">源代码</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/PLFA-zh/Properties/">后一章</a>
    
</p>


  <div class="post-content">
    <pre class="Agda"><a id="160" class="Keyword">module</a> <a id="167" href="/PLFA-zh/Lambda/" class="Module">plfa.Lambda</a> <a id="179" class="Keyword">where</a></pre>

<p>The <em>lambda-calculus</em>, first published by the logician Alonzo Church in
1932, is a core calculus with only three syntactic constructs:
variables, abstraction, and application.  It captures the key concept of
<em>functional abstraction</em>, which appears in pretty much every programming
language, in the form of either functions, procedures, or methods.
The <em>simply-typed lambda calculus</em> (or STLC) is a variant of the
lambda calculus published by Church in 1940.  It has the three
constructs above for function types, plus whatever else is required
for base types. Church had a minimal base type with no operations.
We will instead echo Plotkin’s <em>Programmable Computable
Functions</em> (PCF), and add operations on natural numbers and
recursive function definitions.</p>

<p>This chapter formalises the simply-typed lambda calculus, giving its
syntax, small-step semantics, and typing rules.  The next chapter
<a href="/PLFA-zh/Properties/">Properties</a>
proves its main properties, including
progress and preservation.  Following chapters will look at a number
of variants of lambda calculus.</p>

<p>Be aware that the approach we take here is <em>not</em> our recommended
approach to formalisation.  Using de Bruijn indices and
inherently-typed terms, as we will do in
Chapter <a href="/PLFA-zh/DeBruijn/">DeBruijn</a>,
leads to a more compact formulation.  Nonetheless, we begin with named
variables, partly because such terms are easier to read and partly
because the development is more traditional.</p>

<p>The development in this chapter was inspired by the corresponding
development in Chapter <em>Stlc</em> of <em>Software Foundations</em>
(<em>Programming Language Foundations</em>).  We differ by
representing contexts explicitly (as lists pairing identifiers with
types) rather than as partial maps (which take identifiers to types),
which corresponds better to our subsequent development of DeBruijn
notation. We also differ by taking natural numbers as the base type
rather than booleans, allowing more sophisticated examples. In
particular, we will be able to show (twice!) that two plus two is
four.</p>

<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="2251" class="Keyword">open</a> <a id="2256" class="Keyword">import</a> <a id="2263" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="2301" class="Keyword">using</a> <a id="2307" class="Symbol">(</a><a id="2308" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">_≡_</a><a id="2311" class="Symbol">;</a> <a id="2313" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.Core.html#660" class="Function Operator">_≢_</a><a id="2316" class="Symbol">;</a> <a id="2318" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="2322" class="Symbol">)</a>
<a id="2324" class="Keyword">open</a> <a id="2329" class="Keyword">import</a> <a id="2336" href="https://agda.github.io/agda-stdlib/v0.17/Data.String.html" class="Module">Data.String</a> <a id="2348" class="Keyword">using</a> <a id="2354" class="Symbol">(</a><a id="2355" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.String.html#165" class="Postulate">String</a><a id="2361" class="Symbol">)</a>
<a id="2363" class="Keyword">open</a> <a id="2368" class="Keyword">import</a> <a id="2375" href="https://agda.github.io/agda-stdlib/v0.17/Data.String.Unsafe.html" class="Module">Data.String.Unsafe</a> <a id="2394" class="Keyword">using</a> <a id="2400" class="Symbol">(</a><a id="2401" href="https://agda.github.io/agda-stdlib/v0.17/Data.String.Unsafe.html#749" class="Function Operator">_≟_</a><a id="2404" class="Symbol">)</a>
<a id="2406" class="Keyword">open</a> <a id="2411" class="Keyword">import</a> <a id="2418" href="https://agda.github.io/agda-stdlib/v0.17/Data.Nat.html" class="Module">Data.Nat</a> <a id="2427" class="Keyword">using</a> <a id="2433" class="Symbol">(</a><a id="2434" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="2435" class="Symbol">;</a> <a id="2437" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a><a id="2441" class="Symbol">;</a> <a id="2443" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a><a id="2446" class="Symbol">)</a>
<a id="2448" class="Keyword">open</a> <a id="2453" class="Keyword">import</a> <a id="2460" href="https://agda.github.io/agda-stdlib/v0.17/Data.Empty.html" class="Module">Data.Empty</a> <a id="2471" class="Keyword">using</a> <a id="2477" class="Symbol">(</a><a id="2478" href="https://agda.github.io/agda-stdlib/v0.17/Data.Empty.html#243" class="Datatype">⊥</a><a id="2479" class="Symbol">;</a> <a id="2481" href="https://agda.github.io/agda-stdlib/v0.17/Data.Empty.html#360" class="Function">⊥-elim</a><a id="2487" class="Symbol">)</a>
<a id="2489" class="Keyword">open</a> <a id="2494" class="Keyword">import</a> <a id="2501" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="2518" class="Keyword">using</a> <a id="2524" class="Symbol">(</a><a id="2525" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#534" class="Datatype">Dec</a><a id="2528" class="Symbol">;</a> <a id="2530" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#570" class="InductiveConstructor">yes</a><a id="2533" class="Symbol">;</a> <a id="2535" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#597" class="InductiveConstructor">no</a><a id="2537" class="Symbol">;</a> <a id="2539" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#464" class="Function Operator">¬_</a><a id="2541" class="Symbol">)</a>
<a id="2543" class="Keyword">open</a> <a id="2548" class="Keyword">import</a> <a id="2555" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="2581" class="Keyword">using</a> <a id="2587" class="Symbol">(</a><a id="2588" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.Negation.html#1017" class="Function">¬?</a><a id="2590" class="Symbol">)</a>
<a id="2592" class="Keyword">open</a> <a id="2597" class="Keyword">import</a> <a id="2604" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.html" class="Module">Data.List</a> <a id="2614" class="Keyword">using</a> <a id="2620" class="Symbol">(</a><a id="2621" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.List.html#80" class="Datatype">List</a><a id="2625" class="Symbol">;</a> <a id="2627" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.List.html#132" class="InductiveConstructor Operator">_∷_</a><a id="2630" class="Symbol">;</a> <a id="2632" href="https://agda.github.io/agda-stdlib/v0.17/Data.List.Base.html#8785" class="InductiveConstructor">[]</a><a id="2634" class="Symbol">)</a></pre>

<h2 id="syntax-of-terms">Syntax of terms</h2>

<p>Terms have seven constructs. Three are for the core lambda calculus:</p>

<ul>
  <li>Variables <code class="highlighter-rouge">` x</code></li>
  <li>Abstractions <code class="highlighter-rouge">ƛ x ⇒ N</code></li>
  <li>Applications <code class="highlighter-rouge">L · M</code></li>
</ul>

<p>Three are for the naturals:</p>

<ul>
  <li>Zero <code class="highlighter-rouge">`zero</code></li>
  <li>Successor <code class="highlighter-rouge">`suc</code></li>
  <li>Case <code class="highlighter-rouge">case L [zero⇒ M |suc x ⇒ N ]</code></li>
</ul>

<p>And one is for recursion:</p>

<ul>
  <li>Fixpoint <code class="highlighter-rouge">μ x ⇒ M</code></li>
</ul>

<p>Abstraction is also called <em>lambda abstraction</em>, and is the construct
from which the calculus takes its name.</p>

<p>With the exception of variables and fixpoints, each term
form either constructs a value of a given type (abstractions yield functions,
zero and successor yield natural numbers) or deconstructs it (applications use functions,
case terms use naturals). We will see this again when we come
to the rules for assigning types to terms, where constructors
correspond to introduction rules and deconstructors to eliminators.</p>

<p>Here is the syntax of terms in Backus-Naur Form (BNF):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L, M, N  ::=
  ` x  |  ƛ x ⇒ N  |  L · M  |
  `zero  |  `suc M  |  case L [zero⇒ M |suc x ⇒ N]  |
  μ x ⇒ M
</code></pre></div></div>

<p>And here it is formalised in Agda:</p>
<pre class="Agda"><a id="Id"></a><a id="3744" href="/PLFA-zh/Lambda/#3744" class="Function">Id</a> <a id="3747" class="Symbol">:</a> <a id="3749" class="PrimitiveType">Set</a>
<a id="3753" href="/PLFA-zh/Lambda/#3744" class="Function">Id</a> <a id="3756" class="Symbol">=</a> <a id="3758" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.String.html#165" class="Postulate">String</a>

<a id="3766" class="Keyword">infix</a>  <a id="3773" class="Number">5</a>  <a id="3776" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ_⇒_</a>
<a id="3781" class="Keyword">infix</a>  <a id="3788" class="Number">5</a>  <a id="3791" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">μ_⇒_</a>
<a id="3796" class="Keyword">infixl</a> <a id="3803" class="Number">7</a>  <a id="3806" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">_·_</a>
<a id="3810" class="Keyword">infix</a>  <a id="3817" class="Number">8</a>  <a id="3820" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc_</a>
<a id="3826" class="Keyword">infix</a>  <a id="3833" class="Number">9</a>  <a id="3836" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`_</a>

<a id="3840" class="Keyword">data</a> <a id="Term"></a><a id="3845" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="3850" class="Symbol">:</a> <a id="3852" class="PrimitiveType">Set</a> <a id="3856" class="Keyword">where</a>
  <a id="Term.`_"></a><a id="3864" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`_</a>                      <a id="3888" class="Symbol">:</a>  <a id="3891" href="/PLFA-zh/Lambda/#3744" class="Function">Id</a> <a id="3894" class="Symbol">→</a> <a id="3896" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
  <a id="Term.ƛ_⇒_"></a><a id="3903" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ_⇒_</a>                    <a id="3927" class="Symbol">:</a>  <a id="3930" href="/PLFA-zh/Lambda/#3744" class="Function">Id</a> <a id="3933" class="Symbol">→</a> <a id="3935" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="3940" class="Symbol">→</a> <a id="3942" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
  <a id="Term._·_"></a><a id="3949" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">_·_</a>                     <a id="3973" class="Symbol">:</a>  <a id="3976" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="3981" class="Symbol">→</a> <a id="3983" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="3988" class="Symbol">→</a> <a id="3990" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
  <a id="Term.`zero"></a><a id="3997" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a>                   <a id="4021" class="Symbol">:</a>  <a id="4024" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
  <a id="Term.`suc_"></a><a id="4031" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc_</a>                   <a id="4055" class="Symbol">:</a>  <a id="4058" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="4063" class="Symbol">→</a> <a id="4065" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
  <a id="Term.case_[zero⇒_|suc_⇒_]"></a><a id="4072" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case_[zero⇒_|suc_⇒_]</a>    <a id="4096" class="Symbol">:</a>  <a id="4099" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="4104" class="Symbol">→</a> <a id="4106" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="4111" class="Symbol">→</a> <a id="4113" href="/PLFA-zh/Lambda/#3744" class="Function">Id</a> <a id="4116" class="Symbol">→</a> <a id="4118" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="4123" class="Symbol">→</a> <a id="4125" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
  <a id="Term.μ_⇒_"></a><a id="4132" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">μ_⇒_</a>                    <a id="4156" class="Symbol">:</a>  <a id="4159" href="/PLFA-zh/Lambda/#3744" class="Function">Id</a> <a id="4162" class="Symbol">→</a> <a id="4164" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="4169" class="Symbol">→</a> <a id="4171" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a></pre>
<p>We represent identifiers by strings.  We choose precedence so that
lambda abstraction and fixpoint bind least tightly, then application,
then successor, and tightest of all is the constructor for variables.
Case expressions are self-bracketing.</p>

<h3 id="example-terms">Example terms</h3>

<p>Here are some example terms: the natural number two,
a function that adds naturals,
and a term that computes two plus two:</p>
<pre class="Agda"><a id="two"></a><a id="4589" href="/PLFA-zh/Lambda/#4589" class="Function">two</a> <a id="4593" class="Symbol">:</a> <a id="4595" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
<a id="4600" href="/PLFA-zh/Lambda/#4589" class="Function">two</a> <a id="4604" class="Symbol">=</a> <a id="4606" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="4611" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="4616" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a>

<a id="plus"></a><a id="4623" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="4628" class="Symbol">:</a> <a id="4630" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
<a id="4635" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="4640" class="Symbol">=</a> <a id="4642" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">μ</a> <a id="4644" class="String">&quot;+&quot;</a> <a id="4648" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">⇒</a> <a id="4650" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="4652" class="String">&quot;m&quot;</a> <a id="4656" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="4658" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="4660" class="String">&quot;n&quot;</a> <a id="4664" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a>
         <a id="4675" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="4680" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="4682" class="String">&quot;m&quot;</a>
           <a id="4697" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="4704" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="4706" class="String">&quot;n&quot;</a>
           <a id="4721" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="4726" class="String">&quot;m&quot;</a> <a id="4730" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="4732" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="4737" class="Symbol">(</a><a id="4738" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="4740" class="String">&quot;+&quot;</a> <a id="4744" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="4746" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="4748" class="String">&quot;m&quot;</a> <a id="4752" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="4754" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="4756" class="String">&quot;n&quot;</a><a id="4759" class="Symbol">)</a> <a id="4761" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a></pre>
<p>The recursive definition of addition is similar to our original
definition of <code class="highlighter-rouge">_+_</code> for naturals, as given in
Chapter <a href="/PLFA-zh/Naturals/#plus">Naturals</a>.
Here variable “m” is bound twice, once in a lambda abstraction and once in
the successor branch of the case; the first use of “m” refers to
the former and the second to the latter.  Any use of “m” in the successor branch
must refer to the latter binding, and so we say that the latter binding <em>shadows</em>
the former.  Later we will confirm that two plus two is four, in other words that
the term</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plus · two · two
</code></pre></div></div>

<p>reduces to <code class="highlighter-rouge">`suc `suc `suc `suc `zero</code>.</p>

<p>As a second example, we use higher-order functions to represent
natural numbers.  In particular, the number <em>n</em> is represented by a
function that accepts two arguments and applies the first <em>n</em> times to the
second.  This is called the <em>Church representation</em> of the
naturals.  Here are some example terms: the Church numeral two, a
function that adds Church numerals, a function to compute successor,
and a term that computes two plus two:</p>
<pre class="Agda"><a id="twoᶜ"></a><a id="5839" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="5844" class="Symbol">:</a> <a id="5846" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
<a id="5851" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="5856" class="Symbol">=</a>  <a id="5859" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="5861" class="String">&quot;s&quot;</a> <a id="5865" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="5867" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="5869" class="String">&quot;z&quot;</a> <a id="5873" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="5875" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="5877" class="String">&quot;s&quot;</a> <a id="5881" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="5883" class="Symbol">(</a><a id="5884" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="5886" class="String">&quot;s&quot;</a> <a id="5890" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="5892" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="5894" class="String">&quot;z&quot;</a><a id="5897" class="Symbol">)</a>

<a id="plusᶜ"></a><a id="5900" href="/PLFA-zh/Lambda/#5900" class="Function">plusᶜ</a> <a id="5906" class="Symbol">:</a> <a id="5908" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
<a id="5913" href="/PLFA-zh/Lambda/#5900" class="Function">plusᶜ</a> <a id="5919" class="Symbol">=</a>  <a id="5922" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="5924" class="String">&quot;m&quot;</a> <a id="5928" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="5930" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="5932" class="String">&quot;n&quot;</a> <a id="5936" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="5938" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="5940" class="String">&quot;s&quot;</a> <a id="5944" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="5946" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="5948" class="String">&quot;z&quot;</a> <a id="5952" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a>
         <a id="5963" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="5965" class="String">&quot;m&quot;</a> <a id="5969" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="5971" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="5973" class="String">&quot;s&quot;</a> <a id="5977" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="5979" class="Symbol">(</a><a id="5980" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="5982" class="String">&quot;n&quot;</a> <a id="5986" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="5988" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="5990" class="String">&quot;s&quot;</a> <a id="5994" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="5996" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="5998" class="String">&quot;z&quot;</a><a id="6001" class="Symbol">)</a>

<a id="sucᶜ"></a><a id="6004" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="6009" class="Symbol">:</a> <a id="6011" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
<a id="6016" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="6021" class="Symbol">=</a> <a id="6023" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="6025" class="String">&quot;n&quot;</a> <a id="6029" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="6031" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="6036" class="Symbol">(</a><a id="6037" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="6039" class="String">&quot;n&quot;</a><a id="6042" class="Symbol">)</a></pre>
<p>The Church numeral for two takes two arguments <code class="highlighter-rouge">s</code> and <code class="highlighter-rouge">z</code>
and applies <code class="highlighter-rouge">s</code> twice to <code class="highlighter-rouge">z</code>.
Addition takes two numerals <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code>, a
function <code class="highlighter-rouge">s</code> and an argument <code class="highlighter-rouge">z</code>, and it uses <code class="highlighter-rouge">m</code> to apply <code class="highlighter-rouge">s</code> to the
result of using <code class="highlighter-rouge">n</code> to apply <code class="highlighter-rouge">s</code> to <code class="highlighter-rouge">z</code>; hence <code class="highlighter-rouge">s</code> is applied <code class="highlighter-rouge">m</code> plus
<code class="highlighter-rouge">n</code> times to <code class="highlighter-rouge">z</code>, yielding the Church numeral for the sum of <code class="highlighter-rouge">m</code> and
<code class="highlighter-rouge">n</code>.  For convenience, we define a function that computes successor.
To convert a Church numeral to the corresponding natural, we apply
it to the <code class="highlighter-rouge">sucᶜ</code> function and the natural number zero.
Again, later we will confirm that two plus two is four,
in other words that the term</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plusᶜ · twoᶜ · twoᶜ · sucᶜ · `zero
</code></pre></div></div>

<p>reduces to <code class="highlighter-rouge">`suc `suc `suc `suc `zero</code>.</p>

<h4 id="exercise-mul-recommended">Exercise <code class="highlighter-rouge">mul</code> (recommended)</h4>

<p>Write out the definition of a lambda term that multiplies
two natural numbers.  Your definition may use <code class="highlighter-rouge">plus</code> as
defined earlier.</p>

<h4 id="exercise-mulᶜ">Exercise <code class="highlighter-rouge">mulᶜ</code></h4>

<p>Write out the definition of a lambda term that multiplies
two natural numbers represented as Church numerals. Your
definition may use <code class="highlighter-rouge">plusᶜ</code> as defined earlier (or may not
— there are nice definitions both ways).</p>

<h4 id="exercise-primed-stretch">Exercise <code class="highlighter-rouge">primed</code> (stretch)</h4>

<p>Some people find it annoying to write <code class="highlighter-rouge">` "x"</code> instead of <code class="highlighter-rouge">x</code>.
We can make examples with lambda terms slightly easier to write
by adding the following definitions:</p>
<pre class="Agda"><a id="ƛ′_⇒_"></a><a id="7380" href="/PLFA-zh/Lambda/#7380" class="Function Operator">ƛ′_⇒_</a> <a id="7386" class="Symbol">:</a> <a id="7388" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="7393" class="Symbol">→</a> <a id="7395" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="7400" class="Symbol">→</a> <a id="7402" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
<a id="7407" href="/PLFA-zh/Lambda/#7380" class="Function Operator">ƛ′</a> <a id="7410" class="Symbol">(</a><a id="7411" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="7413" href="/PLFA-zh/Lambda/#7413" class="Bound">x</a><a id="7414" class="Symbol">)</a> <a id="7416" href="/PLFA-zh/Lambda/#7380" class="Function Operator">⇒</a> <a id="7418" href="/PLFA-zh/Lambda/#7418" class="Bound">N</a>  <a id="7421" class="Symbol">=</a>  <a id="7424" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="7426" href="/PLFA-zh/Lambda/#7413" class="Bound">x</a> <a id="7428" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="7430" href="/PLFA-zh/Lambda/#7418" class="Bound">N</a>
<a id="7432" href="/PLFA-zh/Lambda/#7380" class="CatchallClause Function Operator">ƛ′</a><a id="7434" class="CatchallClause"> </a><a id="7435" class="CatchallClause Symbol">_</a><a id="7436" class="CatchallClause"> </a><a id="7437" href="/PLFA-zh/Lambda/#7380" class="CatchallClause Function Operator">⇒</a><a id="7438" class="CatchallClause"> </a><a id="7439" class="CatchallClause Symbol">_</a>      <a id="7446" class="Symbol">=</a>  <a id="7449" href="https://agda.github.io/agda-stdlib/v0.17/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="7456" href="/PLFA-zh/Lambda/#7485" class="Postulate">impossible</a>
  <a id="7469" class="Keyword">where</a> <a id="7475" class="Keyword">postulate</a> <a id="7485" href="/PLFA-zh/Lambda/#7485" class="Postulate">impossible</a> <a id="7496" class="Symbol">:</a> <a id="7498" href="https://agda.github.io/agda-stdlib/v0.17/Data.Empty.html#243" class="Datatype">⊥</a>

<a id="case′_[zero⇒_|suc_⇒_]"></a><a id="7501" href="/PLFA-zh/Lambda/#7501" class="Function Operator">case′_[zero⇒_|suc_⇒_]</a> <a id="7523" class="Symbol">:</a> <a id="7525" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="7530" class="Symbol">→</a> <a id="7532" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="7537" class="Symbol">→</a> <a id="7539" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="7544" class="Symbol">→</a> <a id="7546" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="7551" class="Symbol">→</a> <a id="7553" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
<a id="7558" href="/PLFA-zh/Lambda/#7501" class="Function Operator">case′</a> <a id="7564" href="/PLFA-zh/Lambda/#7564" class="Bound">L</a> <a id="7566" href="/PLFA-zh/Lambda/#7501" class="Function Operator">[zero⇒</a> <a id="7573" href="/PLFA-zh/Lambda/#7573" class="Bound">M</a> <a id="7575" href="/PLFA-zh/Lambda/#7501" class="Function Operator">|suc</a> <a id="7580" class="Symbol">(</a><a id="7581" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="7583" href="/PLFA-zh/Lambda/#7583" class="Bound">x</a><a id="7584" class="Symbol">)</a> <a id="7586" href="/PLFA-zh/Lambda/#7501" class="Function Operator">⇒</a> <a id="7588" href="/PLFA-zh/Lambda/#7588" class="Bound">N</a> <a id="7590" href="/PLFA-zh/Lambda/#7501" class="Function Operator">]</a>  <a id="7593" class="Symbol">=</a>  <a id="7596" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="7601" href="/PLFA-zh/Lambda/#7564" class="Bound">L</a> <a id="7603" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="7610" href="/PLFA-zh/Lambda/#7573" class="Bound">M</a> <a id="7612" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="7617" href="/PLFA-zh/Lambda/#7583" class="Bound">x</a> <a id="7619" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="7621" href="/PLFA-zh/Lambda/#7588" class="Bound">N</a> <a id="7623" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a>
<a id="7625" href="/PLFA-zh/Lambda/#7501" class="CatchallClause Function Operator">case′</a><a id="7630" class="CatchallClause"> </a><a id="7631" class="CatchallClause Symbol">_</a><a id="7632" class="CatchallClause"> </a><a id="7633" href="/PLFA-zh/Lambda/#7501" class="CatchallClause Function Operator">[zero⇒</a><a id="7639" class="CatchallClause"> </a><a id="7640" class="CatchallClause Symbol">_</a><a id="7641" class="CatchallClause"> </a><a id="7642" href="/PLFA-zh/Lambda/#7501" class="CatchallClause Function Operator">|suc</a><a id="7646" class="CatchallClause"> </a><a id="7647" class="CatchallClause Symbol">_</a><a id="7648" class="CatchallClause"> </a><a id="7649" href="/PLFA-zh/Lambda/#7501" class="CatchallClause Function Operator">⇒</a><a id="7650" class="CatchallClause"> </a><a id="7651" class="CatchallClause Symbol">_</a><a id="7652" class="CatchallClause"> </a><a id="7653" href="/PLFA-zh/Lambda/#7501" class="CatchallClause Function Operator">]</a>      <a id="7660" class="Symbol">=</a>  <a id="7663" href="https://agda.github.io/agda-stdlib/v0.17/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="7670" href="/PLFA-zh/Lambda/#7699" class="Postulate">impossible</a>
  <a id="7683" class="Keyword">where</a> <a id="7689" class="Keyword">postulate</a> <a id="7699" href="/PLFA-zh/Lambda/#7699" class="Postulate">impossible</a> <a id="7710" class="Symbol">:</a> <a id="7712" href="https://agda.github.io/agda-stdlib/v0.17/Data.Empty.html#243" class="Datatype">⊥</a>

<a id="μ′_⇒_"></a><a id="7715" href="/PLFA-zh/Lambda/#7715" class="Function Operator">μ′_⇒_</a> <a id="7721" class="Symbol">:</a> <a id="7723" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="7728" class="Symbol">→</a> <a id="7730" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="7735" class="Symbol">→</a> <a id="7737" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
<a id="7742" href="/PLFA-zh/Lambda/#7715" class="Function Operator">μ′</a> <a id="7745" class="Symbol">(</a><a id="7746" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="7748" href="/PLFA-zh/Lambda/#7748" class="Bound">x</a><a id="7749" class="Symbol">)</a> <a id="7751" href="/PLFA-zh/Lambda/#7715" class="Function Operator">⇒</a> <a id="7753" href="/PLFA-zh/Lambda/#7753" class="Bound">N</a>  <a id="7756" class="Symbol">=</a>  <a id="7759" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">μ</a> <a id="7761" href="/PLFA-zh/Lambda/#7748" class="Bound">x</a> <a id="7763" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">⇒</a> <a id="7765" href="/PLFA-zh/Lambda/#7753" class="Bound">N</a>
<a id="7767" href="/PLFA-zh/Lambda/#7715" class="CatchallClause Function Operator">μ′</a><a id="7769" class="CatchallClause"> </a><a id="7770" class="CatchallClause Symbol">_</a><a id="7771" class="CatchallClause"> </a><a id="7772" href="/PLFA-zh/Lambda/#7715" class="CatchallClause Function Operator">⇒</a><a id="7773" class="CatchallClause"> </a><a id="7774" class="CatchallClause Symbol">_</a>      <a id="7781" class="Symbol">=</a>  <a id="7784" href="https://agda.github.io/agda-stdlib/v0.17/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="7791" href="/PLFA-zh/Lambda/#7820" class="Postulate">impossible</a>
  <a id="7804" class="Keyword">where</a> <a id="7810" class="Keyword">postulate</a> <a id="7820" href="/PLFA-zh/Lambda/#7820" class="Postulate">impossible</a> <a id="7831" class="Symbol">:</a> <a id="7833" href="https://agda.github.io/agda-stdlib/v0.17/Data.Empty.html#243" class="Datatype">⊥</a></pre>
<p>The definition of <code class="highlighter-rouge">plus</code> can now be written as follows:</p>
<pre class="Agda"><a id="plus′"></a><a id="7915" href="/PLFA-zh/Lambda/#7915" class="Function">plus′</a> <a id="7921" class="Symbol">:</a> <a id="7923" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
<a id="7928" href="/PLFA-zh/Lambda/#7915" class="Function">plus′</a> <a id="7934" class="Symbol">=</a> <a id="7936" href="/PLFA-zh/Lambda/#7715" class="Function Operator">μ′</a> <a id="7939" href="/PLFA-zh/Lambda/#8046" class="Function">+</a> <a id="7941" href="/PLFA-zh/Lambda/#7715" class="Function Operator">⇒</a> <a id="7943" href="/PLFA-zh/Lambda/#7380" class="Function Operator">ƛ′</a> <a id="7946" href="/PLFA-zh/Lambda/#8060" class="Function">m</a> <a id="7948" href="/PLFA-zh/Lambda/#7380" class="Function Operator">⇒</a> <a id="7950" href="/PLFA-zh/Lambda/#7380" class="Function Operator">ƛ′</a> <a id="7953" href="/PLFA-zh/Lambda/#8074" class="Function">n</a> <a id="7955" href="/PLFA-zh/Lambda/#7380" class="Function Operator">⇒</a>
          <a id="7967" href="/PLFA-zh/Lambda/#7501" class="Function Operator">case′</a> <a id="7973" href="/PLFA-zh/Lambda/#8060" class="Function">m</a>
            <a id="7987" href="/PLFA-zh/Lambda/#7501" class="Function Operator">[zero⇒</a> <a id="7994" href="/PLFA-zh/Lambda/#8074" class="Function">n</a>
            <a id="8008" href="/PLFA-zh/Lambda/#7501" class="Function Operator">|suc</a> <a id="8013" href="/PLFA-zh/Lambda/#8060" class="Function">m</a> <a id="8015" href="/PLFA-zh/Lambda/#7501" class="Function Operator">⇒</a> <a id="8017" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="8022" class="Symbol">(</a><a id="8023" href="/PLFA-zh/Lambda/#8046" class="Function">+</a> <a id="8025" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="8027" href="/PLFA-zh/Lambda/#8060" class="Function">m</a> <a id="8029" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="8031" href="/PLFA-zh/Lambda/#8074" class="Function">n</a><a id="8032" class="Symbol">)</a> <a id="8034" href="/PLFA-zh/Lambda/#7501" class="Function Operator">]</a>
  <a id="8038" class="Keyword">where</a>
  <a id="8046" href="/PLFA-zh/Lambda/#8046" class="Function">+</a>  <a id="8049" class="Symbol">=</a>  <a id="8052" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="8054" class="String">&quot;+&quot;</a>
  <a id="8060" href="/PLFA-zh/Lambda/#8060" class="Function">m</a>  <a id="8063" class="Symbol">=</a>  <a id="8066" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="8068" class="String">&quot;m&quot;</a>
  <a id="8074" href="/PLFA-zh/Lambda/#8074" class="Function">n</a>  <a id="8077" class="Symbol">=</a>  <a id="8080" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="8082" class="String">&quot;n&quot;</a></pre>
<p>Write out the definition of multiplication in the same style.</p>

<h3 id="formal-vs-informal">Formal vs informal</h3>

<p>In informal presentation of formal semantics, one uses choice of
variable name to disambiguate and writes <code class="highlighter-rouge">x</code> rather than <code class="highlighter-rouge">` x</code>
for a term that is a variable. Agda requires we distinguish.</p>

<p>Similarly, informal presentation often use the same notation for
function types, lambda abstraction, and function application in both
the <em>object language</em> (the language one is describing) and the
<em>meta-language</em> (the language in which the description is written),
trusting readers can use context to distinguish the two.  Agda is
not quite so forgiving, so here we use <code class="highlighter-rouge">ƛ x ⇒ N</code> and <code class="highlighter-rouge">L · M</code> for the
object language, as compared to <code class="highlighter-rouge">λ x → N</code> and <code class="highlighter-rouge">L M</code> in our
meta-language, Agda.</p>

<h3 id="bound-and-free-variables">Bound and free variables</h3>

<p>In an abstraction <code class="highlighter-rouge">ƛ x ⇒ N</code> we call <code class="highlighter-rouge">x</code> the <em>bound</em> variable
and <code class="highlighter-rouge">N</code> the <em>body</em> of the abstraction.  A central feature
of lambda calculus is that consistent renaming of bound variables
leaves the meaning of a term unchanged.  Thus the five terms</p>

<ul>
  <li><code class="highlighter-rouge">ƛ "s" ⇒ ƛ "z" ⇒ ` "s" · (` "s" · ` "z")</code></li>
  <li><code class="highlighter-rouge">ƛ "f" ⇒ ƛ "x" ⇒ ` "f" · (` "f" · ` "x")</code></li>
  <li><code class="highlighter-rouge">ƛ "sam" ⇒ ƛ "zelda" ⇒ ` "sam" · (` "sam" · ` "zelda")</code></li>
  <li><code class="highlighter-rouge">ƛ "z" ⇒ ƛ "s" ⇒ ` "z" · (` "z" · ` "s")</code></li>
  <li><code class="highlighter-rouge">ƛ "😇" ⇒ ƛ "😈" ⇒ ` "😇" · (` "😇" · ` "😈" )</code></li>
</ul>

<p>are all considered equivalent.  Following the convention introduced
by Haskell Curry, who used the Greek letter <code class="highlighter-rouge">α</code> (<em>alpha</em>) to label such rules,
this equivalence relation is called <em>alpha renaming</em>.</p>

<p>As we descend from a term into its subterms, variables
that are bound may become free.  Consider the following terms:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">ƛ "s" ⇒ ƛ "z" ⇒ ` "s" · (` "s" · ` "z")</code>
has both <code class="highlighter-rouge">s</code> and <code class="highlighter-rouge">z</code> as bound variables.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ƛ "z" ⇒ ` "s" · (` "s" · ` "z")</code>
has <code class="highlighter-rouge">z</code> bound and <code class="highlighter-rouge">s</code> free.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">` "s" · (` "s" · ` "z")</code>
has both <code class="highlighter-rouge">s</code> and <code class="highlighter-rouge">z</code> as free variables.</p>
  </li>
</ul>

<p>We say that a term with no free variables is <em>closed</em>; otherwise it is
<em>open</em>.  Of the three terms above, the first is closed and the other
two are open.  We will focus on reduction of closed terms.</p>

<p>Different occurrences of a variable may be bound and free.
In the term</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ƛ "x" ⇒ ` "x") · ` "x"
</code></pre></div></div>

<p>the inner occurrence of <code class="highlighter-rouge">x</code> is bound while the outer occurrence is free.
By alpha renaming, the term above is equivalent to</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ƛ "y" ⇒ ` "y") · ` "x"
</code></pre></div></div>

<p>in which <code class="highlighter-rouge">y</code> is bound and <code class="highlighter-rouge">x</code> is free.  A common convention, called the
<em>Barendregt convention</em>, is to use alpha renaming to ensure that the bound
variables in a term are distinct from the free variables, which can
avoid confusions that may arise if bound and free variables have the
same names.</p>

<p>Case and recursion also introduce bound variables, which are also subject
to alpha renaming. In the term</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>μ "+" ⇒ ƛ "m" ⇒ ƛ "n" ⇒
  case ` "m"
    [zero⇒ ` "n"
    |suc "m" ⇒ `suc (` "+" · ` "m" · ` "n") ]
</code></pre></div></div>

<p>notice that there are two binding occurrences of <code class="highlighter-rouge">m</code>, one in the first
line and one in the last line.  It is equivalent to the following term,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>μ "plus" ⇒ ƛ "x" ⇒ ƛ "y" ⇒
  case ` "x"
    [zero⇒ ` "y"
    |suc "x′" ⇒ `suc (` "plus" · ` "x′" · ` "y") ]
</code></pre></div></div>

<p>where the two binding occurrences corresponding to <code class="highlighter-rouge">m</code> now have distinct
names, <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">x′</code>.</p>

<h2 id="values">Values</h2>

<p>A <em>value</em> is a term that corresponds to an answer.
Thus, <code class="highlighter-rouge">`suc `suc `suc `suc `zero</code> is a value,
while <code class="highlighter-rouge">plus · two · two</code> is not.
Following convention, we treat all function abstractions
as values; thus, <code class="highlighter-rouge">plus</code> by itself is considered a value.</p>

<p>The predicate <code class="highlighter-rouge">Value M</code> holds if term <code class="highlighter-rouge">M</code> is a value:</p>

<pre class="Agda"><a id="11629" class="Keyword">data</a> <a id="Value"></a><a id="11634" href="/PLFA-zh/Lambda/#11634" class="Datatype">Value</a> <a id="11640" class="Symbol">:</a> <a id="11642" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="11647" class="Symbol">→</a> <a id="11649" class="PrimitiveType">Set</a> <a id="11653" class="Keyword">where</a>

  <a id="Value.V-ƛ"></a><a id="11662" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-ƛ</a> <a id="11666" class="Symbol">:</a> <a id="11668" class="Symbol">∀</a> <a id="11670" class="Symbol">{</a><a id="11671" href="/PLFA-zh/Lambda/#11671" class="Bound">x</a> <a id="11673" href="/PLFA-zh/Lambda/#11673" class="Bound">N</a><a id="11674" class="Symbol">}</a>
      <a id="11682" class="Comment">---------------</a>
    <a id="11702" class="Symbol">→</a> <a id="11704" href="/PLFA-zh/Lambda/#11634" class="Datatype">Value</a> <a id="11710" class="Symbol">(</a><a id="11711" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="11713" href="/PLFA-zh/Lambda/#11671" class="Bound">x</a> <a id="11715" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="11717" href="/PLFA-zh/Lambda/#11673" class="Bound">N</a><a id="11718" class="Symbol">)</a>

  <a id="Value.V-zero"></a><a id="11723" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a> <a id="11730" class="Symbol">:</a>
      <a id="11738" class="Comment">-----------</a>
      <a id="11756" href="/PLFA-zh/Lambda/#11634" class="Datatype">Value</a> <a id="11762" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a>

  <a id="Value.V-suc"></a><a id="11771" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="11777" class="Symbol">:</a> <a id="11779" class="Symbol">∀</a> <a id="11781" class="Symbol">{</a><a id="11782" href="/PLFA-zh/Lambda/#11782" class="Bound">V</a><a id="11783" class="Symbol">}</a>
    <a id="11789" class="Symbol">→</a> <a id="11791" href="/PLFA-zh/Lambda/#11634" class="Datatype">Value</a> <a id="11797" href="/PLFA-zh/Lambda/#11782" class="Bound">V</a>
      <a id="11805" class="Comment">--------------</a>
    <a id="11824" class="Symbol">→</a> <a id="11826" href="/PLFA-zh/Lambda/#11634" class="Datatype">Value</a> <a id="11832" class="Symbol">(</a><a id="11833" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="11838" href="/PLFA-zh/Lambda/#11782" class="Bound">V</a><a id="11839" class="Symbol">)</a></pre>

<p>In what follows, we let <code class="highlighter-rouge">V</code> and <code class="highlighter-rouge">W</code> range over values.</p>

<h3 id="formal-vs-informal-1">Formal vs informal</h3>

<p>In informal presentations of formal semantics, using
<code class="highlighter-rouge">V</code> as the name of a metavariable is sufficient to
indicate that it is a value. In Agda, we must explicitly
invoke the <code class="highlighter-rouge">Value</code> predicate.</p>

<h3 id="other-approaches">Other approaches</h3>

<p>An alternative is not to focus on closed terms,
to treat variables as values, and to treat
<code class="highlighter-rouge">ƛ x ⇒ N</code> as a value only if <code class="highlighter-rouge">N</code> is a value.
Indeed, this is how Agda normalises terms.
We consider this approach in
Chapter <a href="/PLFA-zh/Untyped/">Untyped</a>.</p>

<h2 id="substitution">Substitution</h2>

<p>The heart of lambda calculus is the operation of
substituting one term for a variable in another term.
Substitution plays a key role in defining the
operational semantics of function application.
For instance, we have</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (ƛ "s" ⇒ ƛ "z" ⇒ ` "s" · (` "s" · ` "z")) · sucᶜ · `zero
—→
  (ƛ "z" ⇒ sucᶜ · (sucᶜ · "z")) · `zero
—→
  sucᶜ · (sucᶜ · `zero)
</code></pre></div></div>

<p>where we substitute <code class="highlighter-rouge">sucᶜ</code> for <code class="highlighter-rouge">` "s"</code> and <code class="highlighter-rouge">`zero</code> for <code class="highlighter-rouge">` "z"</code>
in the body of the function abstraction.</p>

<p>We write substitution as <code class="highlighter-rouge">N [ x := V ]</code>, meaning
“substitute term <code class="highlighter-rouge">V</code> for free occurrences of variable <code class="highlighter-rouge">x</code> in term <code class="highlighter-rouge">N</code>”,
or, more compactly, “substitute <code class="highlighter-rouge">V</code> for <code class="highlighter-rouge">x</code> in <code class="highlighter-rouge">N</code>”,
or equivalently, “in <code class="highlighter-rouge">N</code> replace <code class="highlighter-rouge">x</code> by <code class="highlighter-rouge">V</code>”.
Substitution works if <code class="highlighter-rouge">V</code> is any closed term;
it need not be a value, but we use <code class="highlighter-rouge">V</code> since in fact we
usually substitute values.</p>

<p>Here are some examples:</p>

<ul>
  <li><code class="highlighter-rouge">(ƛ "z" ⇒ ` "s" · (` "s" · ` "z")) [ "s" := sucᶜ ]</code> yields
<code class="highlighter-rouge">ƛ "z" ⇒ sucᶜ · (sucᶜ · ` "z")</code>.</li>
  <li><code class="highlighter-rouge">(sucᶜ · (sucᶜ · ` "z")) [ "z" := `zero ]</code> yields
<code class="highlighter-rouge">sucᶜ · (sucᶜ · `zero)</code>.</li>
  <li><code class="highlighter-rouge">(ƛ "x" ⇒ ` "y") [ "y" := `zero ]</code> yields <code class="highlighter-rouge">ƛ "x" ⇒ `zero</code>.</li>
  <li><code class="highlighter-rouge">(ƛ "x" ⇒ ` "x") [ "x" := `zero ]</code> yields <code class="highlighter-rouge">ƛ "x" ⇒ ` "x"</code>.</li>
  <li><code class="highlighter-rouge">(ƛ "y" ⇒ ` "y") [ "x" := `zero ]</code> yields <code class="highlighter-rouge">ƛ "y" ⇒ ` "y"</code>.</li>
</ul>

<p>In the last but one example, substituting <code class="highlighter-rouge">`zero</code> for <code class="highlighter-rouge">x</code> in
<code class="highlighter-rouge">ƛ "x" ⇒ ` "x"</code> does <em>not</em> yield <code class="highlighter-rouge">ƛ "x" ⇒ `zero</code>,
since <code class="highlighter-rouge">x</code> is bound in the lambda abstraction.
The choice of bound names is irrelevant: both
<code class="highlighter-rouge">ƛ "x" ⇒ ` "x"</code> and <code class="highlighter-rouge">ƛ "y" ⇒ ` "y"</code> stand for the
identity function.  One way to think of this is that <code class="highlighter-rouge">x</code> within
the body of the abstraction stands for a <em>different</em> variable than
<code class="highlighter-rouge">x</code> outside the abstraction, they just happen to have the same name.</p>

<p>We will give a definition of substitution that is only valid
when term substituted for the variable is closed. This is because
substitution by terms that are <em>not</em> closed may require renaming
of bound variables. For example:</p>

<ul>
  <li><code class="highlighter-rouge">(ƛ "x" ⇒ ` "x" · ` "y") [ "y" := ` "x" · `zero]</code> should not yield <br />
<code class="highlighter-rouge">(ƛ "x" ⇒ ` "x" · (` "x" · `zero))</code>.</li>
</ul>

<p>Instead, we should rename the bound variable to avoid capture:</p>

<ul>
  <li><code class="highlighter-rouge">(ƛ "x" ⇒ ` "x" · ` "y") [ "y" := ` "x" · `zero ]</code> should yield <br />
<code class="highlighter-rouge">ƛ "x′" ⇒ ` "x′" · (` "x" · `zero)</code>.</li>
</ul>

<p>Here <code class="highlighter-rouge">x′</code> is a fresh variable distinct from <code class="highlighter-rouge">x</code>.
Formal definition of substitution with suitable renaming is considerably
more complex, so we avoid it by restricting to substitution by closed terms,
which will be adequate for our purposes.</p>

<p>Here is the formal definition of substitution by closed terms in Agda:</p>

<pre class="Agda"><a id="15001" class="Keyword">infix</a> <a id="15007" class="Number">9</a> <a id="15009" href="/PLFA-zh/Lambda/#15018" class="Function Operator">_[_:=_]</a>

<a id="_[_:=_]"></a><a id="15018" href="/PLFA-zh/Lambda/#15018" class="Function Operator">_[_:=_]</a> <a id="15026" class="Symbol">:</a> <a id="15028" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="15033" class="Symbol">→</a> <a id="15035" href="/PLFA-zh/Lambda/#3744" class="Function">Id</a> <a id="15038" class="Symbol">→</a> <a id="15040" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="15045" class="Symbol">→</a> <a id="15047" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a>
<a id="15052" class="Symbol">(</a><a id="15053" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="15055" href="/PLFA-zh/Lambda/#15055" class="Bound">x</a><a id="15056" class="Symbol">)</a> <a id="15058" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15060" href="/PLFA-zh/Lambda/#15060" class="Bound">y</a> <a id="15062" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15065" href="/PLFA-zh/Lambda/#15065" class="Bound">V</a> <a id="15067" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a> <a id="15069" class="Keyword">with</a> <a id="15074" href="/PLFA-zh/Lambda/#15055" class="Bound">x</a> <a id="15076" href="https://agda.github.io/agda-stdlib/v0.17/Data.String.Unsafe.html#749" class="Function Operator">≟</a> <a id="15078" href="/PLFA-zh/Lambda/#15060" class="Bound">y</a>
<a id="15080" class="Symbol">...</a> <a id="15084" class="Symbol">|</a> <a id="15086" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="15090" class="Symbol">_</a>          <a id="15101" class="Symbol">=</a>  <a id="15104" class="Bound">V</a>
<a id="15106" class="Symbol">...</a> <a id="15110" class="Symbol">|</a> <a id="15112" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="15116" class="Symbol">_</a>          <a id="15127" class="Symbol">=</a>  <a id="15130" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="15132" class="Bound">x</a>
<a id="15134" class="Symbol">(</a><a id="15135" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="15137" href="/PLFA-zh/Lambda/#15137" class="Bound">x</a> <a id="15139" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="15141" href="/PLFA-zh/Lambda/#15141" class="Bound">N</a><a id="15142" class="Symbol">)</a> <a id="15144" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15146" href="/PLFA-zh/Lambda/#15146" class="Bound">y</a> <a id="15148" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15151" href="/PLFA-zh/Lambda/#15151" class="Bound">V</a> <a id="15153" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a> <a id="15155" class="Keyword">with</a> <a id="15160" href="/PLFA-zh/Lambda/#15137" class="Bound">x</a> <a id="15162" href="https://agda.github.io/agda-stdlib/v0.17/Data.String.Unsafe.html#749" class="Function Operator">≟</a> <a id="15164" href="/PLFA-zh/Lambda/#15146" class="Bound">y</a>
<a id="15166" class="Symbol">...</a> <a id="15170" class="Symbol">|</a> <a id="15172" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="15176" class="Symbol">_</a>          <a id="15187" class="Symbol">=</a>  <a id="15190" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="15192" class="Bound">x</a> <a id="15194" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="15196" class="Bound">N</a>
<a id="15198" class="Symbol">...</a> <a id="15202" class="Symbol">|</a> <a id="15204" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="15208" class="Symbol">_</a>          <a id="15219" class="Symbol">=</a>  <a id="15222" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="15224" class="Bound">x</a> <a id="15226" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="15228" class="Bound">N</a> <a id="15230" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15232" class="Bound">y</a> <a id="15234" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15237" class="Bound">V</a> <a id="15239" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a>
<a id="15241" class="Symbol">(</a><a id="15242" href="/PLFA-zh/Lambda/#15242" class="Bound">L</a> <a id="15244" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="15246" href="/PLFA-zh/Lambda/#15246" class="Bound">M</a><a id="15247" class="Symbol">)</a> <a id="15249" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15251" href="/PLFA-zh/Lambda/#15251" class="Bound">y</a> <a id="15253" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15256" href="/PLFA-zh/Lambda/#15256" class="Bound">V</a> <a id="15258" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a>   <a id="15262" class="Symbol">=</a>  <a id="15265" href="/PLFA-zh/Lambda/#15242" class="Bound">L</a> <a id="15267" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15269" href="/PLFA-zh/Lambda/#15251" class="Bound">y</a> <a id="15271" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15274" href="/PLFA-zh/Lambda/#15256" class="Bound">V</a> <a id="15276" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a> <a id="15278" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="15280" href="/PLFA-zh/Lambda/#15246" class="Bound">M</a> <a id="15282" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15284" href="/PLFA-zh/Lambda/#15251" class="Bound">y</a> <a id="15286" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15289" href="/PLFA-zh/Lambda/#15256" class="Bound">V</a> <a id="15291" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a>
<a id="15293" class="Symbol">(</a><a id="15294" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a><a id="15299" class="Symbol">)</a> <a id="15301" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15303" href="/PLFA-zh/Lambda/#15303" class="Bound">y</a> <a id="15305" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15308" href="/PLFA-zh/Lambda/#15308" class="Bound">V</a> <a id="15310" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a>   <a id="15314" class="Symbol">=</a>  <a id="15317" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a>
<a id="15323" class="Symbol">(</a><a id="15324" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="15329" href="/PLFA-zh/Lambda/#15329" class="Bound">M</a><a id="15330" class="Symbol">)</a> <a id="15332" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15334" href="/PLFA-zh/Lambda/#15334" class="Bound">y</a> <a id="15336" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15339" href="/PLFA-zh/Lambda/#15339" class="Bound">V</a> <a id="15341" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a>  <a id="15344" class="Symbol">=</a>  <a id="15347" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="15352" href="/PLFA-zh/Lambda/#15329" class="Bound">M</a> <a id="15354" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15356" href="/PLFA-zh/Lambda/#15334" class="Bound">y</a> <a id="15358" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15361" href="/PLFA-zh/Lambda/#15339" class="Bound">V</a> <a id="15363" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a>
<a id="15365" class="Symbol">(</a><a id="15366" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="15371" href="/PLFA-zh/Lambda/#15371" class="Bound">L</a> <a id="15373" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="15380" href="/PLFA-zh/Lambda/#15380" class="Bound">M</a> <a id="15382" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="15387" href="/PLFA-zh/Lambda/#15387" class="Bound">x</a> <a id="15389" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="15391" href="/PLFA-zh/Lambda/#15391" class="Bound">N</a> <a id="15393" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a><a id="15394" class="Symbol">)</a> <a id="15396" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15398" href="/PLFA-zh/Lambda/#15398" class="Bound">y</a> <a id="15400" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15403" href="/PLFA-zh/Lambda/#15403" class="Bound">V</a> <a id="15405" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a> <a id="15407" class="Keyword">with</a> <a id="15412" href="/PLFA-zh/Lambda/#15387" class="Bound">x</a> <a id="15414" href="https://agda.github.io/agda-stdlib/v0.17/Data.String.Unsafe.html#749" class="Function Operator">≟</a> <a id="15416" href="/PLFA-zh/Lambda/#15398" class="Bound">y</a>
<a id="15418" class="Symbol">...</a> <a id="15422" class="Symbol">|</a> <a id="15424" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="15428" class="Symbol">_</a>          <a id="15439" class="Symbol">=</a>  <a id="15442" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="15447" class="Bound">L</a> <a id="15449" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15451" class="Bound">y</a> <a id="15453" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15456" class="Bound">V</a> <a id="15458" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a> <a id="15460" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="15467" class="Bound">M</a> <a id="15469" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15471" class="Bound">y</a> <a id="15473" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15476" class="Bound">V</a> <a id="15478" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a> <a id="15480" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="15485" class="Bound">x</a> <a id="15487" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="15489" class="Bound">N</a> <a id="15491" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a>
<a id="15493" class="Symbol">...</a> <a id="15497" class="Symbol">|</a> <a id="15499" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="15503" class="Symbol">_</a>          <a id="15514" class="Symbol">=</a>  <a id="15517" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="15522" class="Bound">L</a> <a id="15524" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15526" class="Bound">y</a> <a id="15528" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15531" class="Bound">V</a> <a id="15533" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a> <a id="15535" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="15542" class="Bound">M</a> <a id="15544" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15546" class="Bound">y</a> <a id="15548" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15551" class="Bound">V</a> <a id="15553" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a> <a id="15555" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="15560" class="Bound">x</a> <a id="15562" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="15564" class="Bound">N</a> <a id="15566" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15568" class="Bound">y</a> <a id="15570" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15573" class="Bound">V</a> <a id="15575" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a> <a id="15577" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a>
<a id="15579" class="Symbol">(</a><a id="15580" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">μ</a> <a id="15582" href="/PLFA-zh/Lambda/#15582" class="Bound">x</a> <a id="15584" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">⇒</a> <a id="15586" href="/PLFA-zh/Lambda/#15586" class="Bound">N</a><a id="15587" class="Symbol">)</a> <a id="15589" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15591" href="/PLFA-zh/Lambda/#15591" class="Bound">y</a> <a id="15593" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15596" href="/PLFA-zh/Lambda/#15596" class="Bound">V</a> <a id="15598" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a> <a id="15600" class="Keyword">with</a> <a id="15605" href="/PLFA-zh/Lambda/#15582" class="Bound">x</a> <a id="15607" href="https://agda.github.io/agda-stdlib/v0.17/Data.String.Unsafe.html#749" class="Function Operator">≟</a> <a id="15609" href="/PLFA-zh/Lambda/#15591" class="Bound">y</a>
<a id="15611" class="Symbol">...</a> <a id="15615" class="Symbol">|</a> <a id="15617" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="15621" class="Symbol">_</a>          <a id="15632" class="Symbol">=</a>  <a id="15635" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">μ</a> <a id="15637" class="Bound">x</a> <a id="15639" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">⇒</a> <a id="15641" class="Bound">N</a>
<a id="15643" class="Symbol">...</a> <a id="15647" class="Symbol">|</a> <a id="15649" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="15653" class="Symbol">_</a>          <a id="15664" class="Symbol">=</a>  <a id="15667" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">μ</a> <a id="15669" class="Bound">x</a> <a id="15671" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">⇒</a> <a id="15673" class="Bound">N</a> <a id="15675" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="15677" class="Bound">y</a> <a id="15679" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="15682" class="Bound">V</a> <a id="15684" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a></pre>

<p>Let’s unpack the first three cases:</p>

<ul>
  <li>
    <p>For variables, we compare <code class="highlighter-rouge">y</code>, the substituted variable,
with <code class="highlighter-rouge">x</code>, the variable in the term. If they are the same,
we yield <code class="highlighter-rouge">V</code>, otherwise we yield <code class="highlighter-rouge">x</code> unchanged.</p>
  </li>
  <li>
    <p>For abstractions, we compare <code class="highlighter-rouge">y</code>, the substituted variable,
with <code class="highlighter-rouge">x</code>, the variable bound in the abstraction. If they are the same,
we yield the abstraction unchanged, otherwise we substitute inside the body.</p>
  </li>
  <li>
    <p>For application, we recursively substitute in the function
and the argument.</p>
  </li>
</ul>

<p>Case expressions and recursion also have bound variables that are
treated similarly to those in lambda abstractions.  Otherwise we
simply push substitution recursively into the subterms.</p>

<h3 id="examples">Examples</h3>

<p>Here is confirmation that the examples above are correct:</p>

<pre class="Agda"><a id="16467" href="/PLFA-zh/Lambda/#16467" class="Function">_</a> <a id="16469" class="Symbol">:</a> <a id="16471" class="Symbol">(</a><a id="16472" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="16474" class="String">&quot;z&quot;</a> <a id="16478" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="16480" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="16482" class="String">&quot;s&quot;</a> <a id="16486" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="16488" class="Symbol">(</a><a id="16489" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="16491" class="String">&quot;s&quot;</a> <a id="16495" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="16497" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="16499" class="String">&quot;z&quot;</a><a id="16502" class="Symbol">))</a> <a id="16505" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="16507" class="String">&quot;s&quot;</a> <a id="16511" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="16514" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="16519" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a> <a id="16521" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="16523" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="16525" class="String">&quot;z&quot;</a> <a id="16529" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="16531" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="16536" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="16538" class="Symbol">(</a><a id="16539" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="16544" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="16546" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="16548" class="String">&quot;z&quot;</a><a id="16551" class="Symbol">)</a>
<a id="16553" class="Symbol">_</a> <a id="16555" class="Symbol">=</a> <a id="16557" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="16563" href="/PLFA-zh/Lambda/#16563" class="Function">_</a> <a id="16565" class="Symbol">:</a> <a id="16567" class="Symbol">(</a><a id="16568" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="16573" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="16575" class="Symbol">(</a><a id="16576" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="16581" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="16583" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="16585" class="String">&quot;z&quot;</a><a id="16588" class="Symbol">))</a> <a id="16591" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="16593" class="String">&quot;z&quot;</a> <a id="16597" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="16600" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="16606" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a> <a id="16608" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="16610" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="16615" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="16617" class="Symbol">(</a><a id="16618" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="16623" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="16625" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a><a id="16630" class="Symbol">)</a>
<a id="16632" class="Symbol">_</a> <a id="16634" class="Symbol">=</a> <a id="16636" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="16642" href="/PLFA-zh/Lambda/#16642" class="Function">_</a> <a id="16644" class="Symbol">:</a> <a id="16646" class="Symbol">(</a><a id="16647" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="16649" class="String">&quot;x&quot;</a> <a id="16653" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="16655" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="16657" class="String">&quot;y&quot;</a><a id="16660" class="Symbol">)</a> <a id="16662" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="16664" class="String">&quot;y&quot;</a> <a id="16668" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="16671" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="16677" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a> <a id="16679" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="16681" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="16683" class="String">&quot;x&quot;</a> <a id="16687" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="16689" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a>
<a id="16695" class="Symbol">_</a> <a id="16697" class="Symbol">=</a> <a id="16699" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="16705" href="/PLFA-zh/Lambda/#16705" class="Function">_</a> <a id="16707" class="Symbol">:</a> <a id="16709" class="Symbol">(</a><a id="16710" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="16712" class="String">&quot;x&quot;</a> <a id="16716" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="16718" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="16720" class="String">&quot;x&quot;</a><a id="16723" class="Symbol">)</a> <a id="16725" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="16727" class="String">&quot;x&quot;</a> <a id="16731" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="16734" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="16740" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a> <a id="16742" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="16744" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="16746" class="String">&quot;x&quot;</a> <a id="16750" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="16752" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="16754" class="String">&quot;x&quot;</a>
<a id="16758" class="Symbol">_</a> <a id="16760" class="Symbol">=</a> <a id="16762" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="16768" href="/PLFA-zh/Lambda/#16768" class="Function">_</a> <a id="16770" class="Symbol">:</a> <a id="16772" class="Symbol">(</a><a id="16773" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="16775" class="String">&quot;y&quot;</a> <a id="16779" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="16781" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="16783" class="String">&quot;y&quot;</a><a id="16786" class="Symbol">)</a> <a id="16788" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="16790" class="String">&quot;x&quot;</a> <a id="16794" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="16797" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="16803" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a> <a id="16805" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="16807" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="16809" class="String">&quot;y&quot;</a> <a id="16813" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="16815" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="16817" class="String">&quot;y&quot;</a>
<a id="16821" class="Symbol">_</a> <a id="16823" class="Symbol">=</a> <a id="16825" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<h4 id="quiz">Quiz</h4>

<p>What is the result of the following substitution?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ƛ "y" ⇒ ` "x" · (ƛ "x" ⇒ ` "x")) [ "x" := `zero ]
</code></pre></div></div>

<ol>
  <li><code class="highlighter-rouge">(ƛ "y" ⇒ ` "x" · (ƛ "x" ⇒ ` "x"))</code></li>
  <li><code class="highlighter-rouge">(ƛ "y" ⇒ ` "x" · (ƛ "x" ⇒ `zero))</code></li>
  <li><code class="highlighter-rouge">(ƛ "y" ⇒ `zero · (ƛ "x" ⇒ ` "x"))</code></li>
  <li><code class="highlighter-rouge">(ƛ "y" ⇒ `zero · (ƛ "x" ⇒ `zero))</code></li>
</ol>

<h4 id="exercise-___-stretch">Exercise <code class="highlighter-rouge">_[_:=_]′</code> (stretch)</h4>

<p>The definition of substitution above has three clauses (<code class="highlighter-rouge">ƛ</code>, <code class="highlighter-rouge">case</code>,
and <code class="highlighter-rouge">μ</code>) that invoke a <code class="highlighter-rouge">with</code> clause to deal with bound variables.
Rewrite the definition to factor the common part of these three
clauses into a single function, defined by mutual recursion with
substitution.</p>

<h2 id="reduction">Reduction</h2>

<p>We give the reduction rules for call-by-value lambda calculus.  To
reduce an application, first we reduce the left-hand side until it
becomes a value (which must be an abstraction); then we reduce the
right-hand side until it becomes a value; and finally we substitute
the argument for the variable in the abstraction.</p>

<p>In an informal presentation of the operational semantics,
the rules for reduction of applications are written as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L —→ L′
--------------- ξ-·₁
L · M —→ L′ · M

M —→ M′
--------------- ξ-·₂
V · M —→ V · M′

----------------------------- β-ƛ
(ƛ x ⇒ N) · V —→ N [ x := V ]
</code></pre></div></div>

<p>The Agda version of the rules below will be similar, except that universal
quantifications are made explicit, and so are the predicates that indicate
which terms are values.</p>

<p>The rules break into two sorts. Compatibility rules direct us to
reduce some part of a term.  We give them names starting with the
Greek letter <code class="highlighter-rouge">ξ</code> (<em>xi</em>).  Once a term is sufficiently reduced, it will
consist of a constructor and a deconstructor, in our case <code class="highlighter-rouge">ƛ</code> and <code class="highlighter-rouge">·</code>,
which reduces directly.  We give them names starting with the Greek
letter <code class="highlighter-rouge">β</code> (<em>beta</em>) and such rules are traditionally called <em>beta rules</em>.</p>

<p>A bit of terminology: A term that matches the left-hand side of a
reduction rule is called a <em>redex</em>. In the redex <code class="highlighter-rouge">(ƛ x ⇒ N) · V</code>, we
may refer to <code class="highlighter-rouge">x</code> as the <em>formal parameter</em> of the function, and <code class="highlighter-rouge">V</code>
as the <em>actual parameter</em> of the function application.  Beta reduction
replaces the formal parameter by the actual parameter.</p>

<p>If a term is a value, then no reduction applies; conversely,
if a reduction applies to a term then it is not a value.
We will show in the next chapter that for well-typed terms
this exhausts the possibilities: for every well-typed term
either a reduction applies or it is a value.</p>

<p>For numbers, zero does not reduce and successor reduces the subterm.
A case expression reduces its argument to a number, and then chooses
the zero or successor branch as appropriate.  A fixpoint replaces
the bound variable by the entire fixpoint term; this is the one
case where we substitute by a term that is not a value.</p>

<p>Here are the rules formalised in Agda:</p>

<pre class="Agda"><a id="19679" class="Keyword">infix</a> <a id="19685" class="Number">4</a> <a id="19687" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">_—→_</a>

<a id="19693" class="Keyword">data</a> <a id="_—→_"></a><a id="19698" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">_—→_</a> <a id="19703" class="Symbol">:</a> <a id="19705" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="19710" class="Symbol">→</a> <a id="19712" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="19717" class="Symbol">→</a> <a id="19719" class="PrimitiveType">Set</a> <a id="19723" class="Keyword">where</a>

  <a id="_—→_.ξ-·₁"></a><a id="19732" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="19737" class="Symbol">:</a> <a id="19739" class="Symbol">∀</a> <a id="19741" class="Symbol">{</a><a id="19742" href="/PLFA-zh/Lambda/#19742" class="Bound">L</a> <a id="19744" href="/PLFA-zh/Lambda/#19744" class="Bound">L′</a> <a id="19747" href="/PLFA-zh/Lambda/#19747" class="Bound">M</a><a id="19748" class="Symbol">}</a>
    <a id="19754" class="Symbol">→</a> <a id="19756" href="/PLFA-zh/Lambda/#19742" class="Bound">L</a> <a id="19758" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">—→</a> <a id="19761" href="/PLFA-zh/Lambda/#19744" class="Bound">L′</a>
      <a id="19770" class="Comment">-----------------</a>
    <a id="19792" class="Symbol">→</a> <a id="19794" href="/PLFA-zh/Lambda/#19742" class="Bound">L</a> <a id="19796" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="19798" href="/PLFA-zh/Lambda/#19747" class="Bound">M</a> <a id="19800" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">—→</a> <a id="19803" href="/PLFA-zh/Lambda/#19744" class="Bound">L′</a> <a id="19806" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="19808" href="/PLFA-zh/Lambda/#19747" class="Bound">M</a>

  <a id="_—→_.ξ-·₂"></a><a id="19813" href="/PLFA-zh/Lambda/#19813" class="InductiveConstructor">ξ-·₂</a> <a id="19818" class="Symbol">:</a> <a id="19820" class="Symbol">∀</a> <a id="19822" class="Symbol">{</a><a id="19823" href="/PLFA-zh/Lambda/#19823" class="Bound">V</a> <a id="19825" href="/PLFA-zh/Lambda/#19825" class="Bound">M</a> <a id="19827" href="/PLFA-zh/Lambda/#19827" class="Bound">M′</a><a id="19829" class="Symbol">}</a>
    <a id="19835" class="Symbol">→</a> <a id="19837" href="/PLFA-zh/Lambda/#11634" class="Datatype">Value</a> <a id="19843" href="/PLFA-zh/Lambda/#19823" class="Bound">V</a>
    <a id="19849" class="Symbol">→</a> <a id="19851" href="/PLFA-zh/Lambda/#19825" class="Bound">M</a> <a id="19853" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">—→</a> <a id="19856" href="/PLFA-zh/Lambda/#19827" class="Bound">M′</a>
      <a id="19865" class="Comment">-----------------</a>
    <a id="19887" class="Symbol">→</a> <a id="19889" href="/PLFA-zh/Lambda/#19823" class="Bound">V</a> <a id="19891" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="19893" href="/PLFA-zh/Lambda/#19825" class="Bound">M</a> <a id="19895" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">—→</a> <a id="19898" href="/PLFA-zh/Lambda/#19823" class="Bound">V</a> <a id="19900" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="19902" href="/PLFA-zh/Lambda/#19827" class="Bound">M′</a>

  <a id="_—→_.β-ƛ"></a><a id="19908" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="19912" class="Symbol">:</a> <a id="19914" class="Symbol">∀</a> <a id="19916" class="Symbol">{</a><a id="19917" href="/PLFA-zh/Lambda/#19917" class="Bound">x</a> <a id="19919" href="/PLFA-zh/Lambda/#19919" class="Bound">N</a> <a id="19921" href="/PLFA-zh/Lambda/#19921" class="Bound">V</a><a id="19922" class="Symbol">}</a>
    <a id="19928" class="Symbol">→</a> <a id="19930" href="/PLFA-zh/Lambda/#11634" class="Datatype">Value</a> <a id="19936" href="/PLFA-zh/Lambda/#19921" class="Bound">V</a>
      <a id="19944" class="Comment">------------------------------</a>
    <a id="19979" class="Symbol">→</a> <a id="19981" class="Symbol">(</a><a id="19982" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="19984" href="/PLFA-zh/Lambda/#19917" class="Bound">x</a> <a id="19986" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="19988" href="/PLFA-zh/Lambda/#19919" class="Bound">N</a><a id="19989" class="Symbol">)</a> <a id="19991" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="19993" href="/PLFA-zh/Lambda/#19921" class="Bound">V</a> <a id="19995" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">—→</a> <a id="19998" href="/PLFA-zh/Lambda/#19919" class="Bound">N</a> <a id="20000" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="20002" href="/PLFA-zh/Lambda/#19917" class="Bound">x</a> <a id="20004" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="20007" href="/PLFA-zh/Lambda/#19921" class="Bound">V</a> <a id="20009" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a>

  <a id="_—→_.ξ-suc"></a><a id="20014" href="/PLFA-zh/Lambda/#20014" class="InductiveConstructor">ξ-suc</a> <a id="20020" class="Symbol">:</a> <a id="20022" class="Symbol">∀</a> <a id="20024" class="Symbol">{</a><a id="20025" href="/PLFA-zh/Lambda/#20025" class="Bound">M</a> <a id="20027" href="/PLFA-zh/Lambda/#20027" class="Bound">M′</a><a id="20029" class="Symbol">}</a>
    <a id="20035" class="Symbol">→</a> <a id="20037" href="/PLFA-zh/Lambda/#20025" class="Bound">M</a> <a id="20039" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">—→</a> <a id="20042" href="/PLFA-zh/Lambda/#20027" class="Bound">M′</a>
      <a id="20051" class="Comment">------------------</a>
    <a id="20074" class="Symbol">→</a> <a id="20076" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="20081" href="/PLFA-zh/Lambda/#20025" class="Bound">M</a> <a id="20083" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">—→</a> <a id="20086" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="20091" href="/PLFA-zh/Lambda/#20027" class="Bound">M′</a>

  <a id="_—→_.ξ-case"></a><a id="20097" href="/PLFA-zh/Lambda/#20097" class="InductiveConstructor">ξ-case</a> <a id="20104" class="Symbol">:</a> <a id="20106" class="Symbol">∀</a> <a id="20108" class="Symbol">{</a><a id="20109" href="/PLFA-zh/Lambda/#20109" class="Bound">x</a> <a id="20111" href="/PLFA-zh/Lambda/#20111" class="Bound">L</a> <a id="20113" href="/PLFA-zh/Lambda/#20113" class="Bound">L′</a> <a id="20116" href="/PLFA-zh/Lambda/#20116" class="Bound">M</a> <a id="20118" href="/PLFA-zh/Lambda/#20118" class="Bound">N</a><a id="20119" class="Symbol">}</a>
    <a id="20125" class="Symbol">→</a> <a id="20127" href="/PLFA-zh/Lambda/#20111" class="Bound">L</a> <a id="20129" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">—→</a> <a id="20132" href="/PLFA-zh/Lambda/#20113" class="Bound">L′</a>
      <a id="20141" class="Comment">-----------------------------------------------------------------</a>
    <a id="20211" class="Symbol">→</a> <a id="20213" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="20218" href="/PLFA-zh/Lambda/#20111" class="Bound">L</a> <a id="20220" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="20227" href="/PLFA-zh/Lambda/#20116" class="Bound">M</a> <a id="20229" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="20234" href="/PLFA-zh/Lambda/#20109" class="Bound">x</a> <a id="20236" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="20238" href="/PLFA-zh/Lambda/#20118" class="Bound">N</a> <a id="20240" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a> <a id="20242" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">—→</a> <a id="20245" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="20250" href="/PLFA-zh/Lambda/#20113" class="Bound">L′</a> <a id="20253" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="20260" href="/PLFA-zh/Lambda/#20116" class="Bound">M</a> <a id="20262" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="20267" href="/PLFA-zh/Lambda/#20109" class="Bound">x</a> <a id="20269" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="20271" href="/PLFA-zh/Lambda/#20118" class="Bound">N</a> <a id="20273" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a>

  <a id="_—→_.β-zero"></a><a id="20278" href="/PLFA-zh/Lambda/#20278" class="InductiveConstructor">β-zero</a> <a id="20285" class="Symbol">:</a> <a id="20287" class="Symbol">∀</a> <a id="20289" class="Symbol">{</a><a id="20290" href="/PLFA-zh/Lambda/#20290" class="Bound">x</a> <a id="20292" href="/PLFA-zh/Lambda/#20292" class="Bound">M</a> <a id="20294" href="/PLFA-zh/Lambda/#20294" class="Bound">N</a><a id="20295" class="Symbol">}</a>
      <a id="20303" class="Comment">----------------------------------------</a>
    <a id="20348" class="Symbol">→</a> <a id="20350" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="20355" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="20361" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="20368" href="/PLFA-zh/Lambda/#20292" class="Bound">M</a> <a id="20370" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="20375" href="/PLFA-zh/Lambda/#20290" class="Bound">x</a> <a id="20377" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="20379" href="/PLFA-zh/Lambda/#20294" class="Bound">N</a> <a id="20381" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a> <a id="20383" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">—→</a> <a id="20386" href="/PLFA-zh/Lambda/#20292" class="Bound">M</a>

  <a id="_—→_.β-suc"></a><a id="20391" href="/PLFA-zh/Lambda/#20391" class="InductiveConstructor">β-suc</a> <a id="20397" class="Symbol">:</a> <a id="20399" class="Symbol">∀</a> <a id="20401" class="Symbol">{</a><a id="20402" href="/PLFA-zh/Lambda/#20402" class="Bound">x</a> <a id="20404" href="/PLFA-zh/Lambda/#20404" class="Bound">V</a> <a id="20406" href="/PLFA-zh/Lambda/#20406" class="Bound">M</a> <a id="20408" href="/PLFA-zh/Lambda/#20408" class="Bound">N</a><a id="20409" class="Symbol">}</a>
    <a id="20415" class="Symbol">→</a> <a id="20417" href="/PLFA-zh/Lambda/#11634" class="Datatype">Value</a> <a id="20423" href="/PLFA-zh/Lambda/#20404" class="Bound">V</a>
      <a id="20431" class="Comment">---------------------------------------------------</a>
    <a id="20487" class="Symbol">→</a> <a id="20489" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="20494" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="20499" href="/PLFA-zh/Lambda/#20404" class="Bound">V</a> <a id="20501" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="20508" href="/PLFA-zh/Lambda/#20406" class="Bound">M</a> <a id="20510" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="20515" href="/PLFA-zh/Lambda/#20402" class="Bound">x</a> <a id="20517" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="20519" href="/PLFA-zh/Lambda/#20408" class="Bound">N</a> <a id="20521" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a> <a id="20523" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">—→</a> <a id="20526" href="/PLFA-zh/Lambda/#20408" class="Bound">N</a> <a id="20528" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="20530" href="/PLFA-zh/Lambda/#20402" class="Bound">x</a> <a id="20532" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="20535" href="/PLFA-zh/Lambda/#20404" class="Bound">V</a> <a id="20537" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a>

  <a id="_—→_.β-μ"></a><a id="20542" href="/PLFA-zh/Lambda/#20542" class="InductiveConstructor">β-μ</a> <a id="20546" class="Symbol">:</a> <a id="20548" class="Symbol">∀</a> <a id="20550" class="Symbol">{</a><a id="20551" href="/PLFA-zh/Lambda/#20551" class="Bound">x</a> <a id="20553" href="/PLFA-zh/Lambda/#20553" class="Bound">M</a><a id="20554" class="Symbol">}</a>
      <a id="20562" class="Comment">------------------------------</a>
    <a id="20597" class="Symbol">→</a> <a id="20599" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">μ</a> <a id="20601" href="/PLFA-zh/Lambda/#20551" class="Bound">x</a> <a id="20603" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">⇒</a> <a id="20605" href="/PLFA-zh/Lambda/#20553" class="Bound">M</a> <a id="20607" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">—→</a> <a id="20610" href="/PLFA-zh/Lambda/#20553" class="Bound">M</a> <a id="20612" href="/PLFA-zh/Lambda/#15018" class="Function Operator">[</a> <a id="20614" href="/PLFA-zh/Lambda/#20551" class="Bound">x</a> <a id="20616" href="/PLFA-zh/Lambda/#15018" class="Function Operator">:=</a> <a id="20619" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">μ</a> <a id="20621" href="/PLFA-zh/Lambda/#20551" class="Bound">x</a> <a id="20623" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">⇒</a> <a id="20625" href="/PLFA-zh/Lambda/#20553" class="Bound">M</a> <a id="20627" href="/PLFA-zh/Lambda/#15018" class="Function Operator">]</a></pre>

<p>The reduction rules are carefully designed to ensure that subterms
of a term are reduced to values before the whole term is reduced.
This is referred to as <em>call by value</em> reduction.</p>

<p>Further, we have arranged that subterms are reduced in a
left-to-right order.  This means that reduction is <em>deterministic</em>:
for any term, there is at most one other term to which it reduces.
Put another way, our reduction relation <code class="highlighter-rouge">—→</code> is in fact a function.</p>

<h4 id="quiz-1">Quiz</h4>

<p>What does the following term step to?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ƛ "x" ⇒ ` "x") · (ƛ "x" ⇒ ` "x")  —→  ???
</code></pre></div></div>

<ol>
  <li><code class="highlighter-rouge">(ƛ "x" ⇒ ` "x")</code></li>
  <li><code class="highlighter-rouge">(ƛ "x" ⇒ ` "x") · (ƛ "x" ⇒ ` "x")</code></li>
  <li><code class="highlighter-rouge">(ƛ "x" ⇒ ` "x") · (ƛ "x" ⇒ ` "x") · (ƛ "x" ⇒ ` "x")</code></li>
</ol>

<p>What does the following term step to?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ƛ "x" ⇒ ` "x") · (ƛ "x" ⇒ ` "x") · (ƛ "x" ⇒ ` "x")  —→  ???
</code></pre></div></div>

<ol>
  <li><code class="highlighter-rouge">(ƛ "x" ⇒ ` "x")</code></li>
  <li><code class="highlighter-rouge">(ƛ "x" ⇒ ` "x") · (ƛ "x" ⇒ ` "x")</code></li>
  <li><code class="highlighter-rouge">(ƛ "x" ⇒ ` "x") · (ƛ "x" ⇒ ` "x") · (ƛ "x" ⇒ ` "x")</code></li>
</ol>

<p>What does the following term step to?  (Where <code class="highlighter-rouge">twoᶜ</code> and <code class="highlighter-rouge">sucᶜ</code> are as
defined above.)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>twoᶜ · sucᶜ · `zero  —→  ???
</code></pre></div></div>

<ol>
  <li><code class="highlighter-rouge">sucᶜ · (sucᶜ · `zero)</code></li>
  <li><code class="highlighter-rouge">(ƛ "z" ⇒ sucᶜ · (sucᶜ · ` "z")) · `zero</code></li>
  <li><code class="highlighter-rouge">`zero</code></li>
</ol>

<h2 id="reflexive-and-transitive-closure">Reflexive and transitive closure</h2>

<p>A single step is only part of the story. In general, we wish to repeatedly
step a closed term until it reduces to a value.  We do this by defining
the reflexive and transitive closure <code class="highlighter-rouge">—↠</code> of the step relation <code class="highlighter-rouge">—→</code>.</p>

<p>We define reflexive and transitive closure as a sequence of zero or
more steps of the underlying relation, along lines similar to that for
reasoning about chains of equalities in
Chapter <a href="/PLFA-zh/Equality/">Equality</a>:</p>
<pre class="Agda"><a id="22259" class="Keyword">infix</a>  <a id="22266" class="Number">2</a> <a id="22268" href="/PLFA-zh/Lambda/#22324" class="Datatype Operator">_—↠_</a>
<a id="22273" class="Keyword">infix</a>  <a id="22280" class="Number">1</a> <a id="22282" href="/PLFA-zh/Lambda/#22474" class="Function Operator">begin_</a>
<a id="22289" class="Keyword">infixr</a> <a id="22296" class="Number">2</a> <a id="22298" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">_—→⟨_⟩_</a>
<a id="22306" class="Keyword">infix</a>  <a id="22313" class="Number">3</a> <a id="22315" href="/PLFA-zh/Lambda/#22357" class="InductiveConstructor Operator">_∎</a>

<a id="22319" class="Keyword">data</a> <a id="_—↠_"></a><a id="22324" href="/PLFA-zh/Lambda/#22324" class="Datatype Operator">_—↠_</a> <a id="22329" class="Symbol">:</a> <a id="22331" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="22336" class="Symbol">→</a> <a id="22338" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="22343" class="Symbol">→</a> <a id="22345" class="PrimitiveType">Set</a> <a id="22349" class="Keyword">where</a>
  <a id="_—↠_._∎"></a><a id="22357" href="/PLFA-zh/Lambda/#22357" class="InductiveConstructor Operator">_∎</a> <a id="22360" class="Symbol">:</a> <a id="22362" class="Symbol">∀</a> <a id="22364" href="/PLFA-zh/Lambda/#22364" class="Bound">M</a>
      <a id="22372" class="Comment">---------</a>
    <a id="22386" class="Symbol">→</a> <a id="22388" href="/PLFA-zh/Lambda/#22364" class="Bound">M</a> <a id="22390" href="/PLFA-zh/Lambda/#22324" class="Datatype Operator">—↠</a> <a id="22393" href="/PLFA-zh/Lambda/#22364" class="Bound">M</a>

  <a id="_—↠_._—→⟨_⟩_"></a><a id="22398" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">_—→⟨_⟩_</a> <a id="22406" class="Symbol">:</a> <a id="22408" class="Symbol">∀</a> <a id="22410" href="/PLFA-zh/Lambda/#22410" class="Bound">L</a> <a id="22412" class="Symbol">{</a><a id="22413" href="/PLFA-zh/Lambda/#22413" class="Bound">M</a> <a id="22415" href="/PLFA-zh/Lambda/#22415" class="Bound">N</a><a id="22416" class="Symbol">}</a>
    <a id="22422" class="Symbol">→</a> <a id="22424" href="/PLFA-zh/Lambda/#22410" class="Bound">L</a> <a id="22426" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">—→</a> <a id="22429" href="/PLFA-zh/Lambda/#22413" class="Bound">M</a>
    <a id="22435" class="Symbol">→</a> <a id="22437" href="/PLFA-zh/Lambda/#22413" class="Bound">M</a> <a id="22439" href="/PLFA-zh/Lambda/#22324" class="Datatype Operator">—↠</a> <a id="22442" href="/PLFA-zh/Lambda/#22415" class="Bound">N</a>
      <a id="22450" class="Comment">---------</a>
    <a id="22464" class="Symbol">→</a> <a id="22466" href="/PLFA-zh/Lambda/#22410" class="Bound">L</a> <a id="22468" href="/PLFA-zh/Lambda/#22324" class="Datatype Operator">—↠</a> <a id="22471" href="/PLFA-zh/Lambda/#22415" class="Bound">N</a>

<a id="begin_"></a><a id="22474" href="/PLFA-zh/Lambda/#22474" class="Function Operator">begin_</a> <a id="22481" class="Symbol">:</a> <a id="22483" class="Symbol">∀</a> <a id="22485" class="Symbol">{</a><a id="22486" href="/PLFA-zh/Lambda/#22486" class="Bound">M</a> <a id="22488" href="/PLFA-zh/Lambda/#22488" class="Bound">N</a><a id="22489" class="Symbol">}</a>
  <a id="22493" class="Symbol">→</a> <a id="22495" href="/PLFA-zh/Lambda/#22486" class="Bound">M</a> <a id="22497" href="/PLFA-zh/Lambda/#22324" class="Datatype Operator">—↠</a> <a id="22500" href="/PLFA-zh/Lambda/#22488" class="Bound">N</a>
    <a id="22506" class="Comment">------</a>
  <a id="22515" class="Symbol">→</a> <a id="22517" href="/PLFA-zh/Lambda/#22486" class="Bound">M</a> <a id="22519" href="/PLFA-zh/Lambda/#22324" class="Datatype Operator">—↠</a> <a id="22522" href="/PLFA-zh/Lambda/#22488" class="Bound">N</a>
<a id="22524" href="/PLFA-zh/Lambda/#22474" class="Function Operator">begin</a> <a id="22530" href="/PLFA-zh/Lambda/#22530" class="Bound">M—↠N</a> <a id="22535" class="Symbol">=</a> <a id="22537" href="/PLFA-zh/Lambda/#22530" class="Bound">M—↠N</a></pre>
<p>We can read this as follows:</p>

<ul>
  <li>
    <p>From term <code class="highlighter-rouge">M</code>, we can take no steps, giving a step of type <code class="highlighter-rouge">M —↠ M</code>.
It is written <code class="highlighter-rouge">M ∎</code>.</p>
  </li>
  <li>
    <p>From term <code class="highlighter-rouge">L</code> we can take a single step of type <code class="highlighter-rouge">L —→ M</code> followed by zero
or more steps of type <code class="highlighter-rouge">M —↠ N</code>, giving a step of type <code class="highlighter-rouge">L —↠ N</code>. It is
written <code class="highlighter-rouge">L —→⟨ L—→M ⟩ M—↠N</code>, where <code class="highlighter-rouge">L—→M</code> and <code class="highlighter-rouge">M—↠N</code> are steps of the
appropriate type.</p>
  </li>
</ul>

<p>The notation is chosen to allow us to lay out example reductions in an
appealing way, as we will see in the next section.</p>

<p>An alternative is to define reflexive and transitive closure directly,
as the smallest relation that includes <code class="highlighter-rouge">—→</code> and is also reflexive
and transitive.  We could do so as follows:</p>
<pre class="Agda"><a id="23236" class="Keyword">data</a> <a id="_—↠′_"></a><a id="23241" href="/PLFA-zh/Lambda/#23241" class="Datatype Operator">_—↠′_</a> <a id="23247" class="Symbol">:</a> <a id="23249" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="23254" class="Symbol">→</a> <a id="23256" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="23261" class="Symbol">→</a> <a id="23263" class="PrimitiveType">Set</a> <a id="23267" class="Keyword">where</a>

  <a id="_—↠′_.step′"></a><a id="23276" href="/PLFA-zh/Lambda/#23276" class="InductiveConstructor">step′</a> <a id="23282" class="Symbol">:</a> <a id="23284" class="Symbol">∀</a> <a id="23286" class="Symbol">{</a><a id="23287" href="/PLFA-zh/Lambda/#23287" class="Bound">M</a> <a id="23289" href="/PLFA-zh/Lambda/#23289" class="Bound">N</a><a id="23290" class="Symbol">}</a>
    <a id="23296" class="Symbol">→</a> <a id="23298" href="/PLFA-zh/Lambda/#23287" class="Bound">M</a> <a id="23300" href="/PLFA-zh/Lambda/#19698" class="Datatype Operator">—→</a> <a id="23303" href="/PLFA-zh/Lambda/#23289" class="Bound">N</a>
      <a id="23311" class="Comment">-------</a>
    <a id="23323" class="Symbol">→</a> <a id="23325" href="/PLFA-zh/Lambda/#23287" class="Bound">M</a> <a id="23327" href="/PLFA-zh/Lambda/#23241" class="Datatype Operator">—↠′</a> <a id="23331" href="/PLFA-zh/Lambda/#23289" class="Bound">N</a>

  <a id="_—↠′_.refl′"></a><a id="23336" href="/PLFA-zh/Lambda/#23336" class="InductiveConstructor">refl′</a> <a id="23342" class="Symbol">:</a> <a id="23344" class="Symbol">∀</a> <a id="23346" class="Symbol">{</a><a id="23347" href="/PLFA-zh/Lambda/#23347" class="Bound">M</a><a id="23348" class="Symbol">}</a>
      <a id="23356" class="Comment">-------</a>
    <a id="23368" class="Symbol">→</a> <a id="23370" href="/PLFA-zh/Lambda/#23347" class="Bound">M</a> <a id="23372" href="/PLFA-zh/Lambda/#23241" class="Datatype Operator">—↠′</a> <a id="23376" href="/PLFA-zh/Lambda/#23347" class="Bound">M</a>

  <a id="_—↠′_.trans′"></a><a id="23381" href="/PLFA-zh/Lambda/#23381" class="InductiveConstructor">trans′</a> <a id="23388" class="Symbol">:</a> <a id="23390" class="Symbol">∀</a> <a id="23392" class="Symbol">{</a><a id="23393" href="/PLFA-zh/Lambda/#23393" class="Bound">L</a> <a id="23395" href="/PLFA-zh/Lambda/#23395" class="Bound">M</a> <a id="23397" href="/PLFA-zh/Lambda/#23397" class="Bound">N</a><a id="23398" class="Symbol">}</a>
    <a id="23404" class="Symbol">→</a> <a id="23406" href="/PLFA-zh/Lambda/#23393" class="Bound">L</a> <a id="23408" href="/PLFA-zh/Lambda/#23241" class="Datatype Operator">—↠′</a> <a id="23412" href="/PLFA-zh/Lambda/#23395" class="Bound">M</a>
    <a id="23418" class="Symbol">→</a> <a id="23420" href="/PLFA-zh/Lambda/#23395" class="Bound">M</a> <a id="23422" href="/PLFA-zh/Lambda/#23241" class="Datatype Operator">—↠′</a> <a id="23426" href="/PLFA-zh/Lambda/#23397" class="Bound">N</a>
      <a id="23434" class="Comment">-------</a>
    <a id="23446" class="Symbol">→</a> <a id="23448" href="/PLFA-zh/Lambda/#23393" class="Bound">L</a> <a id="23450" href="/PLFA-zh/Lambda/#23241" class="Datatype Operator">—↠′</a> <a id="23454" href="/PLFA-zh/Lambda/#23397" class="Bound">N</a></pre>
<p>The three constructors specify, respectively, that <code class="highlighter-rouge">—↠′</code> includes <code class="highlighter-rouge">—→</code>
and is reflexive and transitive.  A good exercise is to show that
the two definitions are equivalent (indeed, one embeds in the other).</p>

<h4 id="exercise-">Exercise <code class="highlighter-rouge">—↠≲—↠′</code></h4>

<p>Show that the first notion of reflexive and transitive closure
above embeds into the second. Why are they not isomorphic?</p>

<h2 id="confluence">Confluence</h2>

<p>One important property a reduction relation might satisfy is
to be <em>confluent</em>.  If term <code class="highlighter-rouge">L</code> reduces to two other terms,
<code class="highlighter-rouge">M</code> and <code class="highlighter-rouge">N</code>, then both of these reduce to a common term <code class="highlighter-rouge">P</code>.
It can be illustrated as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>           L
          / \
         /   \
        /     \
       M       N
        \     /
         \   /
          \ /
           P
</code></pre></div></div>

<p>Here <code class="highlighter-rouge">L</code>, <code class="highlighter-rouge">M</code>, <code class="highlighter-rouge">N</code> are universally quantified while <code class="highlighter-rouge">P</code>
is existentially quantified.  If each line stands for zero
or more reduction steps, this is called confluence,
while if the top two lines stand for a single reduction
step and the bottom two stand for zero or more reduction
steps it is called the diamond property. In symbols:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>confluence : ∀ {L M N} → ∃[ P ]
  ( ((L —↠ M) × (L —↠ N))
    --------------------
  → ((M —↠ P) × (N —↠ P)) )

diamond : ∀ {L M N} → ∃[ P ]
  ( ((L —→ M) × (L —→ N))
    --------------------
  → ((M —↠ P) × (N —↠ P)) )
</code></pre></div></div>

<p>All of the reduction systems studied in this text are deterministic.
In symbols:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>deterministic : ∀ {L M N}
  → L —→ M
  → L —→ N
    ------
  → M ≡ N
</code></pre></div></div>

<p>It is easy to show that every deterministic relation satisfies
the diamond property, and that every relation that satisfies
the diamond property is confluent.  Hence, all the reduction
systems studied in this text are trivially confluent.</p>

<h2 id="examples-1">Examples</h2>

<p>We start with a simple example. The Church numeral two applied to the
successor function and zero yields the natural number two:</p>
<pre class="Agda"><a id="25379" href="/PLFA-zh/Lambda/#25379" class="Function">_</a> <a id="25381" class="Symbol">:</a> <a id="25383" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="25388" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25390" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="25395" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25397" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="25403" href="/PLFA-zh/Lambda/#22324" class="Datatype Operator">—↠</a> <a id="25406" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="25411" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="25416" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a>
<a id="25422" class="Symbol">_</a> <a id="25424" class="Symbol">=</a>
  <a id="25428" href="/PLFA-zh/Lambda/#22474" class="Function Operator">begin</a>
    <a id="25438" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="25443" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25445" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="25450" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25452" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a>
  <a id="25460" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="25464" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="25469" class="Symbol">(</a><a id="25470" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="25474" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-ƛ</a><a id="25477" class="Symbol">)</a> <a id="25479" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="25485" class="Symbol">(</a><a id="25486" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="25488" class="String">&quot;z&quot;</a> <a id="25492" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="25494" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="25499" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25501" class="Symbol">(</a><a id="25502" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="25507" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25509" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="25511" class="String">&quot;z&quot;</a><a id="25514" class="Symbol">))</a> <a id="25517" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25519" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a>
  <a id="25527" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="25531" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="25535" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a> <a id="25542" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="25548" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="25553" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25555" class="Symbol">(</a><a id="25556" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="25561" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25563" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a><a id="25568" class="Symbol">)</a>
  <a id="25572" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="25576" href="/PLFA-zh/Lambda/#19813" class="InductiveConstructor">ξ-·₂</a> <a id="25581" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-ƛ</a> <a id="25585" class="Symbol">(</a><a id="25586" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="25590" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="25596" class="Symbol">)</a> <a id="25598" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="25604" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="25609" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25611" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="25616" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a>
  <a id="25624" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="25628" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="25632" class="Symbol">(</a><a id="25633" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="25639" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="25645" class="Symbol">)</a> <a id="25647" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="25653" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="25658" class="Symbol">(</a><a id="25659" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="25664" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a><a id="25669" class="Symbol">)</a>
  <a id="25673" href="/PLFA-zh/Lambda/#22357" class="InductiveConstructor Operator">∎</a></pre>

<p>Here is a sample reduction demonstrating that two plus two is four:</p>
<pre class="Agda"><a id="25768" href="/PLFA-zh/Lambda/#25768" class="Function">_</a> <a id="25770" class="Symbol">:</a> <a id="25772" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="25777" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25779" href="/PLFA-zh/Lambda/#4589" class="Function">two</a> <a id="25783" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25785" href="/PLFA-zh/Lambda/#4589" class="Function">two</a> <a id="25789" href="/PLFA-zh/Lambda/#22324" class="Datatype Operator">—↠</a> <a id="25792" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="25797" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="25802" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="25807" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="25812" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a>
<a id="25818" class="Symbol">_</a> <a id="25820" class="Symbol">=</a>
  <a id="25824" href="/PLFA-zh/Lambda/#22474" class="Function Operator">begin</a>
    <a id="25834" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="25839" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25841" href="/PLFA-zh/Lambda/#4589" class="Function">two</a> <a id="25845" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25847" href="/PLFA-zh/Lambda/#4589" class="Function">two</a>
  <a id="25853" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="25857" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="25862" class="Symbol">(</a><a id="25863" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="25868" href="/PLFA-zh/Lambda/#20542" class="InductiveConstructor">β-μ</a><a id="25871" class="Symbol">)</a> <a id="25873" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="25879" class="Symbol">(</a><a id="25880" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="25882" class="String">&quot;m&quot;</a> <a id="25886" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="25888" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="25890" class="String">&quot;n&quot;</a> <a id="25894" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a>
      <a id="25902" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="25907" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="25909" class="String">&quot;m&quot;</a> <a id="25913" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="25920" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="25922" class="String">&quot;n&quot;</a> <a id="25926" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="25931" class="String">&quot;m&quot;</a> <a id="25935" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="25937" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="25942" class="Symbol">(</a><a id="25943" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="25948" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25950" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="25952" class="String">&quot;m&quot;</a> <a id="25956" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25958" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="25960" class="String">&quot;n&quot;</a><a id="25963" class="Symbol">)</a> <a id="25965" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a><a id="25966" class="Symbol">)</a>
        <a id="25976" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25978" href="/PLFA-zh/Lambda/#4589" class="Function">two</a> <a id="25982" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="25984" href="/PLFA-zh/Lambda/#4589" class="Function">two</a>
  <a id="25990" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="25994" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="25999" class="Symbol">(</a><a id="26000" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="26004" class="Symbol">(</a><a id="26005" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="26011" class="Symbol">(</a><a id="26012" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="26018" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="26024" class="Symbol">)))</a> <a id="26028" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="26034" class="Symbol">(</a><a id="26035" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="26037" class="String">&quot;n&quot;</a> <a id="26041" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a>
      <a id="26049" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="26054" href="/PLFA-zh/Lambda/#4589" class="Function">two</a> <a id="26058" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="26065" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26067" class="String">&quot;n&quot;</a> <a id="26071" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="26076" class="String">&quot;m&quot;</a> <a id="26080" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="26082" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26087" class="Symbol">(</a><a id="26088" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="26093" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26095" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26097" class="String">&quot;m&quot;</a> <a id="26101" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26103" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26105" class="String">&quot;n&quot;</a><a id="26108" class="Symbol">)</a> <a id="26110" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a><a id="26111" class="Symbol">)</a>
         <a id="26122" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26124" href="/PLFA-zh/Lambda/#4589" class="Function">two</a>
  <a id="26130" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="26134" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="26138" class="Symbol">(</a><a id="26139" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="26145" class="Symbol">(</a><a id="26146" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="26152" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="26158" class="Symbol">))</a> <a id="26161" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="26167" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="26172" href="/PLFA-zh/Lambda/#4589" class="Function">two</a> <a id="26176" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="26183" href="/PLFA-zh/Lambda/#4589" class="Function">two</a> <a id="26187" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="26192" class="String">&quot;m&quot;</a> <a id="26196" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="26198" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26203" class="Symbol">(</a><a id="26204" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="26209" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26211" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26213" class="String">&quot;m&quot;</a> <a id="26217" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26219" href="/PLFA-zh/Lambda/#4589" class="Function">two</a><a id="26222" class="Symbol">)</a> <a id="26224" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a>
  <a id="26228" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="26232" href="/PLFA-zh/Lambda/#20391" class="InductiveConstructor">β-suc</a> <a id="26238" class="Symbol">(</a><a id="26239" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="26245" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="26251" class="Symbol">)</a> <a id="26253" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="26259" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26264" class="Symbol">(</a><a id="26265" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="26270" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26272" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26277" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="26283" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26285" href="/PLFA-zh/Lambda/#4589" class="Function">two</a><a id="26288" class="Symbol">)</a>
  <a id="26292" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="26296" href="/PLFA-zh/Lambda/#20014" class="InductiveConstructor">ξ-suc</a> <a id="26302" class="Symbol">(</a><a id="26303" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="26308" class="Symbol">(</a><a id="26309" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="26314" href="/PLFA-zh/Lambda/#20542" class="InductiveConstructor">β-μ</a><a id="26317" class="Symbol">))</a> <a id="26320" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="26326" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26331" class="Symbol">((</a><a id="26333" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="26335" class="String">&quot;m&quot;</a> <a id="26339" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="26341" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="26343" class="String">&quot;n&quot;</a> <a id="26347" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a>
      <a id="26355" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="26360" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26362" class="String">&quot;m&quot;</a> <a id="26366" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="26373" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26375" class="String">&quot;n&quot;</a> <a id="26379" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="26384" class="String">&quot;m&quot;</a> <a id="26388" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="26390" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26395" class="Symbol">(</a><a id="26396" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="26401" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26403" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26405" class="String">&quot;m&quot;</a> <a id="26409" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26411" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26413" class="String">&quot;n&quot;</a><a id="26416" class="Symbol">)</a> <a id="26418" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a><a id="26419" class="Symbol">)</a>
        <a id="26429" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26431" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26436" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="26442" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26444" href="/PLFA-zh/Lambda/#4589" class="Function">two</a><a id="26447" class="Symbol">)</a>
  <a id="26451" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="26455" href="/PLFA-zh/Lambda/#20014" class="InductiveConstructor">ξ-suc</a> <a id="26461" class="Symbol">(</a><a id="26462" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="26467" class="Symbol">(</a><a id="26468" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="26472" class="Symbol">(</a><a id="26473" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="26479" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="26485" class="Symbol">)))</a> <a id="26489" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="26495" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26500" class="Symbol">((</a><a id="26502" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="26504" class="String">&quot;n&quot;</a> <a id="26508" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a>
      <a id="26516" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="26521" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26526" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="26532" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="26539" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26541" class="String">&quot;n&quot;</a> <a id="26545" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="26550" class="String">&quot;m&quot;</a> <a id="26554" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="26556" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26561" class="Symbol">(</a><a id="26562" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="26567" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26569" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26571" class="String">&quot;m&quot;</a> <a id="26575" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26577" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26579" class="String">&quot;n&quot;</a><a id="26582" class="Symbol">)</a> <a id="26584" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a><a id="26585" class="Symbol">)</a>
        <a id="26595" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26597" href="/PLFA-zh/Lambda/#4589" class="Function">two</a><a id="26600" class="Symbol">)</a>
  <a id="26604" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="26608" href="/PLFA-zh/Lambda/#20014" class="InductiveConstructor">ξ-suc</a> <a id="26614" class="Symbol">(</a><a id="26615" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="26619" class="Symbol">(</a><a id="26620" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="26626" class="Symbol">(</a><a id="26627" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="26633" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="26639" class="Symbol">)))</a> <a id="26643" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="26649" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26654" class="Symbol">(</a><a id="26655" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="26660" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26665" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="26671" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="26678" href="/PLFA-zh/Lambda/#4589" class="Function">two</a> <a id="26682" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="26687" class="String">&quot;m&quot;</a> <a id="26691" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="26693" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26698" class="Symbol">(</a><a id="26699" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="26704" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26706" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26708" class="String">&quot;m&quot;</a> <a id="26712" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26714" href="/PLFA-zh/Lambda/#4589" class="Function">two</a><a id="26717" class="Symbol">)</a> <a id="26719" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a><a id="26720" class="Symbol">)</a>
  <a id="26724" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="26728" href="/PLFA-zh/Lambda/#20014" class="InductiveConstructor">ξ-suc</a> <a id="26734" class="Symbol">(</a><a id="26735" href="/PLFA-zh/Lambda/#20391" class="InductiveConstructor">β-suc</a> <a id="26741" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="26747" class="Symbol">)</a> <a id="26749" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="26755" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26760" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26765" class="Symbol">(</a><a id="26766" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="26771" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26773" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="26779" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26781" href="/PLFA-zh/Lambda/#4589" class="Function">two</a><a id="26784" class="Symbol">)</a>
  <a id="26788" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="26792" href="/PLFA-zh/Lambda/#20014" class="InductiveConstructor">ξ-suc</a> <a id="26798" class="Symbol">(</a><a id="26799" href="/PLFA-zh/Lambda/#20014" class="InductiveConstructor">ξ-suc</a> <a id="26805" class="Symbol">(</a><a id="26806" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="26811" class="Symbol">(</a><a id="26812" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="26817" href="/PLFA-zh/Lambda/#20542" class="InductiveConstructor">β-μ</a><a id="26820" class="Symbol">)))</a> <a id="26824" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="26830" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26835" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26840" class="Symbol">((</a><a id="26842" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="26844" class="String">&quot;m&quot;</a> <a id="26848" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="26850" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="26852" class="String">&quot;n&quot;</a> <a id="26856" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a>
      <a id="26864" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="26869" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26871" class="String">&quot;m&quot;</a> <a id="26875" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="26882" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26884" class="String">&quot;n&quot;</a> <a id="26888" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="26893" class="String">&quot;m&quot;</a> <a id="26897" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="26899" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="26904" class="Symbol">(</a><a id="26905" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="26910" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26912" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26914" class="String">&quot;m&quot;</a> <a id="26918" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26920" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="26922" class="String">&quot;n&quot;</a><a id="26925" class="Symbol">)</a> <a id="26927" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a><a id="26928" class="Symbol">)</a>
        <a id="26938" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26940" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="26946" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="26948" href="/PLFA-zh/Lambda/#4589" class="Function">two</a><a id="26951" class="Symbol">)</a>
  <a id="26955" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="26959" href="/PLFA-zh/Lambda/#20014" class="InductiveConstructor">ξ-suc</a> <a id="26965" class="Symbol">(</a><a id="26966" href="/PLFA-zh/Lambda/#20014" class="InductiveConstructor">ξ-suc</a> <a id="26972" class="Symbol">(</a><a id="26973" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="26978" class="Symbol">(</a><a id="26979" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="26983" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="26989" class="Symbol">)))</a> <a id="26993" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="26999" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="27004" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="27009" class="Symbol">((</a><a id="27011" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="27013" class="String">&quot;n&quot;</a> <a id="27017" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a>
      <a id="27025" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="27030" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="27036" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="27043" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27045" class="String">&quot;n&quot;</a> <a id="27049" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="27054" class="String">&quot;m&quot;</a> <a id="27058" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="27060" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="27065" class="Symbol">(</a><a id="27066" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="27071" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27073" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27075" class="String">&quot;m&quot;</a> <a id="27079" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27081" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27083" class="String">&quot;n&quot;</a><a id="27086" class="Symbol">)</a> <a id="27088" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a><a id="27089" class="Symbol">)</a>
        <a id="27099" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27101" href="/PLFA-zh/Lambda/#4589" class="Function">two</a><a id="27104" class="Symbol">)</a>
  <a id="27108" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="27112" href="/PLFA-zh/Lambda/#20014" class="InductiveConstructor">ξ-suc</a> <a id="27118" class="Symbol">(</a><a id="27119" href="/PLFA-zh/Lambda/#20014" class="InductiveConstructor">ξ-suc</a> <a id="27125" class="Symbol">(</a><a id="27126" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="27130" class="Symbol">(</a><a id="27131" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="27137" class="Symbol">(</a><a id="27138" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="27144" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="27150" class="Symbol">))))</a> <a id="27155" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="27161" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="27166" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="27171" class="Symbol">(</a><a id="27172" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="27177" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="27183" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="27190" href="/PLFA-zh/Lambda/#4589" class="Function">two</a> <a id="27194" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="27199" class="String">&quot;m&quot;</a> <a id="27203" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="27205" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="27210" class="Symbol">(</a><a id="27211" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="27216" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27218" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27220" class="String">&quot;m&quot;</a> <a id="27224" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27226" href="/PLFA-zh/Lambda/#4589" class="Function">two</a><a id="27229" class="Symbol">)</a> <a id="27231" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a><a id="27232" class="Symbol">)</a>
  <a id="27236" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="27240" href="/PLFA-zh/Lambda/#20014" class="InductiveConstructor">ξ-suc</a> <a id="27246" class="Symbol">(</a><a id="27247" href="/PLFA-zh/Lambda/#20014" class="InductiveConstructor">ξ-suc</a> <a id="27253" href="/PLFA-zh/Lambda/#20278" class="InductiveConstructor">β-zero</a><a id="27259" class="Symbol">)</a> <a id="27261" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="27267" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="27272" class="Symbol">(</a><a id="27273" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="27278" class="Symbol">(</a><a id="27279" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="27284" class="Symbol">(</a><a id="27285" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="27290" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a><a id="27295" class="Symbol">)))</a>
  <a id="27301" href="/PLFA-zh/Lambda/#22357" class="InductiveConstructor Operator">∎</a></pre>

<p>And here is a similar sample reduction for Church numerals:</p>
<pre class="Agda"><a id="27388" href="/PLFA-zh/Lambda/#27388" class="Function">_</a> <a id="27390" class="Symbol">:</a> <a id="27392" href="/PLFA-zh/Lambda/#5900" class="Function">plusᶜ</a> <a id="27398" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27400" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="27405" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27407" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="27412" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27414" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="27419" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27421" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="27427" href="/PLFA-zh/Lambda/#22324" class="Datatype Operator">—↠</a> <a id="27430" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="27435" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="27440" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="27445" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="27450" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a>
<a id="27456" class="Symbol">_</a> <a id="27458" class="Symbol">=</a>
  <a id="27462" href="/PLFA-zh/Lambda/#22474" class="Function Operator">begin</a>
    <a id="27472" class="Symbol">(</a><a id="27473" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="27475" class="String">&quot;m&quot;</a> <a id="27479" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="27481" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="27483" class="String">&quot;n&quot;</a> <a id="27487" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="27489" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="27491" class="String">&quot;s&quot;</a> <a id="27495" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="27497" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="27499" class="String">&quot;z&quot;</a> <a id="27503" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="27505" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27507" class="String">&quot;m&quot;</a> <a id="27511" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27513" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27515" class="String">&quot;s&quot;</a> <a id="27519" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27521" class="Symbol">(</a><a id="27522" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27524" class="String">&quot;n&quot;</a> <a id="27528" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27530" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27532" class="String">&quot;s&quot;</a> <a id="27536" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27538" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27540" class="String">&quot;z&quot;</a><a id="27543" class="Symbol">))</a>
      <a id="27552" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27554" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="27559" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27561" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="27566" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27568" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="27573" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27575" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a>
  <a id="27583" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="27587" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="27592" class="Symbol">(</a><a id="27593" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="27598" class="Symbol">(</a><a id="27599" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="27604" class="Symbol">(</a><a id="27605" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="27609" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-ƛ</a><a id="27612" class="Symbol">)))</a> <a id="27616" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="27622" class="Symbol">(</a><a id="27623" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="27625" class="String">&quot;n&quot;</a> <a id="27629" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="27631" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="27633" class="String">&quot;s&quot;</a> <a id="27637" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="27639" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="27641" class="String">&quot;z&quot;</a> <a id="27645" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="27647" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="27652" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27654" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27656" class="String">&quot;s&quot;</a> <a id="27660" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27662" class="Symbol">(</a><a id="27663" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27665" class="String">&quot;n&quot;</a> <a id="27669" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27671" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27673" class="String">&quot;s&quot;</a> <a id="27677" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27679" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27681" class="String">&quot;z&quot;</a><a id="27684" class="Symbol">))</a>
      <a id="27693" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27695" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="27700" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27702" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="27707" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27709" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a>
  <a id="27717" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="27721" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="27726" class="Symbol">(</a><a id="27727" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="27732" class="Symbol">(</a><a id="27733" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="27737" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-ƛ</a><a id="27740" class="Symbol">))</a> <a id="27743" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="27749" class="Symbol">(</a><a id="27750" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="27752" class="String">&quot;s&quot;</a> <a id="27756" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="27758" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="27760" class="String">&quot;z&quot;</a> <a id="27764" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="27766" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="27771" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27773" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27775" class="String">&quot;s&quot;</a> <a id="27779" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27781" class="Symbol">(</a><a id="27782" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="27787" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27789" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27791" class="String">&quot;s&quot;</a> <a id="27795" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27797" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27799" class="String">&quot;z&quot;</a><a id="27802" class="Symbol">))</a> <a id="27805" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27807" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="27812" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27814" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a>
  <a id="27822" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="27826" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="27831" class="Symbol">(</a><a id="27832" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="27836" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-ƛ</a><a id="27839" class="Symbol">)</a> <a id="27841" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="27847" class="Symbol">(</a><a id="27848" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="27850" class="String">&quot;z&quot;</a> <a id="27854" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="27856" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="27861" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27863" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="27868" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27870" class="Symbol">(</a><a id="27871" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="27876" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27878" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="27883" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27885" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="27887" class="String">&quot;z&quot;</a><a id="27890" class="Symbol">))</a> <a id="27893" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27895" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a>
  <a id="27903" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="27907" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="27911" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a> <a id="27918" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="27924" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="27929" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27931" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="27936" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27938" class="Symbol">(</a><a id="27939" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="27944" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27946" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="27951" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="27953" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a><a id="27958" class="Symbol">)</a>
  <a id="27962" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="27966" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="27971" class="Symbol">(</a><a id="27972" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="27976" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-ƛ</a><a id="27979" class="Symbol">)</a> <a id="27981" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="27987" class="Symbol">(</a><a id="27988" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="27990" class="String">&quot;z&quot;</a> <a id="27994" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="27996" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28001" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28003" class="Symbol">(</a><a id="28004" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28009" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28011" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="28013" class="String">&quot;z&quot;</a><a id="28016" class="Symbol">))</a> <a id="28019" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28021" class="Symbol">(</a><a id="28022" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="28027" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28029" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28034" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28036" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a><a id="28041" class="Symbol">)</a>
  <a id="28045" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="28049" href="/PLFA-zh/Lambda/#19813" class="InductiveConstructor">ξ-·₂</a> <a id="28054" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-ƛ</a> <a id="28058" class="Symbol">(</a><a id="28059" href="/PLFA-zh/Lambda/#19732" class="InductiveConstructor">ξ-·₁</a> <a id="28064" class="Symbol">(</a><a id="28065" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="28069" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-ƛ</a><a id="28072" class="Symbol">))</a> <a id="28075" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="28081" class="Symbol">(</a><a id="28082" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="28084" class="String">&quot;z&quot;</a> <a id="28088" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="28090" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28095" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28097" class="Symbol">(</a><a id="28098" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28103" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28105" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="28107" class="String">&quot;z&quot;</a><a id="28110" class="Symbol">))</a> <a id="28113" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28115" class="Symbol">((</a><a id="28117" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="28119" class="String">&quot;z&quot;</a> <a id="28123" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="28125" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28130" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28132" class="Symbol">(</a><a id="28133" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28138" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28140" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="28142" class="String">&quot;z&quot;</a><a id="28145" class="Symbol">))</a> <a id="28148" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28150" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a><a id="28155" class="Symbol">)</a>
  <a id="28159" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="28163" href="/PLFA-zh/Lambda/#19813" class="InductiveConstructor">ξ-·₂</a> <a id="28168" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-ƛ</a> <a id="28172" class="Symbol">(</a><a id="28173" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="28177" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="28183" class="Symbol">)</a> <a id="28185" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="28191" class="Symbol">(</a><a id="28192" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="28194" class="String">&quot;z&quot;</a> <a id="28198" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="28200" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28205" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28207" class="Symbol">(</a><a id="28208" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28213" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28215" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="28217" class="String">&quot;z&quot;</a><a id="28220" class="Symbol">))</a> <a id="28223" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28225" class="Symbol">(</a><a id="28226" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28231" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28233" class="Symbol">(</a><a id="28234" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28239" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28241" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a><a id="28246" class="Symbol">))</a>
  <a id="28251" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="28255" href="/PLFA-zh/Lambda/#19813" class="InductiveConstructor">ξ-·₂</a> <a id="28260" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-ƛ</a> <a id="28264" class="Symbol">(</a><a id="28265" href="/PLFA-zh/Lambda/#19813" class="InductiveConstructor">ξ-·₂</a> <a id="28270" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-ƛ</a> <a id="28274" class="Symbol">(</a><a id="28275" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="28279" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="28285" class="Symbol">))</a> <a id="28288" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="28294" class="Symbol">(</a><a id="28295" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="28297" class="String">&quot;z&quot;</a> <a id="28301" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="28303" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28308" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28310" class="Symbol">(</a><a id="28311" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28316" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28318" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="28320" class="String">&quot;z&quot;</a><a id="28323" class="Symbol">))</a> <a id="28326" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28328" class="Symbol">(</a><a id="28329" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28334" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28336" class="Symbol">(</a><a id="28337" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="28342" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a><a id="28347" class="Symbol">))</a>
  <a id="28352" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="28356" href="/PLFA-zh/Lambda/#19813" class="InductiveConstructor">ξ-·₂</a> <a id="28361" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-ƛ</a> <a id="28365" class="Symbol">(</a><a id="28366" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="28370" class="Symbol">(</a><a id="28371" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="28377" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="28383" class="Symbol">))</a> <a id="28386" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="28392" class="Symbol">(</a><a id="28393" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="28395" class="String">&quot;z&quot;</a> <a id="28399" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="28401" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28406" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28408" class="Symbol">(</a><a id="28409" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28414" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28416" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="28418" class="String">&quot;z&quot;</a><a id="28421" class="Symbol">))</a> <a id="28424" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28426" class="Symbol">(</a><a id="28427" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="28432" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="28437" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a><a id="28442" class="Symbol">)</a>
  <a id="28446" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="28450" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="28454" class="Symbol">(</a><a id="28455" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="28461" class="Symbol">(</a><a id="28462" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="28468" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="28474" class="Symbol">))</a> <a id="28477" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="28483" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28488" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28490" class="Symbol">(</a><a id="28491" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28496" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28498" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="28503" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="28508" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a><a id="28513" class="Symbol">)</a>
  <a id="28517" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="28521" href="/PLFA-zh/Lambda/#19813" class="InductiveConstructor">ξ-·₂</a> <a id="28526" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-ƛ</a> <a id="28530" class="Symbol">(</a><a id="28531" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="28535" class="Symbol">(</a><a id="28536" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="28542" class="Symbol">(</a><a id="28543" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="28549" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="28555" class="Symbol">)))</a> <a id="28559" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
    <a id="28565" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="28570" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="28572" class="Symbol">(</a><a id="28573" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="28578" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="28583" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="28588" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a><a id="28593" class="Symbol">)</a>
  <a id="28597" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">—→⟨</a> <a id="28601" href="/PLFA-zh/Lambda/#19908" class="InductiveConstructor">β-ƛ</a> <a id="28605" class="Symbol">(</a><a id="28606" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="28612" class="Symbol">(</a><a id="28613" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="28619" class="Symbol">(</a><a id="28620" href="/PLFA-zh/Lambda/#11771" class="InductiveConstructor">V-suc</a> <a id="28626" href="/PLFA-zh/Lambda/#11723" class="InductiveConstructor">V-zero</a><a id="28632" class="Symbol">)))</a> <a id="28636" href="/PLFA-zh/Lambda/#22398" class="InductiveConstructor Operator">⟩</a>
   <a id="28641" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="28646" class="Symbol">(</a><a id="28647" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="28652" class="Symbol">(</a><a id="28653" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="28658" class="Symbol">(</a><a id="28659" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="28664" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a><a id="28669" class="Symbol">)))</a>
  <a id="28675" href="/PLFA-zh/Lambda/#22357" class="InductiveConstructor Operator">∎</a></pre>

<p>In the next chapter, we will see how to compute such reduction sequences.</p>

<h4 id="exercise-plus-example">Exercise <code class="highlighter-rouge">plus-example</code></h4>

<p>Write out the reduction sequence demonstrating that one plus one is two.</p>

<h2 id="syntax-of-types">Syntax of types</h2>

<p>We have just two types:</p>

<ul>
  <li>Functions, <code class="highlighter-rouge">A ⇒ B</code></li>
  <li>Naturals, <code class="highlighter-rouge">`ℕ</code></li>
</ul>

<p>As before, to avoid overlap we use variants of the names used by Agda.</p>

<p>Here is the syntax of types in BNF:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A, B, C  ::=  A ⇒ B | `ℕ
</code></pre></div></div>

<p>And here it is formalised in Agda:</p>

<pre class="Agda"><a id="29150" class="Keyword">infixr</a> <a id="29157" class="Number">7</a> <a id="29159" href="/PLFA-zh/Lambda/#29188" class="InductiveConstructor Operator">_⇒_</a>

<a id="29164" class="Keyword">data</a> <a id="Type"></a><a id="29169" href="/PLFA-zh/Lambda/#29169" class="Datatype">Type</a> <a id="29174" class="Symbol">:</a> <a id="29176" class="PrimitiveType">Set</a> <a id="29180" class="Keyword">where</a>
  <a id="Type._⇒_"></a><a id="29188" href="/PLFA-zh/Lambda/#29188" class="InductiveConstructor Operator">_⇒_</a> <a id="29192" class="Symbol">:</a> <a id="29194" href="/PLFA-zh/Lambda/#29169" class="Datatype">Type</a> <a id="29199" class="Symbol">→</a> <a id="29201" href="/PLFA-zh/Lambda/#29169" class="Datatype">Type</a> <a id="29206" class="Symbol">→</a> <a id="29208" href="/PLFA-zh/Lambda/#29169" class="Datatype">Type</a>
  <a id="Type.`ℕ"></a><a id="29215" href="/PLFA-zh/Lambda/#29215" class="InductiveConstructor">`ℕ</a> <a id="29218" class="Symbol">:</a> <a id="29220" href="/PLFA-zh/Lambda/#29169" class="Datatype">Type</a></pre>

<h3 id="precedence">Precedence</h3>

<p>As in Agda, functions of two or more arguments are represented via
currying. This is made more convenient by declaring <code class="highlighter-rouge">_⇒_</code> to
associate to the right and <code class="highlighter-rouge">_·_</code> to associate to the left.
Thus:</p>

<ul>
  <li><code class="highlighter-rouge">(`ℕ ⇒ `ℕ) ⇒ `ℕ ⇒ `ℕ</code> stands for <code class="highlighter-rouge">((`ℕ ⇒ `ℕ) ⇒ (`ℕ ⇒ `ℕ))</code>.</li>
  <li><code class="highlighter-rouge">plus · two · two</code> stands for <code class="highlighter-rouge">(plus · two) · two</code>.</li>
</ul>

<h3 id="quiz-2">Quiz</h3>

<ul>
  <li>
    <p>What is the type of the following term?</p>

    <p><code class="highlighter-rouge">ƛ "s" ⇒ ` "s" · (` "s"  · `zero)</code></p>

    <ol>
      <li><code class="highlighter-rouge">(`ℕ ⇒ `ℕ) ⇒ (`ℕ ⇒ `ℕ)</code></li>
      <li><code class="highlighter-rouge">(`ℕ ⇒ `ℕ) ⇒ `ℕ</code></li>
      <li><code class="highlighter-rouge">`ℕ ⇒ (`ℕ ⇒ `ℕ)</code></li>
      <li><code class="highlighter-rouge">`ℕ ⇒ `ℕ ⇒ `ℕ</code></li>
      <li><code class="highlighter-rouge">`ℕ ⇒ `ℕ</code></li>
      <li><code class="highlighter-rouge">`ℕ</code></li>
    </ol>

    <p>Give more than one answer if appropriate.</p>
  </li>
  <li>
    <p>What is the type of the following term?</p>

    <p><code class="highlighter-rouge">(ƛ "s" ⇒ ` "s" · (` "s"  · `zero)) · sucᶜ</code></p>

    <ol>
      <li><code class="highlighter-rouge">(`ℕ ⇒ `ℕ) ⇒ (`ℕ ⇒ `ℕ)</code></li>
      <li><code class="highlighter-rouge">(`ℕ ⇒ `ℕ) ⇒ `ℕ</code></li>
      <li><code class="highlighter-rouge">`ℕ ⇒ (`ℕ ⇒ `ℕ)</code></li>
      <li><code class="highlighter-rouge">`ℕ ⇒ `ℕ ⇒ `ℕ</code></li>
      <li><code class="highlighter-rouge">`ℕ ⇒ `ℕ</code></li>
      <li><code class="highlighter-rouge">`ℕ</code></li>
    </ol>

    <p>Give more than one answer if appropriate.</p>
  </li>
</ul>

<h2 id="typing">Typing</h2>

<h3 id="contexts">Contexts</h3>

<p>While reduction considers only closed terms, typing must
consider terms with free variables.  To type a term,
we must first type its subterms, and in particular in the
body of an abstraction its bound variable may appear free.</p>

<p>A <em>context</em> associates variables with types.  We let <code class="highlighter-rouge">Γ</code> and <code class="highlighter-rouge">Δ</code> range
over contexts.  We write <code class="highlighter-rouge">∅</code> for the empty context, and <code class="highlighter-rouge">Γ , x ⦂ A</code>
for the context that extends <code class="highlighter-rouge">Γ</code> by mapping variable <code class="highlighter-rouge">x</code> to type <code class="highlighter-rouge">A</code>.
For example,</p>

<ul>
  <li><code class="highlighter-rouge">∅ , "s" ⦂ `ℕ ⇒ `ℕ , "z" ⦂ `ℕ</code></li>
</ul>

<p>is the context that associates variable <code class="highlighter-rouge">"s"</code> with type <code class="highlighter-rouge">`ℕ ⇒ `ℕ</code>,
and variable <code class="highlighter-rouge">"z"</code> with type <code class="highlighter-rouge">`ℕ</code>.</p>

<p>Contexts are formalised as follows:</p>

<pre class="Agda"><a id="30821" class="Keyword">infixl</a> <a id="30828" class="Number">5</a>  <a id="30831" href="/PLFA-zh/Lambda/#30883" class="InductiveConstructor Operator">_,_⦂_</a>

<a id="30838" class="Keyword">data</a> <a id="Context"></a><a id="30843" href="/PLFA-zh/Lambda/#30843" class="Datatype">Context</a> <a id="30851" class="Symbol">:</a> <a id="30853" class="PrimitiveType">Set</a> <a id="30857" class="Keyword">where</a>
  <a id="Context.∅"></a><a id="30865" href="/PLFA-zh/Lambda/#30865" class="InductiveConstructor">∅</a>     <a id="30871" class="Symbol">:</a> <a id="30873" href="/PLFA-zh/Lambda/#30843" class="Datatype">Context</a>
  <a id="Context._,_⦂_"></a><a id="30883" href="/PLFA-zh/Lambda/#30883" class="InductiveConstructor Operator">_,_⦂_</a> <a id="30889" class="Symbol">:</a> <a id="30891" href="/PLFA-zh/Lambda/#30843" class="Datatype">Context</a> <a id="30899" class="Symbol">→</a> <a id="30901" href="/PLFA-zh/Lambda/#3744" class="Function">Id</a> <a id="30904" class="Symbol">→</a> <a id="30906" href="/PLFA-zh/Lambda/#29169" class="Datatype">Type</a> <a id="30911" class="Symbol">→</a> <a id="30913" href="/PLFA-zh/Lambda/#30843" class="Datatype">Context</a></pre>

<h4 id="exercise-context-">Exercise <code class="highlighter-rouge">Context-≃</code></h4>

<p>Show that <code class="highlighter-rouge">Context</code> is isomorphic to <code class="highlighter-rouge">List (Id × Type)</code>.
For instance, the isomorphism relates the context</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∅ , "s" ⦂ `ℕ ⇒ `ℕ , "z" ⦂ `ℕ
</code></pre></div></div>

<p>to the list</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ ⟨ "z" , `ℕ ⟩ , ⟨ "s" , `ℕ ⇒ `ℕ ⟩ ]
</code></pre></div></div>

<pre class="Agda"><a id="31171" class="Comment">-- Your code goes here</a></pre>

<h3 id="lookup-judgment">Lookup judgment</h3>

<p>We have two forms of <em>judgment</em>.  The first is written</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ∋ x ⦂ A
</code></pre></div></div>

<p>and indicates in context <code class="highlighter-rouge">Γ</code> that variable <code class="highlighter-rouge">x</code> has type <code class="highlighter-rouge">A</code>.
It is called <em>lookup</em>.
For example,</p>

<ul>
  <li><code class="highlighter-rouge">∅ , "s" ⦂ `ℕ ⇒ `ℕ , "z" ⦂ `ℕ ∋ "z" ⦂ `ℕ</code></li>
  <li><code class="highlighter-rouge">∅ , "s" ⦂ `ℕ ⇒ `ℕ , "z" ⦂ `ℕ ∋ "s" ⦂ `ℕ ⇒ `ℕ</code></li>
</ul>

<p>give us the types associated with variables <code class="highlighter-rouge">"z"</code> and <code class="highlighter-rouge">"s"</code>,
respectively.  The symbol <code class="highlighter-rouge">∋</code> (pronounced “ni”, for “in”
backwards) is chosen because checking that <code class="highlighter-rouge">Γ ∋ x ⦂ A</code> is analogous to
checking whether <code class="highlighter-rouge">x ⦂ A</code> appears in a list corresponding to <code class="highlighter-rouge">Γ</code>.</p>

<p>If two variables in a context have the same name, then lookup
should return the most recently bound variable, which <em>shadows</em>
the other variables.  For example,</p>

<ul>
  <li><code class="highlighter-rouge">∅ , "x" ⦂ `ℕ ⇒ `ℕ , "x" ⦂ `ℕ ∋ "x" ⦂ `ℕ</code>.</li>
</ul>

<p>Here <code class="highlighter-rouge">"x" ⦂ `ℕ ⇒ `ℕ</code> is shadowed by <code class="highlighter-rouge">"x" ⦂ `ℕ</code>.</p>

<p>Lookup is formalised as follows:</p>
<pre class="Agda"><a id="32076" class="Keyword">infix</a>  <a id="32083" class="Number">4</a>  <a id="32086" href="/PLFA-zh/Lambda/#32098" class="Datatype Operator">_∋_⦂_</a>

<a id="32093" class="Keyword">data</a> <a id="_∋_⦂_"></a><a id="32098" href="/PLFA-zh/Lambda/#32098" class="Datatype Operator">_∋_⦂_</a> <a id="32104" class="Symbol">:</a> <a id="32106" href="/PLFA-zh/Lambda/#30843" class="Datatype">Context</a> <a id="32114" class="Symbol">→</a> <a id="32116" href="/PLFA-zh/Lambda/#3744" class="Function">Id</a> <a id="32119" class="Symbol">→</a> <a id="32121" href="/PLFA-zh/Lambda/#29169" class="Datatype">Type</a> <a id="32126" class="Symbol">→</a> <a id="32128" class="PrimitiveType">Set</a> <a id="32132" class="Keyword">where</a>

  <a id="_∋_⦂_.Z"></a><a id="32141" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a> <a id="32143" class="Symbol">:</a> <a id="32145" class="Symbol">∀</a> <a id="32147" class="Symbol">{</a><a id="32148" href="/PLFA-zh/Lambda/#32148" class="Bound">Γ</a> <a id="32150" href="/PLFA-zh/Lambda/#32150" class="Bound">x</a> <a id="32152" href="/PLFA-zh/Lambda/#32152" class="Bound">A</a><a id="32153" class="Symbol">}</a>
      <a id="32161" class="Comment">------------------</a>
    <a id="32184" class="Symbol">→</a> <a id="32186" href="/PLFA-zh/Lambda/#32148" class="Bound">Γ</a> <a id="32188" href="/PLFA-zh/Lambda/#30883" class="InductiveConstructor Operator">,</a> <a id="32190" href="/PLFA-zh/Lambda/#32150" class="Bound">x</a> <a id="32192" href="/PLFA-zh/Lambda/#30883" class="InductiveConstructor Operator">⦂</a> <a id="32194" href="/PLFA-zh/Lambda/#32152" class="Bound">A</a> <a id="32196" href="/PLFA-zh/Lambda/#32098" class="Datatype Operator">∋</a> <a id="32198" href="/PLFA-zh/Lambda/#32150" class="Bound">x</a> <a id="32200" href="/PLFA-zh/Lambda/#32098" class="Datatype Operator">⦂</a> <a id="32202" href="/PLFA-zh/Lambda/#32152" class="Bound">A</a>

  <a id="_∋_⦂_.S"></a><a id="32207" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="32209" class="Symbol">:</a> <a id="32211" class="Symbol">∀</a> <a id="32213" class="Symbol">{</a><a id="32214" href="/PLFA-zh/Lambda/#32214" class="Bound">Γ</a> <a id="32216" href="/PLFA-zh/Lambda/#32216" class="Bound">x</a> <a id="32218" href="/PLFA-zh/Lambda/#32218" class="Bound">y</a> <a id="32220" href="/PLFA-zh/Lambda/#32220" class="Bound">A</a> <a id="32222" href="/PLFA-zh/Lambda/#32222" class="Bound">B</a><a id="32223" class="Symbol">}</a>
    <a id="32229" class="Symbol">→</a> <a id="32231" href="/PLFA-zh/Lambda/#32216" class="Bound">x</a> <a id="32233" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.Core.html#660" class="Function Operator">≢</a> <a id="32235" href="/PLFA-zh/Lambda/#32218" class="Bound">y</a>
    <a id="32241" class="Symbol">→</a> <a id="32243" href="/PLFA-zh/Lambda/#32214" class="Bound">Γ</a> <a id="32245" href="/PLFA-zh/Lambda/#32098" class="Datatype Operator">∋</a> <a id="32247" href="/PLFA-zh/Lambda/#32216" class="Bound">x</a> <a id="32249" href="/PLFA-zh/Lambda/#32098" class="Datatype Operator">⦂</a> <a id="32251" href="/PLFA-zh/Lambda/#32220" class="Bound">A</a>
      <a id="32259" class="Comment">------------------</a>
    <a id="32282" class="Symbol">→</a> <a id="32284" href="/PLFA-zh/Lambda/#32214" class="Bound">Γ</a> <a id="32286" href="/PLFA-zh/Lambda/#30883" class="InductiveConstructor Operator">,</a> <a id="32288" href="/PLFA-zh/Lambda/#32218" class="Bound">y</a> <a id="32290" href="/PLFA-zh/Lambda/#30883" class="InductiveConstructor Operator">⦂</a> <a id="32292" href="/PLFA-zh/Lambda/#32222" class="Bound">B</a> <a id="32294" href="/PLFA-zh/Lambda/#32098" class="Datatype Operator">∋</a> <a id="32296" href="/PLFA-zh/Lambda/#32216" class="Bound">x</a> <a id="32298" href="/PLFA-zh/Lambda/#32098" class="Datatype Operator">⦂</a> <a id="32300" href="/PLFA-zh/Lambda/#32220" class="Bound">A</a></pre>

<p>The constructors <code class="highlighter-rouge">Z</code> and <code class="highlighter-rouge">S</code> correspond roughly to the constructors
<code class="highlighter-rouge">here</code> and <code class="highlighter-rouge">there</code> for the element-of relation <code class="highlighter-rouge">_∈_</code> on lists.
Constructor <code class="highlighter-rouge">S</code> takes an additional parameter, which ensures that
when we look up a variable that it is not <em>shadowed</em> by another
variable with the same name earlier in the list.</p>

<h3 id="typing-judgment">Typing judgment</h3>

<p>The second judgment is written</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ⊢ M ⦂ A
</code></pre></div></div>

<p>and indicates in context <code class="highlighter-rouge">Γ</code> that term <code class="highlighter-rouge">M</code> has type <code class="highlighter-rouge">A</code>.
Context <code class="highlighter-rouge">Γ</code> provides types for all the free variables in <code class="highlighter-rouge">M</code>.
For example:</p>

<ul>
  <li><code class="highlighter-rouge">∅ , "s" ⦂ `ℕ ⇒ `ℕ , "z" ⦂ `ℕ ⊢ ` "z" ⦂ `ℕ</code></li>
  <li><code class="highlighter-rouge">∅ , "s" ⦂ `ℕ ⇒ `ℕ , "z" ⦂ `ℕ ⊢ ` "s" ⦂ `ℕ ⇒ `ℕ</code></li>
  <li><code class="highlighter-rouge">∅ , "s" ⦂ `ℕ ⇒ `ℕ , "z" ⦂ `ℕ ⊢ ` "s" · ` "z" ⦂  `ℕ</code></li>
  <li><code class="highlighter-rouge">∅ , "s" ⦂ `ℕ ⇒ `ℕ , "z" ⦂ `ℕ ⊢ ` "s" · (` "s" · ` "z") ⦂  `ℕ</code></li>
  <li><code class="highlighter-rouge">∅ , "s" ⦂ `ℕ ⇒ `ℕ ⊢ (ƛ "z" ⇒ ` "s" · (` "s" · ` "z")) ⦂  `ℕ ⇒ `ℕ</code></li>
  <li><code class="highlighter-rouge">∅ ⊢ ƛ "s" ⇒ ƛ "z" ⇒ ` "s" · (` "s" · ` "z") ⦂  (`ℕ ⇒ `ℕ) ⇒ `ℕ ⇒ `ℕ</code></li>
</ul>

<p>Typing is formalised as follows:</p>
<pre class="Agda"><a id="33254" class="Keyword">infix</a>  <a id="33261" class="Number">4</a>  <a id="33264" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">_⊢_⦂_</a>

<a id="33271" class="Keyword">data</a> <a id="_⊢_⦂_"></a><a id="33276" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">_⊢_⦂_</a> <a id="33282" class="Symbol">:</a> <a id="33284" href="/PLFA-zh/Lambda/#30843" class="Datatype">Context</a> <a id="33292" class="Symbol">→</a> <a id="33294" href="/PLFA-zh/Lambda/#3845" class="Datatype">Term</a> <a id="33299" class="Symbol">→</a> <a id="33301" href="/PLFA-zh/Lambda/#29169" class="Datatype">Type</a> <a id="33306" class="Symbol">→</a> <a id="33308" class="PrimitiveType">Set</a> <a id="33312" class="Keyword">where</a>

  <a id="33321" class="Comment">-- Axiom</a>
  <a id="_⊢_⦂_.⊢`"></a><a id="33332" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="33335" class="Symbol">:</a> <a id="33337" class="Symbol">∀</a> <a id="33339" class="Symbol">{</a><a id="33340" href="/PLFA-zh/Lambda/#33340" class="Bound">Γ</a> <a id="33342" href="/PLFA-zh/Lambda/#33342" class="Bound">x</a> <a id="33344" href="/PLFA-zh/Lambda/#33344" class="Bound">A</a><a id="33345" class="Symbol">}</a>
    <a id="33351" class="Symbol">→</a> <a id="33353" href="/PLFA-zh/Lambda/#33340" class="Bound">Γ</a> <a id="33355" href="/PLFA-zh/Lambda/#32098" class="Datatype Operator">∋</a> <a id="33357" href="/PLFA-zh/Lambda/#33342" class="Bound">x</a> <a id="33359" href="/PLFA-zh/Lambda/#32098" class="Datatype Operator">⦂</a> <a id="33361" href="/PLFA-zh/Lambda/#33344" class="Bound">A</a>
      <a id="33369" class="Comment">-----------</a>
    <a id="33385" class="Symbol">→</a> <a id="33387" href="/PLFA-zh/Lambda/#33340" class="Bound">Γ</a> <a id="33389" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="33391" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="33393" href="/PLFA-zh/Lambda/#33342" class="Bound">x</a> <a id="33395" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="33397" href="/PLFA-zh/Lambda/#33344" class="Bound">A</a>

  <a id="33402" class="Comment">-- ⇒-I</a>
  <a id="_⊢_⦂_.⊢ƛ"></a><a id="33411" href="/PLFA-zh/Lambda/#33411" class="InductiveConstructor">⊢ƛ</a> <a id="33414" class="Symbol">:</a> <a id="33416" class="Symbol">∀</a> <a id="33418" class="Symbol">{</a><a id="33419" href="/PLFA-zh/Lambda/#33419" class="Bound">Γ</a> <a id="33421" href="/PLFA-zh/Lambda/#33421" class="Bound">x</a> <a id="33423" href="/PLFA-zh/Lambda/#33423" class="Bound">N</a> <a id="33425" href="/PLFA-zh/Lambda/#33425" class="Bound">A</a> <a id="33427" href="/PLFA-zh/Lambda/#33427" class="Bound">B</a><a id="33428" class="Symbol">}</a>
    <a id="33434" class="Symbol">→</a> <a id="33436" href="/PLFA-zh/Lambda/#33419" class="Bound">Γ</a> <a id="33438" href="/PLFA-zh/Lambda/#30883" class="InductiveConstructor Operator">,</a> <a id="33440" href="/PLFA-zh/Lambda/#33421" class="Bound">x</a> <a id="33442" href="/PLFA-zh/Lambda/#30883" class="InductiveConstructor Operator">⦂</a> <a id="33444" href="/PLFA-zh/Lambda/#33425" class="Bound">A</a> <a id="33446" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="33448" href="/PLFA-zh/Lambda/#33423" class="Bound">N</a> <a id="33450" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="33452" href="/PLFA-zh/Lambda/#33427" class="Bound">B</a>
      <a id="33460" class="Comment">-------------------</a>
    <a id="33484" class="Symbol">→</a> <a id="33486" href="/PLFA-zh/Lambda/#33419" class="Bound">Γ</a> <a id="33488" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="33490" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="33492" href="/PLFA-zh/Lambda/#33421" class="Bound">x</a> <a id="33494" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="33496" href="/PLFA-zh/Lambda/#33423" class="Bound">N</a> <a id="33498" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="33500" href="/PLFA-zh/Lambda/#33425" class="Bound">A</a> <a id="33502" href="/PLFA-zh/Lambda/#29188" class="InductiveConstructor Operator">⇒</a> <a id="33504" href="/PLFA-zh/Lambda/#33427" class="Bound">B</a>

  <a id="33509" class="Comment">-- ⇒-E</a>
  <a id="_⊢_⦂_._·_"></a><a id="33518" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">_·_</a> <a id="33522" class="Symbol">:</a> <a id="33524" class="Symbol">∀</a> <a id="33526" class="Symbol">{</a><a id="33527" href="/PLFA-zh/Lambda/#33527" class="Bound">Γ</a> <a id="33529" href="/PLFA-zh/Lambda/#33529" class="Bound">L</a> <a id="33531" href="/PLFA-zh/Lambda/#33531" class="Bound">M</a> <a id="33533" href="/PLFA-zh/Lambda/#33533" class="Bound">A</a> <a id="33535" href="/PLFA-zh/Lambda/#33535" class="Bound">B</a><a id="33536" class="Symbol">}</a>
    <a id="33542" class="Symbol">→</a> <a id="33544" href="/PLFA-zh/Lambda/#33527" class="Bound">Γ</a> <a id="33546" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="33548" href="/PLFA-zh/Lambda/#33529" class="Bound">L</a> <a id="33550" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="33552" href="/PLFA-zh/Lambda/#33533" class="Bound">A</a> <a id="33554" href="/PLFA-zh/Lambda/#29188" class="InductiveConstructor Operator">⇒</a> <a id="33556" href="/PLFA-zh/Lambda/#33535" class="Bound">B</a>
    <a id="33562" class="Symbol">→</a> <a id="33564" href="/PLFA-zh/Lambda/#33527" class="Bound">Γ</a> <a id="33566" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="33568" href="/PLFA-zh/Lambda/#33531" class="Bound">M</a> <a id="33570" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="33572" href="/PLFA-zh/Lambda/#33533" class="Bound">A</a>
      <a id="33580" class="Comment">-------------</a>
    <a id="33598" class="Symbol">→</a> <a id="33600" href="/PLFA-zh/Lambda/#33527" class="Bound">Γ</a> <a id="33602" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="33604" href="/PLFA-zh/Lambda/#33529" class="Bound">L</a> <a id="33606" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="33608" href="/PLFA-zh/Lambda/#33531" class="Bound">M</a> <a id="33610" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="33612" href="/PLFA-zh/Lambda/#33535" class="Bound">B</a>

  <a id="33617" class="Comment">-- ℕ-I₁</a>
  <a id="_⊢_⦂_.⊢zero"></a><a id="33627" href="/PLFA-zh/Lambda/#33627" class="InductiveConstructor">⊢zero</a> <a id="33633" class="Symbol">:</a> <a id="33635" class="Symbol">∀</a> <a id="33637" class="Symbol">{</a><a id="33638" href="/PLFA-zh/Lambda/#33638" class="Bound">Γ</a><a id="33639" class="Symbol">}</a>
      <a id="33647" class="Comment">--------------</a>
    <a id="33666" class="Symbol">→</a> <a id="33668" href="/PLFA-zh/Lambda/#33638" class="Bound">Γ</a> <a id="33670" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="33672" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="33678" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="33680" href="/PLFA-zh/Lambda/#29215" class="InductiveConstructor">`ℕ</a>

  <a id="33686" class="Comment">-- ℕ-I₂</a>
  <a id="_⊢_⦂_.⊢suc"></a><a id="33696" href="/PLFA-zh/Lambda/#33696" class="InductiveConstructor">⊢suc</a> <a id="33701" class="Symbol">:</a> <a id="33703" class="Symbol">∀</a> <a id="33705" class="Symbol">{</a><a id="33706" href="/PLFA-zh/Lambda/#33706" class="Bound">Γ</a> <a id="33708" href="/PLFA-zh/Lambda/#33708" class="Bound">M</a><a id="33709" class="Symbol">}</a>
    <a id="33715" class="Symbol">→</a> <a id="33717" href="/PLFA-zh/Lambda/#33706" class="Bound">Γ</a> <a id="33719" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="33721" href="/PLFA-zh/Lambda/#33708" class="Bound">M</a> <a id="33723" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="33725" href="/PLFA-zh/Lambda/#29215" class="InductiveConstructor">`ℕ</a>
      <a id="33734" class="Comment">---------------</a>
    <a id="33754" class="Symbol">→</a> <a id="33756" href="/PLFA-zh/Lambda/#33706" class="Bound">Γ</a> <a id="33758" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="33760" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="33765" href="/PLFA-zh/Lambda/#33708" class="Bound">M</a> <a id="33767" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="33769" href="/PLFA-zh/Lambda/#29215" class="InductiveConstructor">`ℕ</a>

  <a id="33775" class="Comment">-- ℕ-E</a>
  <a id="_⊢_⦂_.⊢case"></a><a id="33784" href="/PLFA-zh/Lambda/#33784" class="InductiveConstructor">⊢case</a> <a id="33790" class="Symbol">:</a> <a id="33792" class="Symbol">∀</a> <a id="33794" class="Symbol">{</a><a id="33795" href="/PLFA-zh/Lambda/#33795" class="Bound">Γ</a> <a id="33797" href="/PLFA-zh/Lambda/#33797" class="Bound">L</a> <a id="33799" href="/PLFA-zh/Lambda/#33799" class="Bound">M</a> <a id="33801" href="/PLFA-zh/Lambda/#33801" class="Bound">x</a> <a id="33803" href="/PLFA-zh/Lambda/#33803" class="Bound">N</a> <a id="33805" href="/PLFA-zh/Lambda/#33805" class="Bound">A</a><a id="33806" class="Symbol">}</a>
    <a id="33812" class="Symbol">→</a> <a id="33814" href="/PLFA-zh/Lambda/#33795" class="Bound">Γ</a> <a id="33816" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="33818" href="/PLFA-zh/Lambda/#33797" class="Bound">L</a> <a id="33820" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="33822" href="/PLFA-zh/Lambda/#29215" class="InductiveConstructor">`ℕ</a>
    <a id="33829" class="Symbol">→</a> <a id="33831" href="/PLFA-zh/Lambda/#33795" class="Bound">Γ</a> <a id="33833" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="33835" href="/PLFA-zh/Lambda/#33799" class="Bound">M</a> <a id="33837" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="33839" href="/PLFA-zh/Lambda/#33805" class="Bound">A</a>
    <a id="33845" class="Symbol">→</a> <a id="33847" href="/PLFA-zh/Lambda/#33795" class="Bound">Γ</a> <a id="33849" href="/PLFA-zh/Lambda/#30883" class="InductiveConstructor Operator">,</a> <a id="33851" href="/PLFA-zh/Lambda/#33801" class="Bound">x</a> <a id="33853" href="/PLFA-zh/Lambda/#30883" class="InductiveConstructor Operator">⦂</a> <a id="33855" href="/PLFA-zh/Lambda/#29215" class="InductiveConstructor">`ℕ</a> <a id="33858" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="33860" href="/PLFA-zh/Lambda/#33803" class="Bound">N</a> <a id="33862" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="33864" href="/PLFA-zh/Lambda/#33805" class="Bound">A</a>
      <a id="33872" class="Comment">-------------------------------------</a>
    <a id="33914" class="Symbol">→</a> <a id="33916" href="/PLFA-zh/Lambda/#33795" class="Bound">Γ</a> <a id="33918" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="33920" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">case</a> <a id="33925" href="/PLFA-zh/Lambda/#33797" class="Bound">L</a> <a id="33927" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">[zero⇒</a> <a id="33934" href="/PLFA-zh/Lambda/#33799" class="Bound">M</a> <a id="33936" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">|suc</a> <a id="33941" href="/PLFA-zh/Lambda/#33801" class="Bound">x</a> <a id="33943" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">⇒</a> <a id="33945" href="/PLFA-zh/Lambda/#33803" class="Bound">N</a> <a id="33947" href="/PLFA-zh/Lambda/#4072" class="InductiveConstructor Operator">]</a> <a id="33949" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="33951" href="/PLFA-zh/Lambda/#33805" class="Bound">A</a>

  <a id="_⊢_⦂_.⊢μ"></a><a id="33956" href="/PLFA-zh/Lambda/#33956" class="InductiveConstructor">⊢μ</a> <a id="33959" class="Symbol">:</a> <a id="33961" class="Symbol">∀</a> <a id="33963" class="Symbol">{</a><a id="33964" href="/PLFA-zh/Lambda/#33964" class="Bound">Γ</a> <a id="33966" href="/PLFA-zh/Lambda/#33966" class="Bound">x</a> <a id="33968" href="/PLFA-zh/Lambda/#33968" class="Bound">M</a> <a id="33970" href="/PLFA-zh/Lambda/#33970" class="Bound">A</a><a id="33971" class="Symbol">}</a>
    <a id="33977" class="Symbol">→</a> <a id="33979" href="/PLFA-zh/Lambda/#33964" class="Bound">Γ</a> <a id="33981" href="/PLFA-zh/Lambda/#30883" class="InductiveConstructor Operator">,</a> <a id="33983" href="/PLFA-zh/Lambda/#33966" class="Bound">x</a> <a id="33985" href="/PLFA-zh/Lambda/#30883" class="InductiveConstructor Operator">⦂</a> <a id="33987" href="/PLFA-zh/Lambda/#33970" class="Bound">A</a> <a id="33989" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="33991" href="/PLFA-zh/Lambda/#33968" class="Bound">M</a> <a id="33993" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="33995" href="/PLFA-zh/Lambda/#33970" class="Bound">A</a>
      <a id="34003" class="Comment">-----------------</a>
    <a id="34025" class="Symbol">→</a> <a id="34027" href="/PLFA-zh/Lambda/#33964" class="Bound">Γ</a> <a id="34029" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="34031" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">μ</a> <a id="34033" href="/PLFA-zh/Lambda/#33966" class="Bound">x</a> <a id="34035" href="/PLFA-zh/Lambda/#4132" class="InductiveConstructor Operator">⇒</a> <a id="34037" href="/PLFA-zh/Lambda/#33968" class="Bound">M</a> <a id="34039" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="34041" href="/PLFA-zh/Lambda/#33970" class="Bound">A</a></pre>

<p>Each type rule is named after the constructor for the
corresponding term.</p>

<p>Most of the rules have a second name, derived from a convention in
logic, whereby the rule is named after the type connective that it
concerns; rules to introduce and to eliminate each connective are
labeled <code class="highlighter-rouge">-I</code> and <code class="highlighter-rouge">-E</code>, respectively. As we read the rules from top to
bottom, introduction and elimination rules do what they say on the
tin: the first <em>introduces</em> a formula for the connective, which
appears in the conclusion but not in the premises; while the second
<em>eliminates</em> a formula for the connective, which appears in a premise
but not in the conclusion. An introduction rule describes how to
construct a value of the type (abstractions yield functions, successor
and zero yield naturals), while an elimination rule describes how to
deconstruct a value of the given type (applications use functions,
case expressions use naturals).</p>

<p>Note also the three places (in <code class="highlighter-rouge">⊢ƛ</code>, <code class="highlighter-rouge">⊢case</code>, and <code class="highlighter-rouge">⊢μ</code>) where the
context is extended with <code class="highlighter-rouge">x</code> and an appropriate type, corresponding to
the three places where a bound variable is introduced.</p>

<p>The rules are deterministic, in that at most one rule applies to every term.</p>

<h3 id="impossible">Checking inequality and postulating the impossible</h3>

<p>The following function makes it convenient to assert an inequality:</p>
<pre class="Agda"><a id="_≠_"></a><a id="35397" href="/PLFA-zh/Lambda/#35397" class="Function Operator">_≠_</a> <a id="35401" class="Symbol">:</a> <a id="35403" class="Symbol">∀</a> <a id="35405" class="Symbol">(</a><a id="35406" href="/PLFA-zh/Lambda/#35406" class="Bound">x</a> <a id="35408" href="/PLFA-zh/Lambda/#35408" class="Bound">y</a> <a id="35410" class="Symbol">:</a> <a id="35412" href="/PLFA-zh/Lambda/#3744" class="Function">Id</a><a id="35414" class="Symbol">)</a> <a id="35416" class="Symbol">→</a> <a id="35418" href="/PLFA-zh/Lambda/#35406" class="Bound">x</a> <a id="35420" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Binary.PropositionalEquality.Core.html#660" class="Function Operator">≢</a> <a id="35422" href="/PLFA-zh/Lambda/#35408" class="Bound">y</a>
<a id="35424" href="/PLFA-zh/Lambda/#35424" class="Bound">x</a> <a id="35426" href="/PLFA-zh/Lambda/#35397" class="Function Operator">≠</a> <a id="35428" href="/PLFA-zh/Lambda/#35428" class="Bound">y</a>  <a id="35431" class="Keyword">with</a> <a id="35436" href="/PLFA-zh/Lambda/#35424" class="Bound">x</a> <a id="35438" href="https://agda.github.io/agda-stdlib/v0.17/Data.String.Unsafe.html#749" class="Function Operator">≟</a> <a id="35440" href="/PLFA-zh/Lambda/#35428" class="Bound">y</a>
<a id="35442" class="Symbol">...</a>       <a id="35452" class="Symbol">|</a> <a id="35454" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="35458" href="/PLFA-zh/Lambda/#35458" class="Bound">x≢y</a>  <a id="35463" class="Symbol">=</a>  <a id="35466" href="/PLFA-zh/Lambda/#35458" class="Bound">x≢y</a>
<a id="35470" class="Symbol">...</a>       <a id="35480" class="Symbol">|</a> <a id="35482" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="35486" class="Symbol">_</a>    <a id="35491" class="Symbol">=</a>  <a id="35494" href="https://agda.github.io/agda-stdlib/v0.17/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="35501" href="/PLFA-zh/Lambda/#35530" class="Postulate">impossible</a>
  <a id="35514" class="Keyword">where</a> <a id="35520" class="Keyword">postulate</a> <a id="35530" href="/PLFA-zh/Lambda/#35530" class="Postulate">impossible</a> <a id="35541" class="Symbol">:</a> <a id="35543" href="https://agda.github.io/agda-stdlib/v0.17/Data.Empty.html#243" class="Datatype">⊥</a></pre>
<p>Here <code class="highlighter-rouge">_≟_</code> is the function that tests two identifiers for equality.
We intend to apply the function only when the
two arguments are indeed unequal, and indicate that the second
case should never arise by postulating a term <code class="highlighter-rouge">impossible</code> of
the empty type <code class="highlighter-rouge">⊥</code>.  If we use C-c C-n to normalise the term</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"a" ≠ "a"
</code></pre></div></div>

<p>Agda will return an answer warning us that the impossible has occurred:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⊥-elim (.plfa.Lambda.impossible "a" "a" refl)
</code></pre></div></div>

<p>While postulating the impossible is a useful technique, it must be
used with care, since such postulation could allow us to provide
evidence of <em>any</em> proposition whatsoever, regardless of its truth.</p>

<h3 id="derivation">Example type derivations</h3>

<p>Type derivations correspond to trees. In informal notation, here
is a type derivation for the Church numeral two,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                        ∋s                     ∋z
                        ------------------ ⊢`  -------------- ⊢`
∋s                      Γ₂ ⊢ ` "s" ⦂ A ⇒ A     Γ₂ ⊢ ` "z" ⦂ A
------------------ ⊢`   ------------------------------------- _·_
Γ₂ ⊢ ` "s" ⦂ A ⇒ A      Γ₂ ⊢ ` "s" · ` "z" ⦂ A
---------------------------------------------- _·_
Γ₂ ⊢ ` "s" · (` "s" · ` "z") ⦂ A
-------------------------------------------- ⊢ƛ
Γ₁ ⊢ ƛ "z" ⇒ ` "s" · (` "s" · ` "z") ⦂ A ⇒ A
------------------------------------------------------------- ⊢ƛ
Γ ⊢ ƛ "s" ⇒ ƛ "z" ⇒ ` "s" · (` "s" · ` "z") ⦂ (A ⇒ A) ⇒ A ⇒ A
</code></pre></div></div>

<p>where <code class="highlighter-rouge">∋s</code> and <code class="highlighter-rouge">∋z</code> abbreviate the two derivations,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>             ---------------- Z
"s" ≢ "z"    Γ₁ ∋ "s" ⦂ A ⇒ A
----------------------------- S       ------------- Z
Γ₂ ∋ "s" ⦂ A ⇒ A                       Γ₂ ∋ "z" ⦂ A
</code></pre></div></div>

<p>and where <code class="highlighter-rouge">Γ₁ = Γ , "s" ⦂ A ⇒ A</code> and <code class="highlighter-rouge">Γ₂ = Γ , "s" ⦂ A ⇒ A , "z" ⦂ A</code>.
The typing derivation is valid for any <code class="highlighter-rouge">Γ</code> and <code class="highlighter-rouge">A</code>, for instance,
we might take <code class="highlighter-rouge">Γ</code> to be <code class="highlighter-rouge">∅</code> and <code class="highlighter-rouge">A</code> to be <code class="highlighter-rouge">`ℕ</code>.</p>

<p>Here is the above typing derivation formalised in Agda:</p>
<pre class="Agda"><a id="Ch"></a><a id="37492" href="/PLFA-zh/Lambda/#37492" class="Function">Ch</a> <a id="37495" class="Symbol">:</a> <a id="37497" href="/PLFA-zh/Lambda/#29169" class="Datatype">Type</a> <a id="37502" class="Symbol">→</a> <a id="37504" href="/PLFA-zh/Lambda/#29169" class="Datatype">Type</a>
<a id="37509" href="/PLFA-zh/Lambda/#37492" class="Function">Ch</a> <a id="37512" href="/PLFA-zh/Lambda/#37512" class="Bound">A</a> <a id="37514" class="Symbol">=</a> <a id="37516" class="Symbol">(</a><a id="37517" href="/PLFA-zh/Lambda/#37512" class="Bound">A</a> <a id="37519" href="/PLFA-zh/Lambda/#29188" class="InductiveConstructor Operator">⇒</a> <a id="37521" href="/PLFA-zh/Lambda/#37512" class="Bound">A</a><a id="37522" class="Symbol">)</a> <a id="37524" href="/PLFA-zh/Lambda/#29188" class="InductiveConstructor Operator">⇒</a> <a id="37526" href="/PLFA-zh/Lambda/#37512" class="Bound">A</a> <a id="37528" href="/PLFA-zh/Lambda/#29188" class="InductiveConstructor Operator">⇒</a> <a id="37530" href="/PLFA-zh/Lambda/#37512" class="Bound">A</a>

<a id="⊢twoᶜ"></a><a id="37533" href="/PLFA-zh/Lambda/#37533" class="Function">⊢twoᶜ</a> <a id="37539" class="Symbol">:</a> <a id="37541" class="Symbol">∀</a> <a id="37543" class="Symbol">{</a><a id="37544" href="/PLFA-zh/Lambda/#37544" class="Bound">Γ</a> <a id="37546" href="/PLFA-zh/Lambda/#37546" class="Bound">A</a><a id="37547" class="Symbol">}</a> <a id="37549" class="Symbol">→</a> <a id="37551" href="/PLFA-zh/Lambda/#37544" class="Bound">Γ</a> <a id="37553" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="37555" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="37560" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="37562" href="/PLFA-zh/Lambda/#37492" class="Function">Ch</a> <a id="37565" href="/PLFA-zh/Lambda/#37546" class="Bound">A</a>
<a id="37567" href="/PLFA-zh/Lambda/#37533" class="Function">⊢twoᶜ</a> <a id="37573" class="Symbol">=</a> <a id="37575" href="/PLFA-zh/Lambda/#33411" class="InductiveConstructor">⊢ƛ</a> <a id="37578" class="Symbol">(</a><a id="37579" href="/PLFA-zh/Lambda/#33411" class="InductiveConstructor">⊢ƛ</a> <a id="37582" class="Symbol">(</a><a id="37583" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="37586" href="/PLFA-zh/Lambda/#37619" class="Function">∋s</a> <a id="37589" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="37591" class="Symbol">(</a><a id="37592" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="37595" href="/PLFA-zh/Lambda/#37619" class="Function">∋s</a> <a id="37598" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="37600" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="37603" href="/PLFA-zh/Lambda/#37642" class="Function">∋z</a><a id="37605" class="Symbol">)))</a>
  <a id="37611" class="Keyword">where</a>
  <a id="37619" href="/PLFA-zh/Lambda/#37619" class="Function">∋s</a> <a id="37622" class="Symbol">=</a> <a id="37624" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="37626" class="Symbol">(</a><a id="37627" class="String">&quot;s&quot;</a> <a id="37631" href="/PLFA-zh/Lambda/#35397" class="Function Operator">≠</a> <a id="37633" class="String">&quot;z&quot;</a><a id="37636" class="Symbol">)</a> <a id="37638" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a>
  <a id="37642" href="/PLFA-zh/Lambda/#37642" class="Function">∋z</a> <a id="37645" class="Symbol">=</a> <a id="37647" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a></pre>

<p>Here are the typings corresponding to computing two plus two:</p>
<pre class="Agda"><a id="⊢two"></a><a id="37736" href="/PLFA-zh/Lambda/#37736" class="Function">⊢two</a> <a id="37741" class="Symbol">:</a> <a id="37743" class="Symbol">∀</a> <a id="37745" class="Symbol">{</a><a id="37746" href="/PLFA-zh/Lambda/#37746" class="Bound">Γ</a><a id="37747" class="Symbol">}</a> <a id="37749" class="Symbol">→</a> <a id="37751" href="/PLFA-zh/Lambda/#37746" class="Bound">Γ</a> <a id="37753" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="37755" href="/PLFA-zh/Lambda/#4589" class="Function">two</a> <a id="37759" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="37761" href="/PLFA-zh/Lambda/#29215" class="InductiveConstructor">`ℕ</a>
<a id="37764" href="/PLFA-zh/Lambda/#37736" class="Function">⊢two</a> <a id="37769" class="Symbol">=</a> <a id="37771" href="/PLFA-zh/Lambda/#33696" class="InductiveConstructor">⊢suc</a> <a id="37776" class="Symbol">(</a><a id="37777" href="/PLFA-zh/Lambda/#33696" class="InductiveConstructor">⊢suc</a> <a id="37782" href="/PLFA-zh/Lambda/#33627" class="InductiveConstructor">⊢zero</a><a id="37787" class="Symbol">)</a>

<a id="⊢plus"></a><a id="37790" href="/PLFA-zh/Lambda/#37790" class="Function">⊢plus</a> <a id="37796" class="Symbol">:</a> <a id="37798" class="Symbol">∀</a> <a id="37800" class="Symbol">{</a><a id="37801" href="/PLFA-zh/Lambda/#37801" class="Bound">Γ</a><a id="37802" class="Symbol">}</a> <a id="37804" class="Symbol">→</a> <a id="37806" href="/PLFA-zh/Lambda/#37801" class="Bound">Γ</a> <a id="37808" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="37810" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="37815" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="37817" href="/PLFA-zh/Lambda/#29215" class="InductiveConstructor">`ℕ</a> <a id="37820" href="/PLFA-zh/Lambda/#29188" class="InductiveConstructor Operator">⇒</a> <a id="37822" href="/PLFA-zh/Lambda/#29215" class="InductiveConstructor">`ℕ</a> <a id="37825" href="/PLFA-zh/Lambda/#29188" class="InductiveConstructor Operator">⇒</a> <a id="37827" href="/PLFA-zh/Lambda/#29215" class="InductiveConstructor">`ℕ</a>
<a id="37830" href="/PLFA-zh/Lambda/#37790" class="Function">⊢plus</a> <a id="37836" class="Symbol">=</a> <a id="37838" href="/PLFA-zh/Lambda/#33956" class="InductiveConstructor">⊢μ</a> <a id="37841" class="Symbol">(</a><a id="37842" href="/PLFA-zh/Lambda/#33411" class="InductiveConstructor">⊢ƛ</a> <a id="37845" class="Symbol">(</a><a id="37846" href="/PLFA-zh/Lambda/#33411" class="InductiveConstructor">⊢ƛ</a> <a id="37849" class="Symbol">(</a><a id="37850" href="/PLFA-zh/Lambda/#33784" class="InductiveConstructor">⊢case</a> <a id="37856" class="Symbol">(</a><a id="37857" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="37860" href="/PLFA-zh/Lambda/#37985" class="Function">∋m</a><a id="37862" class="Symbol">)</a> <a id="37864" class="Symbol">(</a><a id="37865" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="37868" href="/PLFA-zh/Lambda/#38011" class="Function">∋n</a><a id="37870" class="Symbol">)</a>
         <a id="37881" class="Symbol">(</a><a id="37882" href="/PLFA-zh/Lambda/#33696" class="InductiveConstructor">⊢suc</a> <a id="37887" class="Symbol">(</a><a id="37888" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="37891" href="/PLFA-zh/Lambda/#37927" class="Function">∋+</a> <a id="37894" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="37896" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="37899" href="/PLFA-zh/Lambda/#38021" class="Function">∋m′</a> <a id="37903" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="37905" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="37908" href="/PLFA-zh/Lambda/#38031" class="Function">∋n′</a><a id="37911" class="Symbol">)))))</a>
  <a id="37919" class="Keyword">where</a>
  <a id="37927" href="/PLFA-zh/Lambda/#37927" class="Function">∋+</a>  <a id="37931" class="Symbol">=</a> <a id="37933" class="Symbol">(</a><a id="37934" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="37936" class="Symbol">(</a><a id="37937" class="String">&quot;+&quot;</a> <a id="37941" href="/PLFA-zh/Lambda/#35397" class="Function Operator">≠</a> <a id="37943" class="String">&quot;m&quot;</a><a id="37946" class="Symbol">)</a> <a id="37948" class="Symbol">(</a><a id="37949" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="37951" class="Symbol">(</a><a id="37952" class="String">&quot;+&quot;</a> <a id="37956" href="/PLFA-zh/Lambda/#35397" class="Function Operator">≠</a> <a id="37958" class="String">&quot;n&quot;</a><a id="37961" class="Symbol">)</a> <a id="37963" class="Symbol">(</a><a id="37964" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="37966" class="Symbol">(</a><a id="37967" class="String">&quot;+&quot;</a> <a id="37971" href="/PLFA-zh/Lambda/#35397" class="Function Operator">≠</a> <a id="37973" class="String">&quot;m&quot;</a><a id="37976" class="Symbol">)</a> <a id="37978" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a><a id="37979" class="Symbol">)))</a>
  <a id="37985" href="/PLFA-zh/Lambda/#37985" class="Function">∋m</a>  <a id="37989" class="Symbol">=</a> <a id="37991" class="Symbol">(</a><a id="37992" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="37994" class="Symbol">(</a><a id="37995" class="String">&quot;m&quot;</a> <a id="37999" href="/PLFA-zh/Lambda/#35397" class="Function Operator">≠</a> <a id="38001" class="String">&quot;n&quot;</a><a id="38004" class="Symbol">)</a> <a id="38006" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a><a id="38007" class="Symbol">)</a>
  <a id="38011" href="/PLFA-zh/Lambda/#38011" class="Function">∋n</a>  <a id="38015" class="Symbol">=</a> <a id="38017" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a>
  <a id="38021" href="/PLFA-zh/Lambda/#38021" class="Function">∋m′</a> <a id="38025" class="Symbol">=</a> <a id="38027" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a>
  <a id="38031" href="/PLFA-zh/Lambda/#38031" class="Function">∋n′</a> <a id="38035" class="Symbol">=</a> <a id="38037" class="Symbol">(</a><a id="38038" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="38040" class="Symbol">(</a><a id="38041" class="String">&quot;n&quot;</a> <a id="38045" href="/PLFA-zh/Lambda/#35397" class="Function Operator">≠</a> <a id="38047" class="String">&quot;m&quot;</a><a id="38050" class="Symbol">)</a> <a id="38052" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a><a id="38053" class="Symbol">)</a>

<a id="⊢2+2"></a><a id="38056" href="/PLFA-zh/Lambda/#38056" class="Function">⊢2+2</a> <a id="38061" class="Symbol">:</a> <a id="38063" href="/PLFA-zh/Lambda/#30865" class="InductiveConstructor">∅</a> <a id="38065" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="38067" href="/PLFA-zh/Lambda/#4623" class="Function">plus</a> <a id="38072" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="38074" href="/PLFA-zh/Lambda/#4589" class="Function">two</a> <a id="38078" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="38080" href="/PLFA-zh/Lambda/#4589" class="Function">two</a> <a id="38084" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="38086" href="/PLFA-zh/Lambda/#29215" class="InductiveConstructor">`ℕ</a>
<a id="38089" href="/PLFA-zh/Lambda/#38056" class="Function">⊢2+2</a> <a id="38094" class="Symbol">=</a> <a id="38096" href="/PLFA-zh/Lambda/#37790" class="Function">⊢plus</a> <a id="38102" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="38104" href="/PLFA-zh/Lambda/#37736" class="Function">⊢two</a> <a id="38109" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="38111" href="/PLFA-zh/Lambda/#37736" class="Function">⊢two</a></pre>
<p>In contrast to our earlier examples, here we have typed <code class="highlighter-rouge">two</code> and <code class="highlighter-rouge">plus</code>
in an arbitrary context rather than the empty context; this makes it easy
to use them inside other binding contexts as well as at the top level.
Here the two lookup judgments <code class="highlighter-rouge">∋m</code> and <code class="highlighter-rouge">∋m′</code> refer to two different
bindings of variables named <code class="highlighter-rouge">"m"</code>.  In contrast, the two judgments <code class="highlighter-rouge">∋n</code> and
<code class="highlighter-rouge">∋n′</code> both refer to the same binding of <code class="highlighter-rouge">"n"</code> but accessed in different
contexts, the first where “n” is the last binding in the context, and
the second after “m” is bound in the successor branch of the case.</p>

<p>And here are typings for the remainder of the Church example:</p>
<pre class="Agda"><a id="⊢plusᶜ"></a><a id="38774" href="/PLFA-zh/Lambda/#38774" class="Function">⊢plusᶜ</a> <a id="38781" class="Symbol">:</a> <a id="38783" class="Symbol">∀</a> <a id="38785" class="Symbol">{</a><a id="38786" href="/PLFA-zh/Lambda/#38786" class="Bound">Γ</a> <a id="38788" href="/PLFA-zh/Lambda/#38788" class="Bound">A</a><a id="38789" class="Symbol">}</a> <a id="38791" class="Symbol">→</a> <a id="38793" href="/PLFA-zh/Lambda/#38786" class="Bound">Γ</a>  <a id="38796" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="38798" href="/PLFA-zh/Lambda/#5900" class="Function">plusᶜ</a> <a id="38804" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="38806" href="/PLFA-zh/Lambda/#37492" class="Function">Ch</a> <a id="38809" href="/PLFA-zh/Lambda/#38788" class="Bound">A</a> <a id="38811" href="/PLFA-zh/Lambda/#29188" class="InductiveConstructor Operator">⇒</a> <a id="38813" href="/PLFA-zh/Lambda/#37492" class="Function">Ch</a> <a id="38816" href="/PLFA-zh/Lambda/#38788" class="Bound">A</a> <a id="38818" href="/PLFA-zh/Lambda/#29188" class="InductiveConstructor Operator">⇒</a> <a id="38820" href="/PLFA-zh/Lambda/#37492" class="Function">Ch</a> <a id="38823" href="/PLFA-zh/Lambda/#38788" class="Bound">A</a>
<a id="38825" href="/PLFA-zh/Lambda/#38774" class="Function">⊢plusᶜ</a> <a id="38832" class="Symbol">=</a> <a id="38834" href="/PLFA-zh/Lambda/#33411" class="InductiveConstructor">⊢ƛ</a> <a id="38837" class="Symbol">(</a><a id="38838" href="/PLFA-zh/Lambda/#33411" class="InductiveConstructor">⊢ƛ</a> <a id="38841" class="Symbol">(</a><a id="38842" href="/PLFA-zh/Lambda/#33411" class="InductiveConstructor">⊢ƛ</a> <a id="38845" class="Symbol">(</a><a id="38846" href="/PLFA-zh/Lambda/#33411" class="InductiveConstructor">⊢ƛ</a> <a id="38849" class="Symbol">(</a><a id="38850" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="38853" href="/PLFA-zh/Lambda/#38904" class="Function">∋m</a> <a id="38856" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="38858" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="38861" href="/PLFA-zh/Lambda/#38998" class="Function">∋s</a> <a id="38864" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="38866" class="Symbol">(</a><a id="38867" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="38870" href="/PLFA-zh/Lambda/#38959" class="Function">∋n</a> <a id="38873" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="38875" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="38878" href="/PLFA-zh/Lambda/#38998" class="Function">∋s</a> <a id="38881" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="38883" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="38886" href="/PLFA-zh/Lambda/#39021" class="Function">∋z</a><a id="38888" class="Symbol">)))))</a>
  <a id="38896" class="Keyword">where</a>
  <a id="38904" href="/PLFA-zh/Lambda/#38904" class="Function">∋m</a> <a id="38907" class="Symbol">=</a> <a id="38909" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="38911" class="Symbol">(</a><a id="38912" class="String">&quot;m&quot;</a> <a id="38916" href="/PLFA-zh/Lambda/#35397" class="Function Operator">≠</a> <a id="38918" class="String">&quot;z&quot;</a><a id="38921" class="Symbol">)</a> <a id="38923" class="Symbol">(</a><a id="38924" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="38926" class="Symbol">(</a><a id="38927" class="String">&quot;m&quot;</a> <a id="38931" href="/PLFA-zh/Lambda/#35397" class="Function Operator">≠</a> <a id="38933" class="String">&quot;s&quot;</a><a id="38936" class="Symbol">)</a> <a id="38938" class="Symbol">(</a><a id="38939" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="38941" class="Symbol">(</a><a id="38942" class="String">&quot;m&quot;</a> <a id="38946" href="/PLFA-zh/Lambda/#35397" class="Function Operator">≠</a> <a id="38948" class="String">&quot;n&quot;</a><a id="38951" class="Symbol">)</a> <a id="38953" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a><a id="38954" class="Symbol">))</a>
  <a id="38959" href="/PLFA-zh/Lambda/#38959" class="Function">∋n</a> <a id="38962" class="Symbol">=</a> <a id="38964" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="38966" class="Symbol">(</a><a id="38967" class="String">&quot;n&quot;</a> <a id="38971" href="/PLFA-zh/Lambda/#35397" class="Function Operator">≠</a> <a id="38973" class="String">&quot;z&quot;</a><a id="38976" class="Symbol">)</a> <a id="38978" class="Symbol">(</a><a id="38979" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="38981" class="Symbol">(</a><a id="38982" class="String">&quot;n&quot;</a> <a id="38986" href="/PLFA-zh/Lambda/#35397" class="Function Operator">≠</a> <a id="38988" class="String">&quot;s&quot;</a><a id="38991" class="Symbol">)</a> <a id="38993" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a><a id="38994" class="Symbol">)</a>
  <a id="38998" href="/PLFA-zh/Lambda/#38998" class="Function">∋s</a> <a id="39001" class="Symbol">=</a> <a id="39003" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="39005" class="Symbol">(</a><a id="39006" class="String">&quot;s&quot;</a> <a id="39010" href="/PLFA-zh/Lambda/#35397" class="Function Operator">≠</a> <a id="39012" class="String">&quot;z&quot;</a><a id="39015" class="Symbol">)</a> <a id="39017" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a>
  <a id="39021" href="/PLFA-zh/Lambda/#39021" class="Function">∋z</a> <a id="39024" class="Symbol">=</a> <a id="39026" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a>

<a id="⊢sucᶜ"></a><a id="39029" href="/PLFA-zh/Lambda/#39029" class="Function">⊢sucᶜ</a> <a id="39035" class="Symbol">:</a> <a id="39037" class="Symbol">∀</a> <a id="39039" class="Symbol">{</a><a id="39040" href="/PLFA-zh/Lambda/#39040" class="Bound">Γ</a><a id="39041" class="Symbol">}</a> <a id="39043" class="Symbol">→</a> <a id="39045" href="/PLFA-zh/Lambda/#39040" class="Bound">Γ</a> <a id="39047" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="39049" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="39054" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="39056" href="/PLFA-zh/Lambda/#29215" class="InductiveConstructor">`ℕ</a> <a id="39059" href="/PLFA-zh/Lambda/#29188" class="InductiveConstructor Operator">⇒</a> <a id="39061" href="/PLFA-zh/Lambda/#29215" class="InductiveConstructor">`ℕ</a>
<a id="39064" href="/PLFA-zh/Lambda/#39029" class="Function">⊢sucᶜ</a> <a id="39070" class="Symbol">=</a> <a id="39072" href="/PLFA-zh/Lambda/#33411" class="InductiveConstructor">⊢ƛ</a> <a id="39075" class="Symbol">(</a><a id="39076" href="/PLFA-zh/Lambda/#33696" class="InductiveConstructor">⊢suc</a> <a id="39081" class="Symbol">(</a><a id="39082" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="39085" href="/PLFA-zh/Lambda/#39100" class="Function">∋n</a><a id="39087" class="Symbol">))</a>
  <a id="39092" class="Keyword">where</a>
  <a id="39100" href="/PLFA-zh/Lambda/#39100" class="Function">∋n</a> <a id="39103" class="Symbol">=</a> <a id="39105" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a>

<a id="⊢2+2ᶜ"></a><a id="39108" href="/PLFA-zh/Lambda/#39108" class="Function">⊢2+2ᶜ</a> <a id="39114" class="Symbol">:</a> <a id="39116" href="/PLFA-zh/Lambda/#30865" class="InductiveConstructor">∅</a> <a id="39118" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="39120" href="/PLFA-zh/Lambda/#5900" class="Function">plusᶜ</a> <a id="39126" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="39128" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="39133" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="39135" href="/PLFA-zh/Lambda/#5839" class="Function">twoᶜ</a> <a id="39140" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="39142" href="/PLFA-zh/Lambda/#6004" class="Function">sucᶜ</a> <a id="39147" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="39149" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="39155" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="39157" href="/PLFA-zh/Lambda/#29215" class="InductiveConstructor">`ℕ</a>
<a id="39160" href="/PLFA-zh/Lambda/#39108" class="Function">⊢2+2ᶜ</a> <a id="39166" class="Symbol">=</a> <a id="39168" href="/PLFA-zh/Lambda/#38774" class="Function">⊢plusᶜ</a> <a id="39175" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="39177" href="/PLFA-zh/Lambda/#37533" class="Function">⊢twoᶜ</a> <a id="39183" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="39185" href="/PLFA-zh/Lambda/#37533" class="Function">⊢twoᶜ</a> <a id="39191" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="39193" href="/PLFA-zh/Lambda/#39029" class="Function">⊢sucᶜ</a> <a id="39199" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="39201" href="/PLFA-zh/Lambda/#33627" class="InductiveConstructor">⊢zero</a></pre>

<h3 id="interaction-with-agda">Interaction with Agda</h3>

<p>Construction of a type derivation may be done interactively.
Start with the declaration:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⊢sucᶜ : ∅ ⊢ sucᶜ ⦂ `ℕ ⇒ `ℕ
⊢sucᶜ = ?
</code></pre></div></div>

<p>Typing C-c C-l causes Agda to create a hole and tell us its expected type:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⊢sucᶜ = { }0
?0 : ∅ ⊢ sucᶜ ⦂ `ℕ ⇒ `ℕ
</code></pre></div></div>

<p>Now we fill in the hole by typing C-c C-r. Agda observes that
the outermost term in <code class="highlighter-rouge">sucᶜ</code> is <code class="highlighter-rouge">ƛ</code>, which is typed using <code class="highlighter-rouge">⊢ƛ</code>. The
<code class="highlighter-rouge">⊢ƛ</code> rule in turn takes one argument, which Agda leaves as a hole:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⊢sucᶜ = ⊢ƛ { }1
?1 : ∅ , "n" ⦂ `ℕ ⊢ `suc ` "n" ⦂ `ℕ
</code></pre></div></div>

<p>We can fill in the hole by typing C-c C-r again:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⊢sucᶜ = ⊢ƛ (⊢suc { }2)
?2 : ∅ , "n" ⦂ `ℕ ⊢ ` "n" ⦂ `ℕ
</code></pre></div></div>

<p>And again:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⊢suc′ = ⊢ƛ (⊢suc (⊢` { }3))
?3 : ∅ , "n" ⦂ `ℕ ∋ "n" ⦂ `ℕ
</code></pre></div></div>

<p>A further attempt with C-c C-r yields the message:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Don't know which constructor to introduce of Z or S
</code></pre></div></div>

<p>We can fill in <code class="highlighter-rouge">Z</code> by hand. If we type C-c C-space, Agda will confirm we are done:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⊢suc′ = ⊢ƛ (⊢suc (⊢` Z))
</code></pre></div></div>

<p>The entire process can be automated using Agsy, invoked with C-c C-a.</p>

<p>Chapter <a href="/PLFA-zh/Inference/">Inference</a>
will show how to use Agda to compute type derivations directly.</p>

<h3 id="lookup-is-injective">Lookup is injective</h3>

<p>The lookup relation <code class="highlighter-rouge">Γ ∋ x ⦂ A</code> is injective, in that for each <code class="highlighter-rouge">Γ</code> and <code class="highlighter-rouge">x</code>
there is at most one <code class="highlighter-rouge">A</code> such that the judgment holds:</p>
<pre class="Agda"><a id="∋-injective"></a><a id="40518" href="/PLFA-zh/Lambda/#40518" class="Function">∋-injective</a> <a id="40530" class="Symbol">:</a> <a id="40532" class="Symbol">∀</a> <a id="40534" class="Symbol">{</a><a id="40535" href="/PLFA-zh/Lambda/#40535" class="Bound">Γ</a> <a id="40537" href="/PLFA-zh/Lambda/#40537" class="Bound">x</a> <a id="40539" href="/PLFA-zh/Lambda/#40539" class="Bound">A</a> <a id="40541" href="/PLFA-zh/Lambda/#40541" class="Bound">B</a><a id="40542" class="Symbol">}</a> <a id="40544" class="Symbol">→</a> <a id="40546" href="/PLFA-zh/Lambda/#40535" class="Bound">Γ</a> <a id="40548" href="/PLFA-zh/Lambda/#32098" class="Datatype Operator">∋</a> <a id="40550" href="/PLFA-zh/Lambda/#40537" class="Bound">x</a> <a id="40552" href="/PLFA-zh/Lambda/#32098" class="Datatype Operator">⦂</a> <a id="40554" href="/PLFA-zh/Lambda/#40539" class="Bound">A</a> <a id="40556" class="Symbol">→</a> <a id="40558" href="/PLFA-zh/Lambda/#40535" class="Bound">Γ</a> <a id="40560" href="/PLFA-zh/Lambda/#32098" class="Datatype Operator">∋</a> <a id="40562" href="/PLFA-zh/Lambda/#40537" class="Bound">x</a> <a id="40564" href="/PLFA-zh/Lambda/#32098" class="Datatype Operator">⦂</a> <a id="40566" href="/PLFA-zh/Lambda/#40541" class="Bound">B</a> <a id="40568" class="Symbol">→</a> <a id="40570" href="/PLFA-zh/Lambda/#40539" class="Bound">A</a> <a id="40572" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="40574" href="/PLFA-zh/Lambda/#40541" class="Bound">B</a>
<a id="40576" href="/PLFA-zh/Lambda/#40518" class="Function">∋-injective</a> <a id="40588" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a>        <a id="40597" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a>          <a id="40608" class="Symbol">=</a>  <a id="40611" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="40616" href="/PLFA-zh/Lambda/#40518" class="Function">∋-injective</a> <a id="40628" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a>        <a id="40637" class="Symbol">(</a><a id="40638" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="40640" href="/PLFA-zh/Lambda/#40640" class="Bound">x≢</a> <a id="40643" class="Symbol">_)</a>   <a id="40648" class="Symbol">=</a>  <a id="40651" href="https://agda.github.io/agda-stdlib/v0.17/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="40658" class="Symbol">(</a><a id="40659" href="/PLFA-zh/Lambda/#40640" class="Bound">x≢</a> <a id="40662" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="40666" class="Symbol">)</a>
<a id="40668" href="/PLFA-zh/Lambda/#40518" class="Function">∋-injective</a> <a id="40680" class="Symbol">(</a><a id="40681" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="40683" href="/PLFA-zh/Lambda/#40683" class="Bound">x≢</a> <a id="40686" class="Symbol">_)</a> <a id="40689" href="/PLFA-zh/Lambda/#32141" class="InductiveConstructor">Z</a>          <a id="40700" class="Symbol">=</a>  <a id="40703" href="https://agda.github.io/agda-stdlib/v0.17/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="40710" class="Symbol">(</a><a id="40711" href="/PLFA-zh/Lambda/#40683" class="Bound">x≢</a> <a id="40714" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="40718" class="Symbol">)</a>
<a id="40720" href="/PLFA-zh/Lambda/#40518" class="Function">∋-injective</a> <a id="40732" class="Symbol">(</a><a id="40733" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="40735" class="Symbol">_</a> <a id="40737" href="/PLFA-zh/Lambda/#40737" class="Bound">∋x</a><a id="40739" class="Symbol">)</a> <a id="40741" class="Symbol">(</a><a id="40742" href="/PLFA-zh/Lambda/#32207" class="InductiveConstructor">S</a> <a id="40744" class="Symbol">_</a> <a id="40746" href="/PLFA-zh/Lambda/#40746" class="Bound">∋x′</a><a id="40749" class="Symbol">)</a>  <a id="40752" class="Symbol">=</a>  <a id="40755" href="/PLFA-zh/Lambda/#40518" class="Function">∋-injective</a> <a id="40767" href="/PLFA-zh/Lambda/#40737" class="Bound">∋x</a> <a id="40770" href="/PLFA-zh/Lambda/#40746" class="Bound">∋x′</a></pre>

<p>The typing relation <code class="highlighter-rouge">Γ ⊢ M ⦂ A</code> is not injective. For example, in any <code class="highlighter-rouge">Γ</code>
the term <code class="highlighter-rouge">ƛ "x" ⇒ "x"</code> has type <code class="highlighter-rouge">A ⇒ A</code> for any type <code class="highlighter-rouge">A</code>.</p>

<h3 id="non-examples">Non-examples</h3>

<p>We can also show that terms are <em>not</em> typeable.  For example, here is
a formal proof that it is not possible to type the term
<code class="highlighter-rouge">`zero · `suc `zero</code>.  It cannot be typed, because doing so
requires that the first term in the application is both a natural and
a function:</p>

<pre class="Agda"><a id="nope₁"></a><a id="41223" href="/PLFA-zh/Lambda/#41223" class="Function">nope₁</a> <a id="41229" class="Symbol">:</a> <a id="41231" class="Symbol">∀</a> <a id="41233" class="Symbol">{</a><a id="41234" href="/PLFA-zh/Lambda/#41234" class="Bound">A</a><a id="41235" class="Symbol">}</a> <a id="41237" class="Symbol">→</a> <a id="41239" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="41241" class="Symbol">(</a><a id="41242" href="/PLFA-zh/Lambda/#30865" class="InductiveConstructor">∅</a> <a id="41244" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="41246" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="41252" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="41254" href="/PLFA-zh/Lambda/#4031" class="InductiveConstructor Operator">`suc</a> <a id="41259" href="/PLFA-zh/Lambda/#3997" class="InductiveConstructor">`zero</a> <a id="41265" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="41267" href="/PLFA-zh/Lambda/#41234" class="Bound">A</a><a id="41268" class="Symbol">)</a>
<a id="41270" href="/PLFA-zh/Lambda/#41223" class="Function">nope₁</a> <a id="41276" class="Symbol">(()</a> <a id="41280" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="41282" class="Symbol">_)</a></pre>

<p>As a second example, here is a formal proof that it is not possible to
type <code class="highlighter-rouge">ƛ "x" ⇒ ` "x" · ` "x"</code>. It cannot be typed, because
doing so requires types <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> such that <code class="highlighter-rouge">A ⇒ B ≡ A</code>:</p>

<pre class="Agda"><a id="nope₂"></a><a id="41503" href="/PLFA-zh/Lambda/#41503" class="Function">nope₂</a> <a id="41509" class="Symbol">:</a> <a id="41511" class="Symbol">∀</a> <a id="41513" class="Symbol">{</a><a id="41514" href="/PLFA-zh/Lambda/#41514" class="Bound">A</a><a id="41515" class="Symbol">}</a> <a id="41517" class="Symbol">→</a> <a id="41519" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="41521" class="Symbol">(</a><a id="41522" href="/PLFA-zh/Lambda/#30865" class="InductiveConstructor">∅</a> <a id="41524" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⊢</a> <a id="41526" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">ƛ</a> <a id="41528" class="String">&quot;x&quot;</a> <a id="41532" href="/PLFA-zh/Lambda/#3903" class="InductiveConstructor Operator">⇒</a> <a id="41534" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="41536" class="String">&quot;x&quot;</a> <a id="41540" href="/PLFA-zh/Lambda/#3949" class="InductiveConstructor Operator">·</a> <a id="41542" href="/PLFA-zh/Lambda/#3864" class="InductiveConstructor Operator">`</a> <a id="41544" class="String">&quot;x&quot;</a> <a id="41548" href="/PLFA-zh/Lambda/#33276" class="Datatype Operator">⦂</a> <a id="41550" href="/PLFA-zh/Lambda/#41514" class="Bound">A</a><a id="41551" class="Symbol">)</a>
<a id="41553" href="/PLFA-zh/Lambda/#41503" class="Function">nope₂</a> <a id="41559" class="Symbol">(</a><a id="41560" href="/PLFA-zh/Lambda/#33411" class="InductiveConstructor">⊢ƛ</a> <a id="41563" class="Symbol">(</a><a id="41564" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="41567" href="/PLFA-zh/Lambda/#41567" class="Bound">∋x</a> <a id="41570" href="/PLFA-zh/Lambda/#33518" class="InductiveConstructor Operator">·</a> <a id="41572" href="/PLFA-zh/Lambda/#33332" class="InductiveConstructor">⊢`</a> <a id="41575" href="/PLFA-zh/Lambda/#41575" class="Bound">∋x′</a><a id="41578" class="Symbol">))</a>  <a id="41582" class="Symbol">=</a>  <a id="41585" href="/PLFA-zh/Lambda/#41630" class="Function">contradiction</a> <a id="41599" class="Symbol">(</a><a id="41600" href="/PLFA-zh/Lambda/#40518" class="Function">∋-injective</a> <a id="41612" href="/PLFA-zh/Lambda/#41567" class="Bound">∋x</a> <a id="41615" href="/PLFA-zh/Lambda/#41575" class="Bound">∋x′</a><a id="41618" class="Symbol">)</a>
  <a id="41622" class="Keyword">where</a>
  <a id="41630" href="/PLFA-zh/Lambda/#41630" class="Function">contradiction</a> <a id="41644" class="Symbol">:</a> <a id="41646" class="Symbol">∀</a> <a id="41648" class="Symbol">{</a><a id="41649" href="/PLFA-zh/Lambda/#41649" class="Bound">A</a> <a id="41651" href="/PLFA-zh/Lambda/#41651" class="Bound">B</a><a id="41652" class="Symbol">}</a> <a id="41654" class="Symbol">→</a> <a id="41656" href="https://agda.github.io/agda-stdlib/v0.17/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="41658" class="Symbol">(</a><a id="41659" href="/PLFA-zh/Lambda/#41649" class="Bound">A</a> <a id="41661" href="/PLFA-zh/Lambda/#29188" class="InductiveConstructor Operator">⇒</a> <a id="41663" href="/PLFA-zh/Lambda/#41651" class="Bound">B</a> <a id="41665" href="https://agda.github.io/agda-stdlib/v0.17/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="41667" href="/PLFA-zh/Lambda/#41649" class="Bound">A</a><a id="41668" class="Symbol">)</a>
  <a id="41672" href="/PLFA-zh/Lambda/#41630" class="Function">contradiction</a> <a id="41686" class="Symbol">()</a></pre>

<h4 id="quiz-3">Quiz</h4>

<p>For each of the following, give a type <code class="highlighter-rouge">A</code> for which it is derivable,
or explain why there is no such <code class="highlighter-rouge">A</code>.</p>

<ol>
  <li><code class="highlighter-rouge">∅ , "y" ⦂ `ℕ ⇒ `ℕ , "x" ⦂ `ℕ ⊢ ` "y" · ` "x" ⦂ A</code></li>
  <li><code class="highlighter-rouge">∅ , "y" ⦂ `ℕ ⇒ `ℕ , "x" ⦂ `ℕ ⊢ ` "x" · ` "y" ⦂ A</code></li>
  <li><code class="highlighter-rouge">∅ , "y" ⦂ `ℕ ⇒ `ℕ ⊢ ƛ "x" ⇒ ` "y" · ` "x" ⦂ A</code></li>
</ol>

<p>For each of the following, give types <code class="highlighter-rouge">A</code>, <code class="highlighter-rouge">B</code>, and <code class="highlighter-rouge">C</code> for which it is derivable,
or explain why there are no such types.</p>

<ol>
  <li><code class="highlighter-rouge">∅ , "x" ⦂ A ⊢ ` "x" · ` "x" ⦂ B</code></li>
  <li><code class="highlighter-rouge">∅ , "x" ⦂ A , "y" ⦂ B ⊢ ƛ "z" ⇒ ` "x" · (` "y" · ` "z") ⦂ C</code></li>
</ol>

<h4 id="exercise-mul-type-recommended">Exercise <code class="highlighter-rouge">mul-type</code> (recommended)</h4>

<p>Using the term <code class="highlighter-rouge">mul</code> you defined earlier, write out the derivation
showing that it is well-typed.</p>

<h4 id="exercise-mulᶜ-type">Exercise <code class="highlighter-rouge">mulᶜ-type</code></h4>

<p>Using the term <code class="highlighter-rouge">mulᶜ</code> you defined earlier, write out the derivation
showing that it is well-typed.</p>

<h2 id="unicode">Unicode</h2>

<p>This chapter uses the following unicode:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⇒  U+21D2  RIGHTWARDS DOUBLE ARROW (\=&gt;)
ƛ  U+019B  LATIN SMALL LETTER LAMBDA WITH STROKE (\Gl-)
·  U+00B7  MIDDLE DOT (\cdot)
—  U+2014  EM DASH (\em)
↠  U+21A0  RIGHTWARDS TWO HEADED ARROW (\rr-)
ξ  U+03BE  GREEK SMALL LETTER XI (\Gx or \xi)
β  U+03B2  GREEK SMALL LETTER BETA (\Gb or \beta)
Γ  U+0393  GREEK CAPITAL LETTER GAMMA (\GG or \Gamma)
≠  U+2260  NOT EQUAL TO (\=n or \ne)
∋  U+220B  CONTAINS AS MEMBER (\ni)
∅  U+2205  EMPTY SET (\0)
⊢  U+22A2  RIGHT TACK (\vdash or \|-)
⦂  U+2982  Z NOTATION TYPE COLON (\:)
😇  U+1F607  SMILING FACE WITH HALO
😈  U+1F608  SMILING FACE WITH HORNS
</code></pre></div></div>

<p>We compose reduction <code class="highlighter-rouge">—→</code> from an em dash <code class="highlighter-rouge">—</code> and an arrow <code class="highlighter-rouge">→</code>.
Similarly for reflexive and transitive closure <code class="highlighter-rouge">—↠</code>.</p>

  </div>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Lists/">前一章</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/Lambda.lagda">源代码</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/PLFA-zh/Properties/">后一章</a>
    
</p>


</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/PLFA-zh/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">编程语言基础：Agda 描述
</h2>

    <h3 class="footer-heading">原作者：</h3><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li>
          <li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li>
          <li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><h3 class="footer-heading">本章暂无翻译</h3>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可。<br />
    This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
  </div>
</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/PLFA-zh/assets/jquery.js"></script>

<!-- Script which draws background for progress tags -->
<script type="text/javascript">
$('span.progress').each(function(){
    const progress = parseInt($(this).text());
    $(this).css({
        'border-style': 'solid',
        'border-radius': '5px',
        'border-width': 'thin',
        'border-color': progress === 100 ? 'limegreen' : 'dimgray',
        'font-size': '70%',
        'padding': '0% 0.5% 0% 0.5%',
        'margin': '0em 0em 0em 0.5em',
        'box-sizing': 'border-box',
        'vertical-align': '10%'
    });
    $(this).text(progress.toString() + " %");
})
</script>

<!-- Script which allows for foldable code blocks -->
<script type="text/javascript">
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/PLFA-zh/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
